/* Copyright (c) 2008 The Board of Trustees of The Leland Stanford Junior University */
/* Copyright (c) 2011, 2012 Open Networking Foundation */
/* Copyright (c) 2012, 2013 Big Switch Networks, Inc. */
/* See the file LICENSE.loci which should have been included in the source distribution */

/****************************************************************
 * File: loci.c
 *
 * DO NOT EDIT
 *
 * This file is automatically generated
 *
 ****************************************************************/


/****************************************************************
 *
 * This file is divided into the following sections.
 *
 * Instantiate strings such as object names
 * Special case macros for low level object access
 * Per-class, per-member accessor definitions
 * Per-class new/init function definitions
 * Per-class new/init pointer instantiations
 * Instantiate "set map" for pointer set fns
 *
 ****************************************************************/

#ifdef __GNUC__
#ifdef __linux__
/* glibc */
#include <features.h>
#else
/* NetBSD etc */
#include <sys/cdefs.h>
#ifdef __GNUC_PREREQ__
#define __GNUC_PREREQ __GNUC_PREREQ__
#endif
#endif

#ifndef __GNUC_PREREQ
/* fallback */
#define __GNUC_PREREQ(maj, min) 0
#endif

#if __GNUC_PREREQ(4,4)
#pragma GCC optimize ("s")
#endif

#if __GNUC_PREREQ(4,6)
#pragma GCC diagnostic ignored "-Wunused-but-set-variable"
#endif

#endif

#include <loci/loci.h>
#include <loci/of_object.h>
#include "loci_log.h"


const char *const of_object_id_str[] = {
    "of_object",
    "of_aggregate_stats_reply",
    "of_aggregate_stats_request",
    "of_async_get_reply",
    "of_async_get_request",
    "of_async_set",
    "of_barrier_reply",
    "of_barrier_request",
    "of_bsn_bw_clear_data_reply",
    "of_bsn_bw_clear_data_request",
    "of_bsn_bw_enable_get_reply",
    "of_bsn_bw_enable_get_request",
    "of_bsn_bw_enable_set_reply",
    "of_bsn_bw_enable_set_request",
    "of_bsn_get_interfaces_reply",
    "of_bsn_get_interfaces_request",
    "of_bsn_get_ip_mask_reply",
    "of_bsn_get_ip_mask_request",
    "of_bsn_get_l2_table_reply",
    "of_bsn_get_l2_table_request",
    "of_bsn_get_mirroring_reply",
    "of_bsn_get_mirroring_request",
    "of_bsn_set_ip_mask",
    "of_bsn_set_l2_table_reply",
    "of_bsn_set_l2_table_request",
    "of_bsn_set_mirroring",
    "of_bsn_set_pktin_suppression_reply",
    "of_bsn_set_pktin_suppression_request",
    "of_bsn_shell_command",
    "of_bsn_shell_output",
    "of_bsn_shell_status",
    "of_bsn_virtual_port_create_reply",
    "of_bsn_virtual_port_create_request",
    "of_bsn_virtual_port_remove_reply",
    "of_bsn_virtual_port_remove_request",
    "of_desc_stats_reply",
    "of_desc_stats_request",
    "of_echo_reply",
    "of_echo_request",
    "of_error_msg",
    "of_experimenter",
    "of_experimenter_stats_reply",
    "of_experimenter_stats_request",
    "of_features_reply",
    "of_features_request",
    "of_flow_add",
    "of_flow_delete",
    "of_flow_delete_strict",
    "of_flow_modify",
    "of_flow_modify_strict",
    "of_flow_removed",
    "of_flow_stats_reply",
    "of_flow_stats_request",
    "of_get_config_reply",
    "of_get_config_request",
    "of_group_desc_stats_reply",
    "of_group_desc_stats_request",
    "of_group_features_stats_reply",
    "of_group_features_stats_request",
    "of_group_mod",
    "of_group_stats_reply",
    "of_group_stats_request",
    "of_hello",
    "of_meter_config_stats_reply",
    "of_meter_config_stats_request",
    "of_meter_features_stats_reply",
    "of_meter_features_stats_request",
    "of_meter_mod",
    "of_meter_stats_reply",
    "of_meter_stats_request",
    "of_nicira_controller_role_reply",
    "of_nicira_controller_role_request",
    "of_packet_in",
    "of_packet_out",
    "of_port_desc_stats_reply",
    "of_port_desc_stats_request",
    "of_port_mod",
    "of_port_stats_reply",
    "of_port_stats_request",
    "of_port_status",
    "of_queue_get_config_reply",
    "of_queue_get_config_request",
    "of_queue_stats_reply",
    "of_queue_stats_request",
    "of_role_reply",
    "of_role_request",
    "of_set_config",
    "of_table_features_stats_reply",
    "of_table_features_stats_request",
    "of_table_mod",
    "of_table_stats_reply",
    "of_table_stats_request",

    /* Non-message objects */
    "of_action",
    "of_action_bsn_mirror",
    "of_action_bsn_set_tunnel_dst",
    "of_action_copy_ttl_in",
    "of_action_copy_ttl_out",
    "of_action_dec_mpls_ttl",
    "of_action_dec_nw_ttl",
    "of_action_enqueue",
    "of_action_experimenter",
    "of_action_group",
    "of_action_header",
    "of_action_id",
    "of_action_id_bsn_mirror",
    "of_action_id_bsn_set_tunnel_dst",
    "of_action_id_copy_ttl_in",
    "of_action_id_copy_ttl_out",
    "of_action_id_dec_mpls_ttl",
    "of_action_id_dec_nw_ttl",
    "of_action_id_experimenter",
    "of_action_id_group",
    "of_action_id_header",
    "of_action_id_nicira_dec_ttl",
    "of_action_id_output",
    "of_action_id_pop_mpls",
    "of_action_id_pop_pbb",
    "of_action_id_pop_vlan",
    "of_action_id_push_mpls",
    "of_action_id_push_pbb",
    "of_action_id_push_vlan",
    "of_action_id_set_field",
    "of_action_id_set_mpls_ttl",
    "of_action_id_set_nw_ttl",
    "of_action_id_set_queue",
    "of_action_nicira_dec_ttl",
    "of_action_output",
    "of_action_pop_mpls",
    "of_action_pop_pbb",
    "of_action_pop_vlan",
    "of_action_push_mpls",
    "of_action_push_pbb",
    "of_action_push_vlan",
    "of_action_set_dl_dst",
    "of_action_set_dl_src",
    "of_action_set_field",
    "of_action_set_mpls_label",
    "of_action_set_mpls_tc",
    "of_action_set_mpls_ttl",
    "of_action_set_nw_dst",
    "of_action_set_nw_ecn",
    "of_action_set_nw_src",
    "of_action_set_nw_tos",
    "of_action_set_nw_ttl",
    "of_action_set_queue",
    "of_action_set_tp_dst",
    "of_action_set_tp_src",
    "of_action_set_vlan_pcp",
    "of_action_set_vlan_vid",
    "of_action_strip_vlan",
    "of_bsn_interface",
    "of_bsn_vport",
    "of_bsn_vport_header",
    "of_bsn_vport_q_in_q",
    "of_bucket",
    "of_bucket_counter",
    "of_experimenter_multipart_header",
    "of_flow_stats_entry",
    "of_group_desc_stats_entry",
    "of_group_stats_entry",
    "of_header",
    "of_hello_elem",
    "of_hello_elem_header",
    "of_hello_elem_versionbitmap",
    "of_instruction",
    "of_instruction_apply_actions",
    "of_instruction_clear_actions",
    "of_instruction_experimenter",
    "of_instruction_goto_table",
    "of_instruction_header",
    "of_instruction_meter",
    "of_instruction_write_actions",
    "of_instruction_write_metadata",
    "of_match_v1",
    "of_match_v2",
    "of_match_v3",
    "of_meter_band",
    "of_meter_band_drop",
    "of_meter_band_dscp_remark",
    "of_meter_band_experimenter",
    "of_meter_band_header",
    "of_meter_band_stats",
    "of_meter_config",
    "of_meter_features",
    "of_meter_stats",
    "of_oxm",
    "of_oxm_arp_op",
    "of_oxm_arp_op_masked",
    "of_oxm_arp_sha",
    "of_oxm_arp_sha_masked",
    "of_oxm_arp_spa",
    "of_oxm_arp_spa_masked",
    "of_oxm_arp_tha",
    "of_oxm_arp_tha_masked",
    "of_oxm_arp_tpa",
    "of_oxm_arp_tpa_masked",
    "of_oxm_eth_dst",
    "of_oxm_eth_dst_masked",
    "of_oxm_eth_src",
    "of_oxm_eth_src_masked",
    "of_oxm_eth_type",
    "of_oxm_eth_type_masked",
    "of_oxm_header",
    "of_oxm_icmpv4_code",
    "of_oxm_icmpv4_code_masked",
    "of_oxm_icmpv4_type",
    "of_oxm_icmpv4_type_masked",
    "of_oxm_icmpv6_code",
    "of_oxm_icmpv6_code_masked",
    "of_oxm_icmpv6_type",
    "of_oxm_icmpv6_type_masked",
    "of_oxm_in_phy_port",
    "of_oxm_in_phy_port_masked",
    "of_oxm_in_port",
    "of_oxm_in_port_masked",
    "of_oxm_ip_dscp",
    "of_oxm_ip_dscp_masked",
    "of_oxm_ip_ecn",
    "of_oxm_ip_ecn_masked",
    "of_oxm_ip_proto",
    "of_oxm_ip_proto_masked",
    "of_oxm_ipv4_dst",
    "of_oxm_ipv4_dst_masked",
    "of_oxm_ipv4_src",
    "of_oxm_ipv4_src_masked",
    "of_oxm_ipv6_dst",
    "of_oxm_ipv6_dst_masked",
    "of_oxm_ipv6_flabel",
    "of_oxm_ipv6_flabel_masked",
    "of_oxm_ipv6_nd_sll",
    "of_oxm_ipv6_nd_sll_masked",
    "of_oxm_ipv6_nd_target",
    "of_oxm_ipv6_nd_target_masked",
    "of_oxm_ipv6_nd_tll",
    "of_oxm_ipv6_nd_tll_masked",
    "of_oxm_ipv6_src",
    "of_oxm_ipv6_src_masked",
    "of_oxm_metadata",
    "of_oxm_metadata_masked",
    "of_oxm_mpls_label",
    "of_oxm_mpls_label_masked",
    "of_oxm_mpls_tc",
    "of_oxm_mpls_tc_masked",
    "of_oxm_sctp_dst",
    "of_oxm_sctp_dst_masked",
    "of_oxm_sctp_src",
    "of_oxm_sctp_src_masked",
    "of_oxm_tcp_dst",
    "of_oxm_tcp_dst_masked",
    "of_oxm_tcp_src",
    "of_oxm_tcp_src_masked",
    "of_oxm_udp_dst",
    "of_oxm_udp_dst_masked",
    "of_oxm_udp_src",
    "of_oxm_udp_src_masked",
    "of_oxm_vlan_pcp",
    "of_oxm_vlan_pcp_masked",
    "of_oxm_vlan_vid",
    "of_oxm_vlan_vid_masked",
    "of_packet_queue",
    "of_port_desc",
    "of_port_stats_entry",
    "of_queue_prop",
    "of_queue_prop_experimenter",
    "of_queue_prop_header",
    "of_queue_prop_max_rate",
    "of_queue_prop_min_rate",
    "of_queue_stats_entry",
    "of_table_feature_prop",
    "of_table_feature_prop_apply_actions",
    "of_table_feature_prop_apply_actions_miss",
    "of_table_feature_prop_apply_setfield",
    "of_table_feature_prop_apply_setfield_miss",
    "of_table_feature_prop_experimenter",
    "of_table_feature_prop_header",
    "of_table_feature_prop_instructions",
    "of_table_feature_prop_instructions_miss",
    "of_table_feature_prop_match",
    "of_table_feature_prop_next_tables",
    "of_table_feature_prop_next_tables_miss",
    "of_table_feature_prop_wildcards",
    "of_table_feature_prop_write_actions",
    "of_table_feature_prop_write_actions_miss",
    "of_table_feature_prop_write_setfield",
    "of_table_feature_prop_write_setfield_miss",
    "of_table_features",
    "of_table_stats_entry",
    "of_uint32",
    "of_uint8",

    /* List objects */
    "of_list_action",
    "of_list_action_id",
    "of_list_bsn_interface",
    "of_list_bucket",
    "of_list_bucket_counter",
    "of_list_flow_stats_entry",
    "of_list_group_desc_stats_entry",
    "of_list_group_stats_entry",
    "of_list_hello_elem",
    "of_list_instruction",
    "of_list_meter_band",
    "of_list_meter_band_stats",
    "of_list_meter_stats",
    "of_list_oxm",
    "of_list_packet_queue",
    "of_list_port_desc",
    "of_list_port_stats_entry",
    "of_list_queue_prop",
    "of_list_queue_stats_entry",
    "of_list_table_feature_prop",
    "of_list_table_features",
    "of_list_table_stats_entry",
    "of_list_uint32",
    "of_list_uint8",

    /* Generic stats request/reply types; pseudo objects */
    "of_flow_mod",
    "of_stats_reply",
    "of_stats_request",

    "of_unknown_object"
};

 const char *const of_version_str[] = {
    "Unknown OpenFlow Version",
    "OpenFlow-1.0",
    "OpenFlow-1.1",
    "OpenFlow-1.2"
};

const of_mac_addr_t of_mac_addr_all_ones = {
    {
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    }
};
/* Just to be explicit; static duration vars are init'd to 0 */
const of_mac_addr_t of_mac_addr_all_zeros = {
    {
        0, 0, 0, 0, 0, 0
    }
};

const of_ipv6_t of_ipv6_all_ones = {
    {
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff
    }
};
/* Just to be explicit; static duration vars are init'd to 0 */
const of_ipv6_t of_ipv6_all_zeros = {
    {
        0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0
    }
};

/** @var of_error_strings
 * The error string map; use abs value to index
 */
const char *const of_error_strings[] = { OF_ERROR_STRINGS };

/****************************************************************
 * Special case macros for calculating variable lengths and offsets
 ****************************************************************/

/**
 * Get a u16 directly from an offset in an object's wire buffer
 * @param obj An of_object_t object
 * @param offset Base offset of the uint16 relative to the object
 *
 */

static inline int
of_object_u16_get(of_object_t *obj, int offset) {
    uint16_t val16;

    of_wire_buffer_u16_get(obj->wire_object.wbuf,
        obj->wire_object.obj_offset + offset, &val16);

    return (int)val16;
}

/**
 * Set a u16 directly at an offset in an object's wire buffer
 * @param obj An of_object_t object
 * @param offset Base offset of the uint16 relative to the object
 * @param val The value to store
 *
 */

static inline void
of_object_u16_set(of_object_t *obj, int offset, int value) {
    uint16_t val16;

    val16 = (uint16_t)value;
    of_wire_buffer_u16_set(obj->wire_object.wbuf,
        obj->wire_object.obj_offset + offset, val16);
}

/**
 * Get length of an object with a TLV header with uint16_t
 * @param obj An object with a match member
 * @param offset The wire offset of the start of the object
 *
 * The length field follows the type field.
 */

#define _TLV16_LEN(obj, offset) \
    (of_object_u16_get((of_object_t *)(obj), (offset) + 2))

/**
 * Get length of an object that is the "rest" of the object
 * @param obj An object with a match member
 * @param offset The wire offset of the start of the object
 *
 */

#define _END_LEN(obj, offset) ((obj)->length - (offset))

/**
 * Offset of the action_len member in a packet-out object
 */

#define _PACKET_OUT_ACTION_LEN_OFFSET(obj) \
    (((obj)->version == OF_VERSION_1_0) ? 14 : 16)

/**
 * Get length of the action list object in a packet_out object
 * @param obj An object of type of_packet_out
 */

#define _PACKET_OUT_ACTION_LEN(obj) \
    (of_object_u16_get((of_object_t *)(obj), _PACKET_OUT_ACTION_LEN_OFFSET(obj)))

/**
 * Set length of the action list object in a packet_out object
 * @param obj An object of type of_packet_out
 */

#define _PACKET_OUT_ACTION_LEN_SET(obj, len) \
    (of_object_u16_set((of_object_t *)(obj), _PACKET_OUT_ACTION_LEN_OFFSET(obj), len))

/*
 * Match structs in 1.2 come at the end of the fixed length part
 * of structures.  They add 8 bytes to the minimal length of the
 * message, but are also variable length.  This means that the
 * type/length offsets are 8 bytes back from the end of the fixed
 * length part of the object.  The right way to handle this is to
 * expose the offset of the match member more explicitly.  For now,
 * we make the calculation as described here.
 */

/* 1.2 min length of match is 8 bytes */
#define _MATCH_MIN_LENGTH_V3 8

/**
 * The offset of a 1.2 match object relative to fixed length of obj
 */
#define _MATCH_OFFSET_V3(fixed_obj_len) \
    ((fixed_obj_len) - _MATCH_MIN_LENGTH_V3)

/**
 * The "extra" length beyond the minimal 8 bytes of a match struct
 * in an object
 */
#define _MATCH_EXTRA_LENGTH_V3(obj, fixed_obj_len) \
    (OF_MATCH_BYTES(_TLV16_LEN(obj, _MATCH_OFFSET_V3(fixed_obj_len))) - \
     _MATCH_MIN_LENGTH_V3)

/**
 * The offset of an object following a match object for 1.2
 */
#define _OFFSET_FOLLOWING_MATCH_V3(obj, fixed_obj_len) \
    ((fixed_obj_len) + _MATCH_EXTRA_LENGTH_V3(obj, fixed_obj_len))

/**
 * Get length of a match object from its wire representation
 * @param obj An object with a match member
 * @param match_offset The wire offset of the match object.
 *
 * See above; for 1.2,
 * The match length is raw bytes but the actual space it takes
 * up is padded for alignment to 64-bits
 */
#define _WIRE_MATCH_LEN(obj, match_offset) \
    (((obj)->version == OF_VERSION_1_0) ? 40 : \
     (((obj)->version == OF_VERSION_1_1) ? 88 : \
      _TLV16_LEN(obj, match_offset)))

#define _WIRE_LEN_MIN 4

/*
 * Wrapper function for match len.  There are cases where the wire buffer
 * has not been set with the proper minimum length.  In this case, the
 * wire match len is interpretted as its minimum length, 4 bytes.
 */

static inline int
wire_match_len(of_object_t *obj, int match_offset) {
    int len;

    len = _WIRE_MATCH_LEN(obj, match_offset);

    return (len == 0) ? _WIRE_LEN_MIN : len;
}

#define _WIRE_MATCH_PADDED_LEN(obj, match_offset) \
    OF_MATCH_BYTES(wire_match_len((of_object_t *)(obj), (match_offset)))

/**
 * Macro to calculate variable offset of instructions member in flow mod
 * @param obj An object of some type of flow modify/add/delete
 *
 * Get length of preceding match object and add to fixed length
 * Applies only to version 1.2
 */

#define _FLOW_MOD_INSTRUCTIONS_OFFSET(obj) \
    _OFFSET_FOLLOWING_MATCH_V3(obj, 56)

/* The different flavors of flow mod all use the above */
#define _FLOW_ADD_INSTRUCTIONS_OFFSET(obj) \
    _FLOW_MOD_INSTRUCTIONS_OFFSET(obj)
#define _FLOW_MODIFY_INSTRUCTIONS_OFFSET(obj) \
    _FLOW_MOD_INSTRUCTIONS_OFFSET(obj)
#define _FLOW_MODIFY_STRICT_INSTRUCTIONS_OFFSET(obj) \
    _FLOW_MOD_INSTRUCTIONS_OFFSET(obj)
#define _FLOW_DELETE_INSTRUCTIONS_OFFSET(obj) \
    _FLOW_MOD_INSTRUCTIONS_OFFSET(obj)
#define _FLOW_DELETE_STRICT_INSTRUCTIONS_OFFSET(obj) \
    _FLOW_MOD_INSTRUCTIONS_OFFSET(obj)

/**
 * Macro to calculate variable offset of instructions member in flow stats
 * @param obj An object of type of_flow_mod_t
 *
 * Get length of preceding match object and add to fixed length
 * Applies only to version 1.2 and 1.3
 */

#define _FLOW_STATS_ENTRY_INSTRUCTIONS_OFFSET(obj) \
    _OFFSET_FOLLOWING_MATCH_V3(obj, 56)

/**
 * Macro to calculate variable offset of data (packet) member in packet_in
 * @param obj An object of type of_packet_in_t
 *
 * Get length of preceding match object and add to fixed length
 * Applies only to version 1.2 and 1.3
 * The +2 comes from the 2 bytes of padding between the match and packet data.
 */

#define _PACKET_IN_DATA_OFFSET(obj) \
    (_OFFSET_FOLLOWING_MATCH_V3((obj), (obj)->version == OF_VERSION_1_2 ? 24 : 32) + 2)

/**
 * Macro to calculate variable offset of data (packet) member in packet_out
 * @param obj An object of type of_packet_out_t
 *
 * Find the length in the actions_len variable and add to the fixed len
 * Applies only to version 1.2 and 1.3
 */

#define _PACKET_OUT_DATA_OFFSET(obj) (_PACKET_OUT_ACTION_LEN(obj) + \
     of_object_fixed_len[(obj)->version][OF_PACKET_OUT])

/**
 * Macro to map port numbers that changed across versions
 * @param port The port_no_t variable holding the value
 * @param ver The OpenFlow version from which the value was extracted
 */
#define OF_PORT_NO_VALUE_CHECK(port, ver) \
    if (((ver) == OF_VERSION_1_0) && ((port) > 0xff00)) (port) += 0xffff0000


/**
 * Macro to detect if an object ID falls in the "flow mod" family of objects
 * This includes add, modify, modify_strict, delete and delete_strict
 */
#define IS_FLOW_MOD_SUBTYPE(object_id)                 \
    (((object_id) == OF_FLOW_MODIFY) ||                \
     ((object_id) == OF_FLOW_MODIFY_STRICT) ||         \
     ((object_id) == OF_FLOW_DELETE) ||                \
     ((object_id) == OF_FLOW_DELETE_STRICT) ||         \
     ((object_id) == OF_FLOW_ADD))

/****************************************************************
 *
 * Unified accessor function definitions
 *
 ****************************************************************/

/* Unified accessor functions for of_aggregate_stats_reply */
/** \ingroup of_aggregate_stats_reply 
 * @{ */

/**
 * Get xid from an object of type of_aggregate_stats_reply.
 * @param obj Pointer to an object of type of_aggregate_stats_reply.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_aggregate_stats_reply_xid_get(
    of_aggregate_stats_reply_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_AGGREGATE_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_aggregate_stats_reply.
 * @param obj Pointer to an object of type of_aggregate_stats_reply.
 * @param xid The value to write into the object
 */
void
of_aggregate_stats_reply_xid_set(
    of_aggregate_stats_reply_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_AGGREGATE_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get flags from an object of type of_aggregate_stats_reply.
 * @param obj Pointer to an object of type of_aggregate_stats_reply.
 * @param flags Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_aggregate_stats_reply_flags_get(
    of_aggregate_stats_reply_t *obj,
    uint16_t *flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_AGGREGATE_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set flags in an object of type of_aggregate_stats_reply.
 * @param obj Pointer to an object of type of_aggregate_stats_reply.
 * @param flags The value to write into the object
 */
void
of_aggregate_stats_reply_flags_set(
    of_aggregate_stats_reply_t *obj,
    uint16_t flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_AGGREGATE_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get packet_count from an object of type of_aggregate_stats_reply.
 * @param obj Pointer to an object of type of_aggregate_stats_reply.
 * @param packet_count Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_aggregate_stats_reply_packet_count_get(
    of_aggregate_stats_reply_t *obj,
    uint64_t *packet_count)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_AGGREGATE_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, packet_count);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set packet_count in an object of type of_aggregate_stats_reply.
 * @param obj Pointer to an object of type of_aggregate_stats_reply.
 * @param packet_count The value to write into the object
 */
void
of_aggregate_stats_reply_packet_count_set(
    of_aggregate_stats_reply_t *obj,
    uint64_t packet_count)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_AGGREGATE_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, packet_count);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get byte_count from an object of type of_aggregate_stats_reply.
 * @param obj Pointer to an object of type of_aggregate_stats_reply.
 * @param byte_count Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_aggregate_stats_reply_byte_count_get(
    of_aggregate_stats_reply_t *obj,
    uint64_t *byte_count)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_AGGREGATE_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 20;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 24;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, byte_count);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set byte_count in an object of type of_aggregate_stats_reply.
 * @param obj Pointer to an object of type of_aggregate_stats_reply.
 * @param byte_count The value to write into the object
 */
void
of_aggregate_stats_reply_byte_count_set(
    of_aggregate_stats_reply_t *obj,
    uint64_t byte_count)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_AGGREGATE_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 20;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 24;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, byte_count);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get flow_count from an object of type of_aggregate_stats_reply.
 * @param obj Pointer to an object of type of_aggregate_stats_reply.
 * @param flow_count Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_aggregate_stats_reply_flow_count_get(
    of_aggregate_stats_reply_t *obj,
    uint32_t *flow_count)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_AGGREGATE_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 28;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 32;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, flow_count);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set flow_count in an object of type of_aggregate_stats_reply.
 * @param obj Pointer to an object of type of_aggregate_stats_reply.
 * @param flow_count The value to write into the object
 */
void
of_aggregate_stats_reply_flow_count_set(
    of_aggregate_stats_reply_t *obj,
    uint32_t flow_count)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_AGGREGATE_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 28;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 32;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, flow_count);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_aggregate_stats_request */
/** \ingroup of_aggregate_stats_request 
 * @{ */

/**
 * Get xid from an object of type of_aggregate_stats_request.
 * @param obj Pointer to an object of type of_aggregate_stats_request.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_aggregate_stats_request_xid_get(
    of_aggregate_stats_request_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_AGGREGATE_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_aggregate_stats_request.
 * @param obj Pointer to an object of type of_aggregate_stats_request.
 * @param xid The value to write into the object
 */
void
of_aggregate_stats_request_xid_set(
    of_aggregate_stats_request_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_AGGREGATE_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get flags from an object of type of_aggregate_stats_request.
 * @param obj Pointer to an object of type of_aggregate_stats_request.
 * @param flags Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_aggregate_stats_request_flags_get(
    of_aggregate_stats_request_t *obj,
    uint16_t *flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_AGGREGATE_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set flags in an object of type of_aggregate_stats_request.
 * @param obj Pointer to an object of type of_aggregate_stats_request.
 * @param flags The value to write into the object
 */
void
of_aggregate_stats_request_flags_set(
    of_aggregate_stats_request_t *obj,
    uint16_t flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_AGGREGATE_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get table_id from an object of type of_aggregate_stats_request.
 * @param obj Pointer to an object of type of_aggregate_stats_request.
 * @param table_id Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_aggregate_stats_request_table_id_get(
    of_aggregate_stats_request_t *obj,
    uint8_t *table_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_AGGREGATE_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 52;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, table_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set table_id in an object of type of_aggregate_stats_request.
 * @param obj Pointer to an object of type of_aggregate_stats_request.
 * @param table_id The value to write into the object
 */
void
of_aggregate_stats_request_table_id_set(
    of_aggregate_stats_request_t *obj,
    uint8_t table_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_AGGREGATE_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 52;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, table_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get out_port from an object of type of_aggregate_stats_request.
 * @param obj Pointer to an object of type of_aggregate_stats_request.
 * @param out_port Pointer to the child object of type
 * of_port_no_t to be filled out.
 *
 */
void
of_aggregate_stats_request_out_port_get(
    of_aggregate_stats_request_t *obj,
    of_port_no_t *out_port)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_AGGREGATE_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 54;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 20;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_get(ver, wbuf, abs_offset, out_port);
    OF_PORT_NO_VALUE_CHECK(*out_port, ver);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set out_port in an object of type of_aggregate_stats_request.
 * @param obj Pointer to an object of type of_aggregate_stats_request.
 * @param out_port The value to write into the object
 */
void
of_aggregate_stats_request_out_port_set(
    of_aggregate_stats_request_t *obj,
    of_port_no_t out_port)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_AGGREGATE_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 54;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 20;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_set(ver, wbuf, abs_offset, out_port);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get out_group from an object of type of_aggregate_stats_request.
 * @param obj Pointer to an object of type of_aggregate_stats_request.
 * @param out_group Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_aggregate_stats_request_out_group_get(
    of_aggregate_stats_request_t *obj,
    uint32_t *out_group)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_AGGREGATE_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 24;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, out_group);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set out_group in an object of type of_aggregate_stats_request.
 * @param obj Pointer to an object of type of_aggregate_stats_request.
 * @param out_group The value to write into the object
 */
void
of_aggregate_stats_request_out_group_set(
    of_aggregate_stats_request_t *obj,
    uint32_t out_group)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_AGGREGATE_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 24;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, out_group);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get cookie from an object of type of_aggregate_stats_request.
 * @param obj Pointer to an object of type of_aggregate_stats_request.
 * @param cookie Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_aggregate_stats_request_cookie_get(
    of_aggregate_stats_request_t *obj,
    uint64_t *cookie)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_AGGREGATE_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 32;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, cookie);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set cookie in an object of type of_aggregate_stats_request.
 * @param obj Pointer to an object of type of_aggregate_stats_request.
 * @param cookie The value to write into the object
 */
void
of_aggregate_stats_request_cookie_set(
    of_aggregate_stats_request_t *obj,
    uint64_t cookie)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_AGGREGATE_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 32;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, cookie);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get cookie_mask from an object of type of_aggregate_stats_request.
 * @param obj Pointer to an object of type of_aggregate_stats_request.
 * @param cookie_mask Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_aggregate_stats_request_cookie_mask_get(
    of_aggregate_stats_request_t *obj,
    uint64_t *cookie_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_AGGREGATE_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 40;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, cookie_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set cookie_mask in an object of type of_aggregate_stats_request.
 * @param obj Pointer to an object of type of_aggregate_stats_request.
 * @param cookie_mask The value to write into the object
 */
void
of_aggregate_stats_request_cookie_mask_set(
    of_aggregate_stats_request_t *obj,
    uint64_t cookie_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_AGGREGATE_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 40;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, cookie_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get match from an object of type of_aggregate_stats_request.
 * @param obj Pointer to an object of type of_aggregate_stats_request.
 * @param match Pointer to the child object of type
 * of_match_t to be filled out.
 *
 */
int WARN_UNUSED_RESULT
of_aggregate_stats_request_match_get(
    of_aggregate_stats_request_t *obj,
    of_match_t *match)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    of_octets_t match_octets; /* Serialized string for match */

    ASSERT(obj->object_id == OF_AGGREGATE_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    case OF_VERSION_1_1:
        offset = 48;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 48;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    ASSERT(cur_len + abs_offset <= WBUF_CURRENT_BYTES(wbuf));
    match_octets.bytes = cur_len;
    match_octets.data = OF_OBJECT_BUFFER_INDEX(obj, offset);
    OF_TRY(of_match_deserialize(ver, match, &match_octets));

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/**
 * Set match in an object of type of_aggregate_stats_request.
 * @param obj Pointer to an object of type of_aggregate_stats_request.
 * @param match Pointer to the child of type of_match_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_aggregate_stats_request_match_set(
    of_aggregate_stats_request_t *obj,
    of_match_t *match)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */
    of_octets_t match_octets; /* Serialized string for match */

    ASSERT(obj->object_id == OF_AGGREGATE_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    case OF_VERSION_1_1:
        offset = 48;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 48;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Match object */
    OF_TRY(of_match_serialize(ver, match, &match_octets));
    new_len = match_octets.bytes;
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        match_octets.data, new_len);
    /* Free match serialized octets */
    FREE(match_octets.data);

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_async_get_reply */
/** \ingroup of_async_get_reply 
 * @{ */

/**
 * Get xid from an object of type of_async_get_reply.
 * @param obj Pointer to an object of type of_async_get_reply.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_async_get_reply_xid_get(
    of_async_get_reply_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ASYNC_GET_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_async_get_reply.
 * @param obj Pointer to an object of type of_async_get_reply.
 * @param xid The value to write into the object
 */
void
of_async_get_reply_xid_set(
    of_async_get_reply_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ASYNC_GET_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get packet_in_mask_equal_master from an object of type of_async_get_reply.
 * @param obj Pointer to an object of type of_async_get_reply.
 * @param packet_in_mask_equal_master Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_async_get_reply_packet_in_mask_equal_master_get(
    of_async_get_reply_t *obj,
    uint32_t *packet_in_mask_equal_master)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ASYNC_GET_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, packet_in_mask_equal_master);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set packet_in_mask_equal_master in an object of type of_async_get_reply.
 * @param obj Pointer to an object of type of_async_get_reply.
 * @param packet_in_mask_equal_master The value to write into the object
 */
void
of_async_get_reply_packet_in_mask_equal_master_set(
    of_async_get_reply_t *obj,
    uint32_t packet_in_mask_equal_master)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ASYNC_GET_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, packet_in_mask_equal_master);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get packet_in_mask_slave from an object of type of_async_get_reply.
 * @param obj Pointer to an object of type of_async_get_reply.
 * @param packet_in_mask_slave Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_async_get_reply_packet_in_mask_slave_get(
    of_async_get_reply_t *obj,
    uint32_t *packet_in_mask_slave)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ASYNC_GET_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, packet_in_mask_slave);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set packet_in_mask_slave in an object of type of_async_get_reply.
 * @param obj Pointer to an object of type of_async_get_reply.
 * @param packet_in_mask_slave The value to write into the object
 */
void
of_async_get_reply_packet_in_mask_slave_set(
    of_async_get_reply_t *obj,
    uint32_t packet_in_mask_slave)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ASYNC_GET_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, packet_in_mask_slave);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get port_status_mask_equal_master from an object of type of_async_get_reply.
 * @param obj Pointer to an object of type of_async_get_reply.
 * @param port_status_mask_equal_master Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_async_get_reply_port_status_mask_equal_master_get(
    of_async_get_reply_t *obj,
    uint32_t *port_status_mask_equal_master)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ASYNC_GET_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, port_status_mask_equal_master);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set port_status_mask_equal_master in an object of type of_async_get_reply.
 * @param obj Pointer to an object of type of_async_get_reply.
 * @param port_status_mask_equal_master The value to write into the object
 */
void
of_async_get_reply_port_status_mask_equal_master_set(
    of_async_get_reply_t *obj,
    uint32_t port_status_mask_equal_master)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ASYNC_GET_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, port_status_mask_equal_master);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get port_status_mask_slave from an object of type of_async_get_reply.
 * @param obj Pointer to an object of type of_async_get_reply.
 * @param port_status_mask_slave Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_async_get_reply_port_status_mask_slave_get(
    of_async_get_reply_t *obj,
    uint32_t *port_status_mask_slave)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ASYNC_GET_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 20;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, port_status_mask_slave);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set port_status_mask_slave in an object of type of_async_get_reply.
 * @param obj Pointer to an object of type of_async_get_reply.
 * @param port_status_mask_slave The value to write into the object
 */
void
of_async_get_reply_port_status_mask_slave_set(
    of_async_get_reply_t *obj,
    uint32_t port_status_mask_slave)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ASYNC_GET_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 20;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, port_status_mask_slave);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get flow_removed_mask_equal_master from an object of type of_async_get_reply.
 * @param obj Pointer to an object of type of_async_get_reply.
 * @param flow_removed_mask_equal_master Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_async_get_reply_flow_removed_mask_equal_master_get(
    of_async_get_reply_t *obj,
    uint32_t *flow_removed_mask_equal_master)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ASYNC_GET_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 24;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, flow_removed_mask_equal_master);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set flow_removed_mask_equal_master in an object of type of_async_get_reply.
 * @param obj Pointer to an object of type of_async_get_reply.
 * @param flow_removed_mask_equal_master The value to write into the object
 */
void
of_async_get_reply_flow_removed_mask_equal_master_set(
    of_async_get_reply_t *obj,
    uint32_t flow_removed_mask_equal_master)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ASYNC_GET_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 24;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, flow_removed_mask_equal_master);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get flow_removed_mask_slave from an object of type of_async_get_reply.
 * @param obj Pointer to an object of type of_async_get_reply.
 * @param flow_removed_mask_slave Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_async_get_reply_flow_removed_mask_slave_get(
    of_async_get_reply_t *obj,
    uint32_t *flow_removed_mask_slave)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ASYNC_GET_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 28;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, flow_removed_mask_slave);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set flow_removed_mask_slave in an object of type of_async_get_reply.
 * @param obj Pointer to an object of type of_async_get_reply.
 * @param flow_removed_mask_slave The value to write into the object
 */
void
of_async_get_reply_flow_removed_mask_slave_set(
    of_async_get_reply_t *obj,
    uint32_t flow_removed_mask_slave)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ASYNC_GET_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 28;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, flow_removed_mask_slave);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_async_get_request */
/** \ingroup of_async_get_request 
 * @{ */

/**
 * Get xid from an object of type of_async_get_request.
 * @param obj Pointer to an object of type of_async_get_request.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_async_get_request_xid_get(
    of_async_get_request_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ASYNC_GET_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_async_get_request.
 * @param obj Pointer to an object of type of_async_get_request.
 * @param xid The value to write into the object
 */
void
of_async_get_request_xid_set(
    of_async_get_request_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ASYNC_GET_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get packet_in_mask_equal_master from an object of type of_async_get_request.
 * @param obj Pointer to an object of type of_async_get_request.
 * @param packet_in_mask_equal_master Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_async_get_request_packet_in_mask_equal_master_get(
    of_async_get_request_t *obj,
    uint32_t *packet_in_mask_equal_master)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ASYNC_GET_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, packet_in_mask_equal_master);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set packet_in_mask_equal_master in an object of type of_async_get_request.
 * @param obj Pointer to an object of type of_async_get_request.
 * @param packet_in_mask_equal_master The value to write into the object
 */
void
of_async_get_request_packet_in_mask_equal_master_set(
    of_async_get_request_t *obj,
    uint32_t packet_in_mask_equal_master)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ASYNC_GET_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, packet_in_mask_equal_master);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get packet_in_mask_slave from an object of type of_async_get_request.
 * @param obj Pointer to an object of type of_async_get_request.
 * @param packet_in_mask_slave Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_async_get_request_packet_in_mask_slave_get(
    of_async_get_request_t *obj,
    uint32_t *packet_in_mask_slave)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ASYNC_GET_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, packet_in_mask_slave);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set packet_in_mask_slave in an object of type of_async_get_request.
 * @param obj Pointer to an object of type of_async_get_request.
 * @param packet_in_mask_slave The value to write into the object
 */
void
of_async_get_request_packet_in_mask_slave_set(
    of_async_get_request_t *obj,
    uint32_t packet_in_mask_slave)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ASYNC_GET_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, packet_in_mask_slave);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get port_status_mask_equal_master from an object of type of_async_get_request.
 * @param obj Pointer to an object of type of_async_get_request.
 * @param port_status_mask_equal_master Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_async_get_request_port_status_mask_equal_master_get(
    of_async_get_request_t *obj,
    uint32_t *port_status_mask_equal_master)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ASYNC_GET_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, port_status_mask_equal_master);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set port_status_mask_equal_master in an object of type of_async_get_request.
 * @param obj Pointer to an object of type of_async_get_request.
 * @param port_status_mask_equal_master The value to write into the object
 */
void
of_async_get_request_port_status_mask_equal_master_set(
    of_async_get_request_t *obj,
    uint32_t port_status_mask_equal_master)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ASYNC_GET_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, port_status_mask_equal_master);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get port_status_mask_slave from an object of type of_async_get_request.
 * @param obj Pointer to an object of type of_async_get_request.
 * @param port_status_mask_slave Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_async_get_request_port_status_mask_slave_get(
    of_async_get_request_t *obj,
    uint32_t *port_status_mask_slave)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ASYNC_GET_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 20;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, port_status_mask_slave);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set port_status_mask_slave in an object of type of_async_get_request.
 * @param obj Pointer to an object of type of_async_get_request.
 * @param port_status_mask_slave The value to write into the object
 */
void
of_async_get_request_port_status_mask_slave_set(
    of_async_get_request_t *obj,
    uint32_t port_status_mask_slave)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ASYNC_GET_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 20;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, port_status_mask_slave);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get flow_removed_mask_equal_master from an object of type of_async_get_request.
 * @param obj Pointer to an object of type of_async_get_request.
 * @param flow_removed_mask_equal_master Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_async_get_request_flow_removed_mask_equal_master_get(
    of_async_get_request_t *obj,
    uint32_t *flow_removed_mask_equal_master)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ASYNC_GET_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 24;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, flow_removed_mask_equal_master);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set flow_removed_mask_equal_master in an object of type of_async_get_request.
 * @param obj Pointer to an object of type of_async_get_request.
 * @param flow_removed_mask_equal_master The value to write into the object
 */
void
of_async_get_request_flow_removed_mask_equal_master_set(
    of_async_get_request_t *obj,
    uint32_t flow_removed_mask_equal_master)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ASYNC_GET_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 24;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, flow_removed_mask_equal_master);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get flow_removed_mask_slave from an object of type of_async_get_request.
 * @param obj Pointer to an object of type of_async_get_request.
 * @param flow_removed_mask_slave Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_async_get_request_flow_removed_mask_slave_get(
    of_async_get_request_t *obj,
    uint32_t *flow_removed_mask_slave)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ASYNC_GET_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 28;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, flow_removed_mask_slave);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set flow_removed_mask_slave in an object of type of_async_get_request.
 * @param obj Pointer to an object of type of_async_get_request.
 * @param flow_removed_mask_slave The value to write into the object
 */
void
of_async_get_request_flow_removed_mask_slave_set(
    of_async_get_request_t *obj,
    uint32_t flow_removed_mask_slave)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ASYNC_GET_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 28;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, flow_removed_mask_slave);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_async_set */
/** \ingroup of_async_set 
 * @{ */

/**
 * Get xid from an object of type of_async_set.
 * @param obj Pointer to an object of type of_async_set.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_async_set_xid_get(
    of_async_set_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ASYNC_SET);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_async_set.
 * @param obj Pointer to an object of type of_async_set.
 * @param xid The value to write into the object
 */
void
of_async_set_xid_set(
    of_async_set_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ASYNC_SET);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get packet_in_mask_equal_master from an object of type of_async_set.
 * @param obj Pointer to an object of type of_async_set.
 * @param packet_in_mask_equal_master Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_async_set_packet_in_mask_equal_master_get(
    of_async_set_t *obj,
    uint32_t *packet_in_mask_equal_master)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ASYNC_SET);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, packet_in_mask_equal_master);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set packet_in_mask_equal_master in an object of type of_async_set.
 * @param obj Pointer to an object of type of_async_set.
 * @param packet_in_mask_equal_master The value to write into the object
 */
void
of_async_set_packet_in_mask_equal_master_set(
    of_async_set_t *obj,
    uint32_t packet_in_mask_equal_master)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ASYNC_SET);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, packet_in_mask_equal_master);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get packet_in_mask_slave from an object of type of_async_set.
 * @param obj Pointer to an object of type of_async_set.
 * @param packet_in_mask_slave Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_async_set_packet_in_mask_slave_get(
    of_async_set_t *obj,
    uint32_t *packet_in_mask_slave)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ASYNC_SET);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, packet_in_mask_slave);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set packet_in_mask_slave in an object of type of_async_set.
 * @param obj Pointer to an object of type of_async_set.
 * @param packet_in_mask_slave The value to write into the object
 */
void
of_async_set_packet_in_mask_slave_set(
    of_async_set_t *obj,
    uint32_t packet_in_mask_slave)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ASYNC_SET);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, packet_in_mask_slave);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get port_status_mask_equal_master from an object of type of_async_set.
 * @param obj Pointer to an object of type of_async_set.
 * @param port_status_mask_equal_master Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_async_set_port_status_mask_equal_master_get(
    of_async_set_t *obj,
    uint32_t *port_status_mask_equal_master)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ASYNC_SET);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, port_status_mask_equal_master);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set port_status_mask_equal_master in an object of type of_async_set.
 * @param obj Pointer to an object of type of_async_set.
 * @param port_status_mask_equal_master The value to write into the object
 */
void
of_async_set_port_status_mask_equal_master_set(
    of_async_set_t *obj,
    uint32_t port_status_mask_equal_master)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ASYNC_SET);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, port_status_mask_equal_master);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get port_status_mask_slave from an object of type of_async_set.
 * @param obj Pointer to an object of type of_async_set.
 * @param port_status_mask_slave Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_async_set_port_status_mask_slave_get(
    of_async_set_t *obj,
    uint32_t *port_status_mask_slave)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ASYNC_SET);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 20;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, port_status_mask_slave);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set port_status_mask_slave in an object of type of_async_set.
 * @param obj Pointer to an object of type of_async_set.
 * @param port_status_mask_slave The value to write into the object
 */
void
of_async_set_port_status_mask_slave_set(
    of_async_set_t *obj,
    uint32_t port_status_mask_slave)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ASYNC_SET);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 20;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, port_status_mask_slave);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get flow_removed_mask_equal_master from an object of type of_async_set.
 * @param obj Pointer to an object of type of_async_set.
 * @param flow_removed_mask_equal_master Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_async_set_flow_removed_mask_equal_master_get(
    of_async_set_t *obj,
    uint32_t *flow_removed_mask_equal_master)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ASYNC_SET);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 24;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, flow_removed_mask_equal_master);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set flow_removed_mask_equal_master in an object of type of_async_set.
 * @param obj Pointer to an object of type of_async_set.
 * @param flow_removed_mask_equal_master The value to write into the object
 */
void
of_async_set_flow_removed_mask_equal_master_set(
    of_async_set_t *obj,
    uint32_t flow_removed_mask_equal_master)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ASYNC_SET);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 24;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, flow_removed_mask_equal_master);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get flow_removed_mask_slave from an object of type of_async_set.
 * @param obj Pointer to an object of type of_async_set.
 * @param flow_removed_mask_slave Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_async_set_flow_removed_mask_slave_get(
    of_async_set_t *obj,
    uint32_t *flow_removed_mask_slave)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ASYNC_SET);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 28;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, flow_removed_mask_slave);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set flow_removed_mask_slave in an object of type of_async_set.
 * @param obj Pointer to an object of type of_async_set.
 * @param flow_removed_mask_slave The value to write into the object
 */
void
of_async_set_flow_removed_mask_slave_set(
    of_async_set_t *obj,
    uint32_t flow_removed_mask_slave)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ASYNC_SET);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 28;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, flow_removed_mask_slave);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_barrier_reply */
/** \ingroup of_barrier_reply 
 * @{ */

/**
 * Get xid from an object of type of_barrier_reply.
 * @param obj Pointer to an object of type of_barrier_reply.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_barrier_reply_xid_get(
    of_barrier_reply_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BARRIER_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_barrier_reply.
 * @param obj Pointer to an object of type of_barrier_reply.
 * @param xid The value to write into the object
 */
void
of_barrier_reply_xid_set(
    of_barrier_reply_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BARRIER_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_barrier_request */
/** \ingroup of_barrier_request 
 * @{ */

/**
 * Get xid from an object of type of_barrier_request.
 * @param obj Pointer to an object of type of_barrier_request.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_barrier_request_xid_get(
    of_barrier_request_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BARRIER_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_barrier_request.
 * @param obj Pointer to an object of type of_barrier_request.
 * @param xid The value to write into the object
 */
void
of_barrier_request_xid_set(
    of_barrier_request_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BARRIER_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_bsn_bw_clear_data_reply */
/** \ingroup of_bsn_bw_clear_data_reply 
 * @{ */

/**
 * Get xid from an object of type of_bsn_bw_clear_data_reply.
 * @param obj Pointer to an object of type of_bsn_bw_clear_data_reply.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_bw_clear_data_reply_xid_get(
    of_bsn_bw_clear_data_reply_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_BW_CLEAR_DATA_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_bsn_bw_clear_data_reply.
 * @param obj Pointer to an object of type of_bsn_bw_clear_data_reply.
 * @param xid The value to write into the object
 */
void
of_bsn_bw_clear_data_reply_xid_set(
    of_bsn_bw_clear_data_reply_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_BW_CLEAR_DATA_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get experimenter from an object of type of_bsn_bw_clear_data_reply.
 * @param obj Pointer to an object of type of_bsn_bw_clear_data_reply.
 * @param experimenter Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_bw_clear_data_reply_experimenter_get(
    of_bsn_bw_clear_data_reply_t *obj,
    uint32_t *experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_BW_CLEAR_DATA_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set experimenter in an object of type of_bsn_bw_clear_data_reply.
 * @param obj Pointer to an object of type of_bsn_bw_clear_data_reply.
 * @param experimenter The value to write into the object
 */
void
of_bsn_bw_clear_data_reply_experimenter_set(
    of_bsn_bw_clear_data_reply_t *obj,
    uint32_t experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_BW_CLEAR_DATA_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get subtype from an object of type of_bsn_bw_clear_data_reply.
 * @param obj Pointer to an object of type of_bsn_bw_clear_data_reply.
 * @param subtype Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_bw_clear_data_reply_subtype_get(
    of_bsn_bw_clear_data_reply_t *obj,
    uint32_t *subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_BW_CLEAR_DATA_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set subtype in an object of type of_bsn_bw_clear_data_reply.
 * @param obj Pointer to an object of type of_bsn_bw_clear_data_reply.
 * @param subtype The value to write into the object
 */
void
of_bsn_bw_clear_data_reply_subtype_set(
    of_bsn_bw_clear_data_reply_t *obj,
    uint32_t subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_BW_CLEAR_DATA_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get status from an object of type of_bsn_bw_clear_data_reply.
 * @param obj Pointer to an object of type of_bsn_bw_clear_data_reply.
 * @param status Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_bw_clear_data_reply_status_get(
    of_bsn_bw_clear_data_reply_t *obj,
    uint32_t *status)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_BW_CLEAR_DATA_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, status);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set status in an object of type of_bsn_bw_clear_data_reply.
 * @param obj Pointer to an object of type of_bsn_bw_clear_data_reply.
 * @param status The value to write into the object
 */
void
of_bsn_bw_clear_data_reply_status_set(
    of_bsn_bw_clear_data_reply_t *obj,
    uint32_t status)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_BW_CLEAR_DATA_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, status);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_bsn_bw_clear_data_request */
/** \ingroup of_bsn_bw_clear_data_request 
 * @{ */

/**
 * Get xid from an object of type of_bsn_bw_clear_data_request.
 * @param obj Pointer to an object of type of_bsn_bw_clear_data_request.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_bw_clear_data_request_xid_get(
    of_bsn_bw_clear_data_request_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_BW_CLEAR_DATA_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_bsn_bw_clear_data_request.
 * @param obj Pointer to an object of type of_bsn_bw_clear_data_request.
 * @param xid The value to write into the object
 */
void
of_bsn_bw_clear_data_request_xid_set(
    of_bsn_bw_clear_data_request_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_BW_CLEAR_DATA_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get experimenter from an object of type of_bsn_bw_clear_data_request.
 * @param obj Pointer to an object of type of_bsn_bw_clear_data_request.
 * @param experimenter Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_bw_clear_data_request_experimenter_get(
    of_bsn_bw_clear_data_request_t *obj,
    uint32_t *experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_BW_CLEAR_DATA_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set experimenter in an object of type of_bsn_bw_clear_data_request.
 * @param obj Pointer to an object of type of_bsn_bw_clear_data_request.
 * @param experimenter The value to write into the object
 */
void
of_bsn_bw_clear_data_request_experimenter_set(
    of_bsn_bw_clear_data_request_t *obj,
    uint32_t experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_BW_CLEAR_DATA_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get subtype from an object of type of_bsn_bw_clear_data_request.
 * @param obj Pointer to an object of type of_bsn_bw_clear_data_request.
 * @param subtype Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_bw_clear_data_request_subtype_get(
    of_bsn_bw_clear_data_request_t *obj,
    uint32_t *subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_BW_CLEAR_DATA_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set subtype in an object of type of_bsn_bw_clear_data_request.
 * @param obj Pointer to an object of type of_bsn_bw_clear_data_request.
 * @param subtype The value to write into the object
 */
void
of_bsn_bw_clear_data_request_subtype_set(
    of_bsn_bw_clear_data_request_t *obj,
    uint32_t subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_BW_CLEAR_DATA_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_bsn_bw_enable_get_reply */
/** \ingroup of_bsn_bw_enable_get_reply 
 * @{ */

/**
 * Get xid from an object of type of_bsn_bw_enable_get_reply.
 * @param obj Pointer to an object of type of_bsn_bw_enable_get_reply.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_bw_enable_get_reply_xid_get(
    of_bsn_bw_enable_get_reply_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_BW_ENABLE_GET_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_bsn_bw_enable_get_reply.
 * @param obj Pointer to an object of type of_bsn_bw_enable_get_reply.
 * @param xid The value to write into the object
 */
void
of_bsn_bw_enable_get_reply_xid_set(
    of_bsn_bw_enable_get_reply_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_BW_ENABLE_GET_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get experimenter from an object of type of_bsn_bw_enable_get_reply.
 * @param obj Pointer to an object of type of_bsn_bw_enable_get_reply.
 * @param experimenter Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_bw_enable_get_reply_experimenter_get(
    of_bsn_bw_enable_get_reply_t *obj,
    uint32_t *experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_BW_ENABLE_GET_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set experimenter in an object of type of_bsn_bw_enable_get_reply.
 * @param obj Pointer to an object of type of_bsn_bw_enable_get_reply.
 * @param experimenter The value to write into the object
 */
void
of_bsn_bw_enable_get_reply_experimenter_set(
    of_bsn_bw_enable_get_reply_t *obj,
    uint32_t experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_BW_ENABLE_GET_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get subtype from an object of type of_bsn_bw_enable_get_reply.
 * @param obj Pointer to an object of type of_bsn_bw_enable_get_reply.
 * @param subtype Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_bw_enable_get_reply_subtype_get(
    of_bsn_bw_enable_get_reply_t *obj,
    uint32_t *subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_BW_ENABLE_GET_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set subtype in an object of type of_bsn_bw_enable_get_reply.
 * @param obj Pointer to an object of type of_bsn_bw_enable_get_reply.
 * @param subtype The value to write into the object
 */
void
of_bsn_bw_enable_get_reply_subtype_set(
    of_bsn_bw_enable_get_reply_t *obj,
    uint32_t subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_BW_ENABLE_GET_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get enabled from an object of type of_bsn_bw_enable_get_reply.
 * @param obj Pointer to an object of type of_bsn_bw_enable_get_reply.
 * @param enabled Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_bw_enable_get_reply_enabled_get(
    of_bsn_bw_enable_get_reply_t *obj,
    uint32_t *enabled)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_BW_ENABLE_GET_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, enabled);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set enabled in an object of type of_bsn_bw_enable_get_reply.
 * @param obj Pointer to an object of type of_bsn_bw_enable_get_reply.
 * @param enabled The value to write into the object
 */
void
of_bsn_bw_enable_get_reply_enabled_set(
    of_bsn_bw_enable_get_reply_t *obj,
    uint32_t enabled)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_BW_ENABLE_GET_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, enabled);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_bsn_bw_enable_get_request */
/** \ingroup of_bsn_bw_enable_get_request 
 * @{ */

/**
 * Get xid from an object of type of_bsn_bw_enable_get_request.
 * @param obj Pointer to an object of type of_bsn_bw_enable_get_request.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_bw_enable_get_request_xid_get(
    of_bsn_bw_enable_get_request_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_BW_ENABLE_GET_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_bsn_bw_enable_get_request.
 * @param obj Pointer to an object of type of_bsn_bw_enable_get_request.
 * @param xid The value to write into the object
 */
void
of_bsn_bw_enable_get_request_xid_set(
    of_bsn_bw_enable_get_request_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_BW_ENABLE_GET_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get experimenter from an object of type of_bsn_bw_enable_get_request.
 * @param obj Pointer to an object of type of_bsn_bw_enable_get_request.
 * @param experimenter Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_bw_enable_get_request_experimenter_get(
    of_bsn_bw_enable_get_request_t *obj,
    uint32_t *experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_BW_ENABLE_GET_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set experimenter in an object of type of_bsn_bw_enable_get_request.
 * @param obj Pointer to an object of type of_bsn_bw_enable_get_request.
 * @param experimenter The value to write into the object
 */
void
of_bsn_bw_enable_get_request_experimenter_set(
    of_bsn_bw_enable_get_request_t *obj,
    uint32_t experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_BW_ENABLE_GET_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get subtype from an object of type of_bsn_bw_enable_get_request.
 * @param obj Pointer to an object of type of_bsn_bw_enable_get_request.
 * @param subtype Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_bw_enable_get_request_subtype_get(
    of_bsn_bw_enable_get_request_t *obj,
    uint32_t *subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_BW_ENABLE_GET_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set subtype in an object of type of_bsn_bw_enable_get_request.
 * @param obj Pointer to an object of type of_bsn_bw_enable_get_request.
 * @param subtype The value to write into the object
 */
void
of_bsn_bw_enable_get_request_subtype_set(
    of_bsn_bw_enable_get_request_t *obj,
    uint32_t subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_BW_ENABLE_GET_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_bsn_bw_enable_set_reply */
/** \ingroup of_bsn_bw_enable_set_reply 
 * @{ */

/**
 * Get xid from an object of type of_bsn_bw_enable_set_reply.
 * @param obj Pointer to an object of type of_bsn_bw_enable_set_reply.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_bw_enable_set_reply_xid_get(
    of_bsn_bw_enable_set_reply_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_BW_ENABLE_SET_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_bsn_bw_enable_set_reply.
 * @param obj Pointer to an object of type of_bsn_bw_enable_set_reply.
 * @param xid The value to write into the object
 */
void
of_bsn_bw_enable_set_reply_xid_set(
    of_bsn_bw_enable_set_reply_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_BW_ENABLE_SET_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get experimenter from an object of type of_bsn_bw_enable_set_reply.
 * @param obj Pointer to an object of type of_bsn_bw_enable_set_reply.
 * @param experimenter Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_bw_enable_set_reply_experimenter_get(
    of_bsn_bw_enable_set_reply_t *obj,
    uint32_t *experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_BW_ENABLE_SET_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set experimenter in an object of type of_bsn_bw_enable_set_reply.
 * @param obj Pointer to an object of type of_bsn_bw_enable_set_reply.
 * @param experimenter The value to write into the object
 */
void
of_bsn_bw_enable_set_reply_experimenter_set(
    of_bsn_bw_enable_set_reply_t *obj,
    uint32_t experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_BW_ENABLE_SET_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get subtype from an object of type of_bsn_bw_enable_set_reply.
 * @param obj Pointer to an object of type of_bsn_bw_enable_set_reply.
 * @param subtype Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_bw_enable_set_reply_subtype_get(
    of_bsn_bw_enable_set_reply_t *obj,
    uint32_t *subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_BW_ENABLE_SET_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set subtype in an object of type of_bsn_bw_enable_set_reply.
 * @param obj Pointer to an object of type of_bsn_bw_enable_set_reply.
 * @param subtype The value to write into the object
 */
void
of_bsn_bw_enable_set_reply_subtype_set(
    of_bsn_bw_enable_set_reply_t *obj,
    uint32_t subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_BW_ENABLE_SET_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get enable from an object of type of_bsn_bw_enable_set_reply.
 * @param obj Pointer to an object of type of_bsn_bw_enable_set_reply.
 * @param enable Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_bw_enable_set_reply_enable_get(
    of_bsn_bw_enable_set_reply_t *obj,
    uint32_t *enable)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_BW_ENABLE_SET_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, enable);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set enable in an object of type of_bsn_bw_enable_set_reply.
 * @param obj Pointer to an object of type of_bsn_bw_enable_set_reply.
 * @param enable The value to write into the object
 */
void
of_bsn_bw_enable_set_reply_enable_set(
    of_bsn_bw_enable_set_reply_t *obj,
    uint32_t enable)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_BW_ENABLE_SET_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, enable);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get status from an object of type of_bsn_bw_enable_set_reply.
 * @param obj Pointer to an object of type of_bsn_bw_enable_set_reply.
 * @param status Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_bw_enable_set_reply_status_get(
    of_bsn_bw_enable_set_reply_t *obj,
    uint32_t *status)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_BW_ENABLE_SET_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 20;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, status);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set status in an object of type of_bsn_bw_enable_set_reply.
 * @param obj Pointer to an object of type of_bsn_bw_enable_set_reply.
 * @param status The value to write into the object
 */
void
of_bsn_bw_enable_set_reply_status_set(
    of_bsn_bw_enable_set_reply_t *obj,
    uint32_t status)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_BW_ENABLE_SET_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 20;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, status);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_bsn_bw_enable_set_request */
/** \ingroup of_bsn_bw_enable_set_request 
 * @{ */

/**
 * Get xid from an object of type of_bsn_bw_enable_set_request.
 * @param obj Pointer to an object of type of_bsn_bw_enable_set_request.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_bw_enable_set_request_xid_get(
    of_bsn_bw_enable_set_request_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_BW_ENABLE_SET_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_bsn_bw_enable_set_request.
 * @param obj Pointer to an object of type of_bsn_bw_enable_set_request.
 * @param xid The value to write into the object
 */
void
of_bsn_bw_enable_set_request_xid_set(
    of_bsn_bw_enable_set_request_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_BW_ENABLE_SET_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get experimenter from an object of type of_bsn_bw_enable_set_request.
 * @param obj Pointer to an object of type of_bsn_bw_enable_set_request.
 * @param experimenter Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_bw_enable_set_request_experimenter_get(
    of_bsn_bw_enable_set_request_t *obj,
    uint32_t *experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_BW_ENABLE_SET_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set experimenter in an object of type of_bsn_bw_enable_set_request.
 * @param obj Pointer to an object of type of_bsn_bw_enable_set_request.
 * @param experimenter The value to write into the object
 */
void
of_bsn_bw_enable_set_request_experimenter_set(
    of_bsn_bw_enable_set_request_t *obj,
    uint32_t experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_BW_ENABLE_SET_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get subtype from an object of type of_bsn_bw_enable_set_request.
 * @param obj Pointer to an object of type of_bsn_bw_enable_set_request.
 * @param subtype Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_bw_enable_set_request_subtype_get(
    of_bsn_bw_enable_set_request_t *obj,
    uint32_t *subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_BW_ENABLE_SET_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set subtype in an object of type of_bsn_bw_enable_set_request.
 * @param obj Pointer to an object of type of_bsn_bw_enable_set_request.
 * @param subtype The value to write into the object
 */
void
of_bsn_bw_enable_set_request_subtype_set(
    of_bsn_bw_enable_set_request_t *obj,
    uint32_t subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_BW_ENABLE_SET_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get enable from an object of type of_bsn_bw_enable_set_request.
 * @param obj Pointer to an object of type of_bsn_bw_enable_set_request.
 * @param enable Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_bw_enable_set_request_enable_get(
    of_bsn_bw_enable_set_request_t *obj,
    uint32_t *enable)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_BW_ENABLE_SET_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, enable);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set enable in an object of type of_bsn_bw_enable_set_request.
 * @param obj Pointer to an object of type of_bsn_bw_enable_set_request.
 * @param enable The value to write into the object
 */
void
of_bsn_bw_enable_set_request_enable_set(
    of_bsn_bw_enable_set_request_t *obj,
    uint32_t enable)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_BW_ENABLE_SET_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, enable);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_bsn_get_interfaces_reply */
/** \ingroup of_bsn_get_interfaces_reply 
 * @{ */

/**
 * Get xid from an object of type of_bsn_get_interfaces_reply.
 * @param obj Pointer to an object of type of_bsn_get_interfaces_reply.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_get_interfaces_reply_xid_get(
    of_bsn_get_interfaces_reply_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_INTERFACES_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_bsn_get_interfaces_reply.
 * @param obj Pointer to an object of type of_bsn_get_interfaces_reply.
 * @param xid The value to write into the object
 */
void
of_bsn_get_interfaces_reply_xid_set(
    of_bsn_get_interfaces_reply_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_INTERFACES_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get experimenter from an object of type of_bsn_get_interfaces_reply.
 * @param obj Pointer to an object of type of_bsn_get_interfaces_reply.
 * @param experimenter Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_get_interfaces_reply_experimenter_get(
    of_bsn_get_interfaces_reply_t *obj,
    uint32_t *experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_INTERFACES_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set experimenter in an object of type of_bsn_get_interfaces_reply.
 * @param obj Pointer to an object of type of_bsn_get_interfaces_reply.
 * @param experimenter The value to write into the object
 */
void
of_bsn_get_interfaces_reply_experimenter_set(
    of_bsn_get_interfaces_reply_t *obj,
    uint32_t experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_INTERFACES_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get subtype from an object of type of_bsn_get_interfaces_reply.
 * @param obj Pointer to an object of type of_bsn_get_interfaces_reply.
 * @param subtype Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_get_interfaces_reply_subtype_get(
    of_bsn_get_interfaces_reply_t *obj,
    uint32_t *subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_INTERFACES_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set subtype in an object of type of_bsn_get_interfaces_reply.
 * @param obj Pointer to an object of type of_bsn_get_interfaces_reply.
 * @param subtype The value to write into the object
 */
void
of_bsn_get_interfaces_reply_subtype_set(
    of_bsn_get_interfaces_reply_t *obj,
    uint32_t subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_INTERFACES_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Bind an object of type of_list_bsn_interface_t to the parent of type of_bsn_get_interfaces_reply for
 * member interfaces
 * @param obj Pointer to an object of type of_bsn_get_interfaces_reply.
 * @param interfaces Pointer to the child object of type
 * of_list_bsn_interface_t to be filled out.
 * \ingroup of_bsn_get_interfaces_reply
 *
 * The parameter interfaces is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_bsn_get_interfaces_reply_interfaces_bind(
    of_bsn_get_interfaces_reply_t *obj,
    of_list_bsn_interface_t *interfaces)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_BSN_GET_INTERFACES_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_bsn_interface_init(interfaces, obj->version, 0, 1);
    /* Attach to parent */
    interfaces->parent = (of_object_t *)obj;
    interfaces->wire_object.wbuf = obj->wire_object.wbuf;
    interfaces->wire_object.obj_offset = abs_offset;
    interfaces->wire_object.owned = 0;
    interfaces->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of interfaces into a new variable of type of_list_bsn_interface_t from
 * a of_bsn_get_interfaces_reply instance.
 *
 * @param obj Pointer to the source of type of_bsn_get_interfaces_reply_t
 * @returns A pointer to a new instance of type of_list_bsn_interface_t whose contents
 * match that of interfaces from source
 * @returns NULL if an error occurs
 */
of_list_bsn_interface_t *
of_bsn_get_interfaces_reply_interfaces_get(of_bsn_get_interfaces_reply_t *obj) {
    of_list_bsn_interface_t _interfaces;
    of_list_bsn_interface_t *_interfaces_ptr;

    of_bsn_get_interfaces_reply_interfaces_bind(obj, &_interfaces);
    _interfaces_ptr = (of_list_bsn_interface_t *)of_object_dup(&_interfaces);
    return _interfaces_ptr;
}

/**
 * Set interfaces in an object of type of_bsn_get_interfaces_reply.
 * @param obj Pointer to an object of type of_bsn_get_interfaces_reply.
 * @param interfaces Pointer to the child of type of_list_bsn_interface_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_bsn_get_interfaces_reply_interfaces_set(
    of_bsn_get_interfaces_reply_t *obj,
    of_list_bsn_interface_t *interfaces)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_BSN_GET_INTERFACES_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = interfaces->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == interfaces->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(interfaces, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(interfaces, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (interfaces->wire_length_set != NULL) {
        interfaces->wire_length_set((of_object_t *)interfaces, interfaces->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_bsn_get_interfaces_request */
/** \ingroup of_bsn_get_interfaces_request 
 * @{ */

/**
 * Get xid from an object of type of_bsn_get_interfaces_request.
 * @param obj Pointer to an object of type of_bsn_get_interfaces_request.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_get_interfaces_request_xid_get(
    of_bsn_get_interfaces_request_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_INTERFACES_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_bsn_get_interfaces_request.
 * @param obj Pointer to an object of type of_bsn_get_interfaces_request.
 * @param xid The value to write into the object
 */
void
of_bsn_get_interfaces_request_xid_set(
    of_bsn_get_interfaces_request_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_INTERFACES_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get experimenter from an object of type of_bsn_get_interfaces_request.
 * @param obj Pointer to an object of type of_bsn_get_interfaces_request.
 * @param experimenter Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_get_interfaces_request_experimenter_get(
    of_bsn_get_interfaces_request_t *obj,
    uint32_t *experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_INTERFACES_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set experimenter in an object of type of_bsn_get_interfaces_request.
 * @param obj Pointer to an object of type of_bsn_get_interfaces_request.
 * @param experimenter The value to write into the object
 */
void
of_bsn_get_interfaces_request_experimenter_set(
    of_bsn_get_interfaces_request_t *obj,
    uint32_t experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_INTERFACES_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get subtype from an object of type of_bsn_get_interfaces_request.
 * @param obj Pointer to an object of type of_bsn_get_interfaces_request.
 * @param subtype Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_get_interfaces_request_subtype_get(
    of_bsn_get_interfaces_request_t *obj,
    uint32_t *subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_INTERFACES_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set subtype in an object of type of_bsn_get_interfaces_request.
 * @param obj Pointer to an object of type of_bsn_get_interfaces_request.
 * @param subtype The value to write into the object
 */
void
of_bsn_get_interfaces_request_subtype_set(
    of_bsn_get_interfaces_request_t *obj,
    uint32_t subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_INTERFACES_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_bsn_get_ip_mask_reply */
/** \ingroup of_bsn_get_ip_mask_reply 
 * @{ */

/**
 * Get xid from an object of type of_bsn_get_ip_mask_reply.
 * @param obj Pointer to an object of type of_bsn_get_ip_mask_reply.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_get_ip_mask_reply_xid_get(
    of_bsn_get_ip_mask_reply_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_IP_MASK_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_bsn_get_ip_mask_reply.
 * @param obj Pointer to an object of type of_bsn_get_ip_mask_reply.
 * @param xid The value to write into the object
 */
void
of_bsn_get_ip_mask_reply_xid_set(
    of_bsn_get_ip_mask_reply_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_IP_MASK_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get experimenter from an object of type of_bsn_get_ip_mask_reply.
 * @param obj Pointer to an object of type of_bsn_get_ip_mask_reply.
 * @param experimenter Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_get_ip_mask_reply_experimenter_get(
    of_bsn_get_ip_mask_reply_t *obj,
    uint32_t *experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_IP_MASK_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set experimenter in an object of type of_bsn_get_ip_mask_reply.
 * @param obj Pointer to an object of type of_bsn_get_ip_mask_reply.
 * @param experimenter The value to write into the object
 */
void
of_bsn_get_ip_mask_reply_experimenter_set(
    of_bsn_get_ip_mask_reply_t *obj,
    uint32_t experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_IP_MASK_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get subtype from an object of type of_bsn_get_ip_mask_reply.
 * @param obj Pointer to an object of type of_bsn_get_ip_mask_reply.
 * @param subtype Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_get_ip_mask_reply_subtype_get(
    of_bsn_get_ip_mask_reply_t *obj,
    uint32_t *subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_IP_MASK_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set subtype in an object of type of_bsn_get_ip_mask_reply.
 * @param obj Pointer to an object of type of_bsn_get_ip_mask_reply.
 * @param subtype The value to write into the object
 */
void
of_bsn_get_ip_mask_reply_subtype_set(
    of_bsn_get_ip_mask_reply_t *obj,
    uint32_t subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_IP_MASK_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get index from an object of type of_bsn_get_ip_mask_reply.
 * @param obj Pointer to an object of type of_bsn_get_ip_mask_reply.
 * @param index Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_bsn_get_ip_mask_reply_index_get(
    of_bsn_get_ip_mask_reply_t *obj,
    uint8_t *index)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_IP_MASK_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, index);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set index in an object of type of_bsn_get_ip_mask_reply.
 * @param obj Pointer to an object of type of_bsn_get_ip_mask_reply.
 * @param index The value to write into the object
 */
void
of_bsn_get_ip_mask_reply_index_set(
    of_bsn_get_ip_mask_reply_t *obj,
    uint8_t index)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_IP_MASK_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, index);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get mask from an object of type of_bsn_get_ip_mask_reply.
 * @param obj Pointer to an object of type of_bsn_get_ip_mask_reply.
 * @param mask Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_get_ip_mask_reply_mask_get(
    of_bsn_get_ip_mask_reply_t *obj,
    uint32_t *mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_IP_MASK_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 20;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set mask in an object of type of_bsn_get_ip_mask_reply.
 * @param obj Pointer to an object of type of_bsn_get_ip_mask_reply.
 * @param mask The value to write into the object
 */
void
of_bsn_get_ip_mask_reply_mask_set(
    of_bsn_get_ip_mask_reply_t *obj,
    uint32_t mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_IP_MASK_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 20;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_bsn_get_ip_mask_request */
/** \ingroup of_bsn_get_ip_mask_request 
 * @{ */

/**
 * Get xid from an object of type of_bsn_get_ip_mask_request.
 * @param obj Pointer to an object of type of_bsn_get_ip_mask_request.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_get_ip_mask_request_xid_get(
    of_bsn_get_ip_mask_request_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_IP_MASK_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_bsn_get_ip_mask_request.
 * @param obj Pointer to an object of type of_bsn_get_ip_mask_request.
 * @param xid The value to write into the object
 */
void
of_bsn_get_ip_mask_request_xid_set(
    of_bsn_get_ip_mask_request_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_IP_MASK_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get experimenter from an object of type of_bsn_get_ip_mask_request.
 * @param obj Pointer to an object of type of_bsn_get_ip_mask_request.
 * @param experimenter Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_get_ip_mask_request_experimenter_get(
    of_bsn_get_ip_mask_request_t *obj,
    uint32_t *experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_IP_MASK_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set experimenter in an object of type of_bsn_get_ip_mask_request.
 * @param obj Pointer to an object of type of_bsn_get_ip_mask_request.
 * @param experimenter The value to write into the object
 */
void
of_bsn_get_ip_mask_request_experimenter_set(
    of_bsn_get_ip_mask_request_t *obj,
    uint32_t experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_IP_MASK_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get subtype from an object of type of_bsn_get_ip_mask_request.
 * @param obj Pointer to an object of type of_bsn_get_ip_mask_request.
 * @param subtype Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_get_ip_mask_request_subtype_get(
    of_bsn_get_ip_mask_request_t *obj,
    uint32_t *subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_IP_MASK_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set subtype in an object of type of_bsn_get_ip_mask_request.
 * @param obj Pointer to an object of type of_bsn_get_ip_mask_request.
 * @param subtype The value to write into the object
 */
void
of_bsn_get_ip_mask_request_subtype_set(
    of_bsn_get_ip_mask_request_t *obj,
    uint32_t subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_IP_MASK_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get index from an object of type of_bsn_get_ip_mask_request.
 * @param obj Pointer to an object of type of_bsn_get_ip_mask_request.
 * @param index Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_bsn_get_ip_mask_request_index_get(
    of_bsn_get_ip_mask_request_t *obj,
    uint8_t *index)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_IP_MASK_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, index);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set index in an object of type of_bsn_get_ip_mask_request.
 * @param obj Pointer to an object of type of_bsn_get_ip_mask_request.
 * @param index The value to write into the object
 */
void
of_bsn_get_ip_mask_request_index_set(
    of_bsn_get_ip_mask_request_t *obj,
    uint8_t index)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_IP_MASK_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, index);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_bsn_get_l2_table_reply */
/** \ingroup of_bsn_get_l2_table_reply 
 * @{ */

/**
 * Get xid from an object of type of_bsn_get_l2_table_reply.
 * @param obj Pointer to an object of type of_bsn_get_l2_table_reply.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_get_l2_table_reply_xid_get(
    of_bsn_get_l2_table_reply_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_L2_TABLE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_bsn_get_l2_table_reply.
 * @param obj Pointer to an object of type of_bsn_get_l2_table_reply.
 * @param xid The value to write into the object
 */
void
of_bsn_get_l2_table_reply_xid_set(
    of_bsn_get_l2_table_reply_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_L2_TABLE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get experimenter from an object of type of_bsn_get_l2_table_reply.
 * @param obj Pointer to an object of type of_bsn_get_l2_table_reply.
 * @param experimenter Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_get_l2_table_reply_experimenter_get(
    of_bsn_get_l2_table_reply_t *obj,
    uint32_t *experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_L2_TABLE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set experimenter in an object of type of_bsn_get_l2_table_reply.
 * @param obj Pointer to an object of type of_bsn_get_l2_table_reply.
 * @param experimenter The value to write into the object
 */
void
of_bsn_get_l2_table_reply_experimenter_set(
    of_bsn_get_l2_table_reply_t *obj,
    uint32_t experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_L2_TABLE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get subtype from an object of type of_bsn_get_l2_table_reply.
 * @param obj Pointer to an object of type of_bsn_get_l2_table_reply.
 * @param subtype Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_get_l2_table_reply_subtype_get(
    of_bsn_get_l2_table_reply_t *obj,
    uint32_t *subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_L2_TABLE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set subtype in an object of type of_bsn_get_l2_table_reply.
 * @param obj Pointer to an object of type of_bsn_get_l2_table_reply.
 * @param subtype The value to write into the object
 */
void
of_bsn_get_l2_table_reply_subtype_set(
    of_bsn_get_l2_table_reply_t *obj,
    uint32_t subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_L2_TABLE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get l2_table_enable from an object of type of_bsn_get_l2_table_reply.
 * @param obj Pointer to an object of type of_bsn_get_l2_table_reply.
 * @param l2_table_enable Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_bsn_get_l2_table_reply_l2_table_enable_get(
    of_bsn_get_l2_table_reply_t *obj,
    uint8_t *l2_table_enable)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_L2_TABLE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, l2_table_enable);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set l2_table_enable in an object of type of_bsn_get_l2_table_reply.
 * @param obj Pointer to an object of type of_bsn_get_l2_table_reply.
 * @param l2_table_enable The value to write into the object
 */
void
of_bsn_get_l2_table_reply_l2_table_enable_set(
    of_bsn_get_l2_table_reply_t *obj,
    uint8_t l2_table_enable)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_L2_TABLE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, l2_table_enable);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get l2_table_priority from an object of type of_bsn_get_l2_table_reply.
 * @param obj Pointer to an object of type of_bsn_get_l2_table_reply.
 * @param l2_table_priority Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_bsn_get_l2_table_reply_l2_table_priority_get(
    of_bsn_get_l2_table_reply_t *obj,
    uint16_t *l2_table_priority)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_L2_TABLE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 18;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, l2_table_priority);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set l2_table_priority in an object of type of_bsn_get_l2_table_reply.
 * @param obj Pointer to an object of type of_bsn_get_l2_table_reply.
 * @param l2_table_priority The value to write into the object
 */
void
of_bsn_get_l2_table_reply_l2_table_priority_set(
    of_bsn_get_l2_table_reply_t *obj,
    uint16_t l2_table_priority)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_L2_TABLE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 18;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, l2_table_priority);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_bsn_get_l2_table_request */
/** \ingroup of_bsn_get_l2_table_request 
 * @{ */

/**
 * Get xid from an object of type of_bsn_get_l2_table_request.
 * @param obj Pointer to an object of type of_bsn_get_l2_table_request.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_get_l2_table_request_xid_get(
    of_bsn_get_l2_table_request_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_L2_TABLE_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_bsn_get_l2_table_request.
 * @param obj Pointer to an object of type of_bsn_get_l2_table_request.
 * @param xid The value to write into the object
 */
void
of_bsn_get_l2_table_request_xid_set(
    of_bsn_get_l2_table_request_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_L2_TABLE_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get experimenter from an object of type of_bsn_get_l2_table_request.
 * @param obj Pointer to an object of type of_bsn_get_l2_table_request.
 * @param experimenter Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_get_l2_table_request_experimenter_get(
    of_bsn_get_l2_table_request_t *obj,
    uint32_t *experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_L2_TABLE_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set experimenter in an object of type of_bsn_get_l2_table_request.
 * @param obj Pointer to an object of type of_bsn_get_l2_table_request.
 * @param experimenter The value to write into the object
 */
void
of_bsn_get_l2_table_request_experimenter_set(
    of_bsn_get_l2_table_request_t *obj,
    uint32_t experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_L2_TABLE_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get subtype from an object of type of_bsn_get_l2_table_request.
 * @param obj Pointer to an object of type of_bsn_get_l2_table_request.
 * @param subtype Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_get_l2_table_request_subtype_get(
    of_bsn_get_l2_table_request_t *obj,
    uint32_t *subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_L2_TABLE_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set subtype in an object of type of_bsn_get_l2_table_request.
 * @param obj Pointer to an object of type of_bsn_get_l2_table_request.
 * @param subtype The value to write into the object
 */
void
of_bsn_get_l2_table_request_subtype_set(
    of_bsn_get_l2_table_request_t *obj,
    uint32_t subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_L2_TABLE_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_bsn_get_mirroring_reply */
/** \ingroup of_bsn_get_mirroring_reply 
 * @{ */

/**
 * Get xid from an object of type of_bsn_get_mirroring_reply.
 * @param obj Pointer to an object of type of_bsn_get_mirroring_reply.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_get_mirroring_reply_xid_get(
    of_bsn_get_mirroring_reply_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_MIRRORING_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_bsn_get_mirroring_reply.
 * @param obj Pointer to an object of type of_bsn_get_mirroring_reply.
 * @param xid The value to write into the object
 */
void
of_bsn_get_mirroring_reply_xid_set(
    of_bsn_get_mirroring_reply_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_MIRRORING_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get experimenter from an object of type of_bsn_get_mirroring_reply.
 * @param obj Pointer to an object of type of_bsn_get_mirroring_reply.
 * @param experimenter Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_get_mirroring_reply_experimenter_get(
    of_bsn_get_mirroring_reply_t *obj,
    uint32_t *experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_MIRRORING_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set experimenter in an object of type of_bsn_get_mirroring_reply.
 * @param obj Pointer to an object of type of_bsn_get_mirroring_reply.
 * @param experimenter The value to write into the object
 */
void
of_bsn_get_mirroring_reply_experimenter_set(
    of_bsn_get_mirroring_reply_t *obj,
    uint32_t experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_MIRRORING_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get subtype from an object of type of_bsn_get_mirroring_reply.
 * @param obj Pointer to an object of type of_bsn_get_mirroring_reply.
 * @param subtype Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_get_mirroring_reply_subtype_get(
    of_bsn_get_mirroring_reply_t *obj,
    uint32_t *subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_MIRRORING_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set subtype in an object of type of_bsn_get_mirroring_reply.
 * @param obj Pointer to an object of type of_bsn_get_mirroring_reply.
 * @param subtype The value to write into the object
 */
void
of_bsn_get_mirroring_reply_subtype_set(
    of_bsn_get_mirroring_reply_t *obj,
    uint32_t subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_MIRRORING_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get report_mirror_ports from an object of type of_bsn_get_mirroring_reply.
 * @param obj Pointer to an object of type of_bsn_get_mirroring_reply.
 * @param report_mirror_ports Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_bsn_get_mirroring_reply_report_mirror_ports_get(
    of_bsn_get_mirroring_reply_t *obj,
    uint8_t *report_mirror_ports)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_MIRRORING_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, report_mirror_ports);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set report_mirror_ports in an object of type of_bsn_get_mirroring_reply.
 * @param obj Pointer to an object of type of_bsn_get_mirroring_reply.
 * @param report_mirror_ports The value to write into the object
 */
void
of_bsn_get_mirroring_reply_report_mirror_ports_set(
    of_bsn_get_mirroring_reply_t *obj,
    uint8_t report_mirror_ports)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_MIRRORING_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, report_mirror_ports);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_bsn_get_mirroring_request */
/** \ingroup of_bsn_get_mirroring_request 
 * @{ */

/**
 * Get xid from an object of type of_bsn_get_mirroring_request.
 * @param obj Pointer to an object of type of_bsn_get_mirroring_request.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_get_mirroring_request_xid_get(
    of_bsn_get_mirroring_request_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_MIRRORING_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_bsn_get_mirroring_request.
 * @param obj Pointer to an object of type of_bsn_get_mirroring_request.
 * @param xid The value to write into the object
 */
void
of_bsn_get_mirroring_request_xid_set(
    of_bsn_get_mirroring_request_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_MIRRORING_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get experimenter from an object of type of_bsn_get_mirroring_request.
 * @param obj Pointer to an object of type of_bsn_get_mirroring_request.
 * @param experimenter Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_get_mirroring_request_experimenter_get(
    of_bsn_get_mirroring_request_t *obj,
    uint32_t *experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_MIRRORING_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set experimenter in an object of type of_bsn_get_mirroring_request.
 * @param obj Pointer to an object of type of_bsn_get_mirroring_request.
 * @param experimenter The value to write into the object
 */
void
of_bsn_get_mirroring_request_experimenter_set(
    of_bsn_get_mirroring_request_t *obj,
    uint32_t experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_MIRRORING_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get subtype from an object of type of_bsn_get_mirroring_request.
 * @param obj Pointer to an object of type of_bsn_get_mirroring_request.
 * @param subtype Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_get_mirroring_request_subtype_get(
    of_bsn_get_mirroring_request_t *obj,
    uint32_t *subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_MIRRORING_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set subtype in an object of type of_bsn_get_mirroring_request.
 * @param obj Pointer to an object of type of_bsn_get_mirroring_request.
 * @param subtype The value to write into the object
 */
void
of_bsn_get_mirroring_request_subtype_set(
    of_bsn_get_mirroring_request_t *obj,
    uint32_t subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_MIRRORING_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get report_mirror_ports from an object of type of_bsn_get_mirroring_request.
 * @param obj Pointer to an object of type of_bsn_get_mirroring_request.
 * @param report_mirror_ports Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_bsn_get_mirroring_request_report_mirror_ports_get(
    of_bsn_get_mirroring_request_t *obj,
    uint8_t *report_mirror_ports)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_MIRRORING_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, report_mirror_ports);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set report_mirror_ports in an object of type of_bsn_get_mirroring_request.
 * @param obj Pointer to an object of type of_bsn_get_mirroring_request.
 * @param report_mirror_ports The value to write into the object
 */
void
of_bsn_get_mirroring_request_report_mirror_ports_set(
    of_bsn_get_mirroring_request_t *obj,
    uint8_t report_mirror_ports)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_GET_MIRRORING_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, report_mirror_ports);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_bsn_set_ip_mask */
/** \ingroup of_bsn_set_ip_mask 
 * @{ */

/**
 * Get xid from an object of type of_bsn_set_ip_mask.
 * @param obj Pointer to an object of type of_bsn_set_ip_mask.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_set_ip_mask_xid_get(
    of_bsn_set_ip_mask_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_IP_MASK);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_bsn_set_ip_mask.
 * @param obj Pointer to an object of type of_bsn_set_ip_mask.
 * @param xid The value to write into the object
 */
void
of_bsn_set_ip_mask_xid_set(
    of_bsn_set_ip_mask_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_IP_MASK);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get experimenter from an object of type of_bsn_set_ip_mask.
 * @param obj Pointer to an object of type of_bsn_set_ip_mask.
 * @param experimenter Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_set_ip_mask_experimenter_get(
    of_bsn_set_ip_mask_t *obj,
    uint32_t *experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_IP_MASK);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set experimenter in an object of type of_bsn_set_ip_mask.
 * @param obj Pointer to an object of type of_bsn_set_ip_mask.
 * @param experimenter The value to write into the object
 */
void
of_bsn_set_ip_mask_experimenter_set(
    of_bsn_set_ip_mask_t *obj,
    uint32_t experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_IP_MASK);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get subtype from an object of type of_bsn_set_ip_mask.
 * @param obj Pointer to an object of type of_bsn_set_ip_mask.
 * @param subtype Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_set_ip_mask_subtype_get(
    of_bsn_set_ip_mask_t *obj,
    uint32_t *subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_IP_MASK);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set subtype in an object of type of_bsn_set_ip_mask.
 * @param obj Pointer to an object of type of_bsn_set_ip_mask.
 * @param subtype The value to write into the object
 */
void
of_bsn_set_ip_mask_subtype_set(
    of_bsn_set_ip_mask_t *obj,
    uint32_t subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_IP_MASK);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get index from an object of type of_bsn_set_ip_mask.
 * @param obj Pointer to an object of type of_bsn_set_ip_mask.
 * @param index Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_bsn_set_ip_mask_index_get(
    of_bsn_set_ip_mask_t *obj,
    uint8_t *index)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_IP_MASK);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, index);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set index in an object of type of_bsn_set_ip_mask.
 * @param obj Pointer to an object of type of_bsn_set_ip_mask.
 * @param index The value to write into the object
 */
void
of_bsn_set_ip_mask_index_set(
    of_bsn_set_ip_mask_t *obj,
    uint8_t index)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_IP_MASK);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, index);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get mask from an object of type of_bsn_set_ip_mask.
 * @param obj Pointer to an object of type of_bsn_set_ip_mask.
 * @param mask Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_set_ip_mask_mask_get(
    of_bsn_set_ip_mask_t *obj,
    uint32_t *mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_IP_MASK);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 20;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set mask in an object of type of_bsn_set_ip_mask.
 * @param obj Pointer to an object of type of_bsn_set_ip_mask.
 * @param mask The value to write into the object
 */
void
of_bsn_set_ip_mask_mask_set(
    of_bsn_set_ip_mask_t *obj,
    uint32_t mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_IP_MASK);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 20;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_bsn_set_l2_table_reply */
/** \ingroup of_bsn_set_l2_table_reply 
 * @{ */

/**
 * Get xid from an object of type of_bsn_set_l2_table_reply.
 * @param obj Pointer to an object of type of_bsn_set_l2_table_reply.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_set_l2_table_reply_xid_get(
    of_bsn_set_l2_table_reply_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_L2_TABLE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_bsn_set_l2_table_reply.
 * @param obj Pointer to an object of type of_bsn_set_l2_table_reply.
 * @param xid The value to write into the object
 */
void
of_bsn_set_l2_table_reply_xid_set(
    of_bsn_set_l2_table_reply_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_L2_TABLE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get experimenter from an object of type of_bsn_set_l2_table_reply.
 * @param obj Pointer to an object of type of_bsn_set_l2_table_reply.
 * @param experimenter Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_set_l2_table_reply_experimenter_get(
    of_bsn_set_l2_table_reply_t *obj,
    uint32_t *experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_L2_TABLE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set experimenter in an object of type of_bsn_set_l2_table_reply.
 * @param obj Pointer to an object of type of_bsn_set_l2_table_reply.
 * @param experimenter The value to write into the object
 */
void
of_bsn_set_l2_table_reply_experimenter_set(
    of_bsn_set_l2_table_reply_t *obj,
    uint32_t experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_L2_TABLE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get subtype from an object of type of_bsn_set_l2_table_reply.
 * @param obj Pointer to an object of type of_bsn_set_l2_table_reply.
 * @param subtype Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_set_l2_table_reply_subtype_get(
    of_bsn_set_l2_table_reply_t *obj,
    uint32_t *subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_L2_TABLE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set subtype in an object of type of_bsn_set_l2_table_reply.
 * @param obj Pointer to an object of type of_bsn_set_l2_table_reply.
 * @param subtype The value to write into the object
 */
void
of_bsn_set_l2_table_reply_subtype_set(
    of_bsn_set_l2_table_reply_t *obj,
    uint32_t subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_L2_TABLE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get l2_table_enable from an object of type of_bsn_set_l2_table_reply.
 * @param obj Pointer to an object of type of_bsn_set_l2_table_reply.
 * @param l2_table_enable Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_bsn_set_l2_table_reply_l2_table_enable_get(
    of_bsn_set_l2_table_reply_t *obj,
    uint8_t *l2_table_enable)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_L2_TABLE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, l2_table_enable);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set l2_table_enable in an object of type of_bsn_set_l2_table_reply.
 * @param obj Pointer to an object of type of_bsn_set_l2_table_reply.
 * @param l2_table_enable The value to write into the object
 */
void
of_bsn_set_l2_table_reply_l2_table_enable_set(
    of_bsn_set_l2_table_reply_t *obj,
    uint8_t l2_table_enable)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_L2_TABLE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, l2_table_enable);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get l2_table_priority from an object of type of_bsn_set_l2_table_reply.
 * @param obj Pointer to an object of type of_bsn_set_l2_table_reply.
 * @param l2_table_priority Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_bsn_set_l2_table_reply_l2_table_priority_get(
    of_bsn_set_l2_table_reply_t *obj,
    uint16_t *l2_table_priority)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_L2_TABLE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 18;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, l2_table_priority);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set l2_table_priority in an object of type of_bsn_set_l2_table_reply.
 * @param obj Pointer to an object of type of_bsn_set_l2_table_reply.
 * @param l2_table_priority The value to write into the object
 */
void
of_bsn_set_l2_table_reply_l2_table_priority_set(
    of_bsn_set_l2_table_reply_t *obj,
    uint16_t l2_table_priority)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_L2_TABLE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 18;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, l2_table_priority);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get status from an object of type of_bsn_set_l2_table_reply.
 * @param obj Pointer to an object of type of_bsn_set_l2_table_reply.
 * @param status Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_set_l2_table_reply_status_get(
    of_bsn_set_l2_table_reply_t *obj,
    uint32_t *status)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_L2_TABLE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 20;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, status);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set status in an object of type of_bsn_set_l2_table_reply.
 * @param obj Pointer to an object of type of_bsn_set_l2_table_reply.
 * @param status The value to write into the object
 */
void
of_bsn_set_l2_table_reply_status_set(
    of_bsn_set_l2_table_reply_t *obj,
    uint32_t status)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_L2_TABLE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 20;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, status);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_bsn_set_l2_table_request */
/** \ingroup of_bsn_set_l2_table_request 
 * @{ */

/**
 * Get xid from an object of type of_bsn_set_l2_table_request.
 * @param obj Pointer to an object of type of_bsn_set_l2_table_request.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_set_l2_table_request_xid_get(
    of_bsn_set_l2_table_request_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_L2_TABLE_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_bsn_set_l2_table_request.
 * @param obj Pointer to an object of type of_bsn_set_l2_table_request.
 * @param xid The value to write into the object
 */
void
of_bsn_set_l2_table_request_xid_set(
    of_bsn_set_l2_table_request_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_L2_TABLE_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get experimenter from an object of type of_bsn_set_l2_table_request.
 * @param obj Pointer to an object of type of_bsn_set_l2_table_request.
 * @param experimenter Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_set_l2_table_request_experimenter_get(
    of_bsn_set_l2_table_request_t *obj,
    uint32_t *experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_L2_TABLE_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set experimenter in an object of type of_bsn_set_l2_table_request.
 * @param obj Pointer to an object of type of_bsn_set_l2_table_request.
 * @param experimenter The value to write into the object
 */
void
of_bsn_set_l2_table_request_experimenter_set(
    of_bsn_set_l2_table_request_t *obj,
    uint32_t experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_L2_TABLE_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get subtype from an object of type of_bsn_set_l2_table_request.
 * @param obj Pointer to an object of type of_bsn_set_l2_table_request.
 * @param subtype Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_set_l2_table_request_subtype_get(
    of_bsn_set_l2_table_request_t *obj,
    uint32_t *subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_L2_TABLE_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set subtype in an object of type of_bsn_set_l2_table_request.
 * @param obj Pointer to an object of type of_bsn_set_l2_table_request.
 * @param subtype The value to write into the object
 */
void
of_bsn_set_l2_table_request_subtype_set(
    of_bsn_set_l2_table_request_t *obj,
    uint32_t subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_L2_TABLE_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get l2_table_enable from an object of type of_bsn_set_l2_table_request.
 * @param obj Pointer to an object of type of_bsn_set_l2_table_request.
 * @param l2_table_enable Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_bsn_set_l2_table_request_l2_table_enable_get(
    of_bsn_set_l2_table_request_t *obj,
    uint8_t *l2_table_enable)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_L2_TABLE_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, l2_table_enable);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set l2_table_enable in an object of type of_bsn_set_l2_table_request.
 * @param obj Pointer to an object of type of_bsn_set_l2_table_request.
 * @param l2_table_enable The value to write into the object
 */
void
of_bsn_set_l2_table_request_l2_table_enable_set(
    of_bsn_set_l2_table_request_t *obj,
    uint8_t l2_table_enable)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_L2_TABLE_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, l2_table_enable);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get l2_table_priority from an object of type of_bsn_set_l2_table_request.
 * @param obj Pointer to an object of type of_bsn_set_l2_table_request.
 * @param l2_table_priority Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_bsn_set_l2_table_request_l2_table_priority_get(
    of_bsn_set_l2_table_request_t *obj,
    uint16_t *l2_table_priority)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_L2_TABLE_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 18;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, l2_table_priority);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set l2_table_priority in an object of type of_bsn_set_l2_table_request.
 * @param obj Pointer to an object of type of_bsn_set_l2_table_request.
 * @param l2_table_priority The value to write into the object
 */
void
of_bsn_set_l2_table_request_l2_table_priority_set(
    of_bsn_set_l2_table_request_t *obj,
    uint16_t l2_table_priority)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_L2_TABLE_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 18;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, l2_table_priority);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_bsn_set_mirroring */
/** \ingroup of_bsn_set_mirroring 
 * @{ */

/**
 * Get xid from an object of type of_bsn_set_mirroring.
 * @param obj Pointer to an object of type of_bsn_set_mirroring.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_set_mirroring_xid_get(
    of_bsn_set_mirroring_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_MIRRORING);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_bsn_set_mirroring.
 * @param obj Pointer to an object of type of_bsn_set_mirroring.
 * @param xid The value to write into the object
 */
void
of_bsn_set_mirroring_xid_set(
    of_bsn_set_mirroring_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_MIRRORING);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get experimenter from an object of type of_bsn_set_mirroring.
 * @param obj Pointer to an object of type of_bsn_set_mirroring.
 * @param experimenter Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_set_mirroring_experimenter_get(
    of_bsn_set_mirroring_t *obj,
    uint32_t *experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_MIRRORING);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set experimenter in an object of type of_bsn_set_mirroring.
 * @param obj Pointer to an object of type of_bsn_set_mirroring.
 * @param experimenter The value to write into the object
 */
void
of_bsn_set_mirroring_experimenter_set(
    of_bsn_set_mirroring_t *obj,
    uint32_t experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_MIRRORING);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get subtype from an object of type of_bsn_set_mirroring.
 * @param obj Pointer to an object of type of_bsn_set_mirroring.
 * @param subtype Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_set_mirroring_subtype_get(
    of_bsn_set_mirroring_t *obj,
    uint32_t *subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_MIRRORING);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set subtype in an object of type of_bsn_set_mirroring.
 * @param obj Pointer to an object of type of_bsn_set_mirroring.
 * @param subtype The value to write into the object
 */
void
of_bsn_set_mirroring_subtype_set(
    of_bsn_set_mirroring_t *obj,
    uint32_t subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_MIRRORING);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get report_mirror_ports from an object of type of_bsn_set_mirroring.
 * @param obj Pointer to an object of type of_bsn_set_mirroring.
 * @param report_mirror_ports Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_bsn_set_mirroring_report_mirror_ports_get(
    of_bsn_set_mirroring_t *obj,
    uint8_t *report_mirror_ports)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_MIRRORING);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, report_mirror_ports);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set report_mirror_ports in an object of type of_bsn_set_mirroring.
 * @param obj Pointer to an object of type of_bsn_set_mirroring.
 * @param report_mirror_ports The value to write into the object
 */
void
of_bsn_set_mirroring_report_mirror_ports_set(
    of_bsn_set_mirroring_t *obj,
    uint8_t report_mirror_ports)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_MIRRORING);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, report_mirror_ports);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_bsn_set_pktin_suppression_reply */
/** \ingroup of_bsn_set_pktin_suppression_reply 
 * @{ */

/**
 * Get xid from an object of type of_bsn_set_pktin_suppression_reply.
 * @param obj Pointer to an object of type of_bsn_set_pktin_suppression_reply.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_set_pktin_suppression_reply_xid_get(
    of_bsn_set_pktin_suppression_reply_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_PKTIN_SUPPRESSION_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_bsn_set_pktin_suppression_reply.
 * @param obj Pointer to an object of type of_bsn_set_pktin_suppression_reply.
 * @param xid The value to write into the object
 */
void
of_bsn_set_pktin_suppression_reply_xid_set(
    of_bsn_set_pktin_suppression_reply_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_PKTIN_SUPPRESSION_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get experimenter from an object of type of_bsn_set_pktin_suppression_reply.
 * @param obj Pointer to an object of type of_bsn_set_pktin_suppression_reply.
 * @param experimenter Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_set_pktin_suppression_reply_experimenter_get(
    of_bsn_set_pktin_suppression_reply_t *obj,
    uint32_t *experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_PKTIN_SUPPRESSION_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set experimenter in an object of type of_bsn_set_pktin_suppression_reply.
 * @param obj Pointer to an object of type of_bsn_set_pktin_suppression_reply.
 * @param experimenter The value to write into the object
 */
void
of_bsn_set_pktin_suppression_reply_experimenter_set(
    of_bsn_set_pktin_suppression_reply_t *obj,
    uint32_t experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_PKTIN_SUPPRESSION_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get subtype from an object of type of_bsn_set_pktin_suppression_reply.
 * @param obj Pointer to an object of type of_bsn_set_pktin_suppression_reply.
 * @param subtype Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_set_pktin_suppression_reply_subtype_get(
    of_bsn_set_pktin_suppression_reply_t *obj,
    uint32_t *subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_PKTIN_SUPPRESSION_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set subtype in an object of type of_bsn_set_pktin_suppression_reply.
 * @param obj Pointer to an object of type of_bsn_set_pktin_suppression_reply.
 * @param subtype The value to write into the object
 */
void
of_bsn_set_pktin_suppression_reply_subtype_set(
    of_bsn_set_pktin_suppression_reply_t *obj,
    uint32_t subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_PKTIN_SUPPRESSION_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get status from an object of type of_bsn_set_pktin_suppression_reply.
 * @param obj Pointer to an object of type of_bsn_set_pktin_suppression_reply.
 * @param status Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_set_pktin_suppression_reply_status_get(
    of_bsn_set_pktin_suppression_reply_t *obj,
    uint32_t *status)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_PKTIN_SUPPRESSION_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, status);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set status in an object of type of_bsn_set_pktin_suppression_reply.
 * @param obj Pointer to an object of type of_bsn_set_pktin_suppression_reply.
 * @param status The value to write into the object
 */
void
of_bsn_set_pktin_suppression_reply_status_set(
    of_bsn_set_pktin_suppression_reply_t *obj,
    uint32_t status)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_PKTIN_SUPPRESSION_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, status);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_bsn_set_pktin_suppression_request */
/** \ingroup of_bsn_set_pktin_suppression_request 
 * @{ */

/**
 * Get xid from an object of type of_bsn_set_pktin_suppression_request.
 * @param obj Pointer to an object of type of_bsn_set_pktin_suppression_request.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_set_pktin_suppression_request_xid_get(
    of_bsn_set_pktin_suppression_request_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_PKTIN_SUPPRESSION_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_bsn_set_pktin_suppression_request.
 * @param obj Pointer to an object of type of_bsn_set_pktin_suppression_request.
 * @param xid The value to write into the object
 */
void
of_bsn_set_pktin_suppression_request_xid_set(
    of_bsn_set_pktin_suppression_request_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_PKTIN_SUPPRESSION_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get experimenter from an object of type of_bsn_set_pktin_suppression_request.
 * @param obj Pointer to an object of type of_bsn_set_pktin_suppression_request.
 * @param experimenter Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_set_pktin_suppression_request_experimenter_get(
    of_bsn_set_pktin_suppression_request_t *obj,
    uint32_t *experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_PKTIN_SUPPRESSION_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set experimenter in an object of type of_bsn_set_pktin_suppression_request.
 * @param obj Pointer to an object of type of_bsn_set_pktin_suppression_request.
 * @param experimenter The value to write into the object
 */
void
of_bsn_set_pktin_suppression_request_experimenter_set(
    of_bsn_set_pktin_suppression_request_t *obj,
    uint32_t experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_PKTIN_SUPPRESSION_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get subtype from an object of type of_bsn_set_pktin_suppression_request.
 * @param obj Pointer to an object of type of_bsn_set_pktin_suppression_request.
 * @param subtype Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_set_pktin_suppression_request_subtype_get(
    of_bsn_set_pktin_suppression_request_t *obj,
    uint32_t *subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_PKTIN_SUPPRESSION_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set subtype in an object of type of_bsn_set_pktin_suppression_request.
 * @param obj Pointer to an object of type of_bsn_set_pktin_suppression_request.
 * @param subtype The value to write into the object
 */
void
of_bsn_set_pktin_suppression_request_subtype_set(
    of_bsn_set_pktin_suppression_request_t *obj,
    uint32_t subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_PKTIN_SUPPRESSION_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get enabled from an object of type of_bsn_set_pktin_suppression_request.
 * @param obj Pointer to an object of type of_bsn_set_pktin_suppression_request.
 * @param enabled Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_bsn_set_pktin_suppression_request_enabled_get(
    of_bsn_set_pktin_suppression_request_t *obj,
    uint8_t *enabled)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_PKTIN_SUPPRESSION_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, enabled);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set enabled in an object of type of_bsn_set_pktin_suppression_request.
 * @param obj Pointer to an object of type of_bsn_set_pktin_suppression_request.
 * @param enabled The value to write into the object
 */
void
of_bsn_set_pktin_suppression_request_enabled_set(
    of_bsn_set_pktin_suppression_request_t *obj,
    uint8_t enabled)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_PKTIN_SUPPRESSION_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, enabled);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get idle_timeout from an object of type of_bsn_set_pktin_suppression_request.
 * @param obj Pointer to an object of type of_bsn_set_pktin_suppression_request.
 * @param idle_timeout Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_bsn_set_pktin_suppression_request_idle_timeout_get(
    of_bsn_set_pktin_suppression_request_t *obj,
    uint16_t *idle_timeout)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_PKTIN_SUPPRESSION_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 18;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, idle_timeout);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set idle_timeout in an object of type of_bsn_set_pktin_suppression_request.
 * @param obj Pointer to an object of type of_bsn_set_pktin_suppression_request.
 * @param idle_timeout The value to write into the object
 */
void
of_bsn_set_pktin_suppression_request_idle_timeout_set(
    of_bsn_set_pktin_suppression_request_t *obj,
    uint16_t idle_timeout)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_PKTIN_SUPPRESSION_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 18;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, idle_timeout);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get hard_timeout from an object of type of_bsn_set_pktin_suppression_request.
 * @param obj Pointer to an object of type of_bsn_set_pktin_suppression_request.
 * @param hard_timeout Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_bsn_set_pktin_suppression_request_hard_timeout_get(
    of_bsn_set_pktin_suppression_request_t *obj,
    uint16_t *hard_timeout)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_PKTIN_SUPPRESSION_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 20;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, hard_timeout);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set hard_timeout in an object of type of_bsn_set_pktin_suppression_request.
 * @param obj Pointer to an object of type of_bsn_set_pktin_suppression_request.
 * @param hard_timeout The value to write into the object
 */
void
of_bsn_set_pktin_suppression_request_hard_timeout_set(
    of_bsn_set_pktin_suppression_request_t *obj,
    uint16_t hard_timeout)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_PKTIN_SUPPRESSION_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 20;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, hard_timeout);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get priority from an object of type of_bsn_set_pktin_suppression_request.
 * @param obj Pointer to an object of type of_bsn_set_pktin_suppression_request.
 * @param priority Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_bsn_set_pktin_suppression_request_priority_get(
    of_bsn_set_pktin_suppression_request_t *obj,
    uint16_t *priority)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_PKTIN_SUPPRESSION_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 22;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, priority);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set priority in an object of type of_bsn_set_pktin_suppression_request.
 * @param obj Pointer to an object of type of_bsn_set_pktin_suppression_request.
 * @param priority The value to write into the object
 */
void
of_bsn_set_pktin_suppression_request_priority_set(
    of_bsn_set_pktin_suppression_request_t *obj,
    uint16_t priority)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_PKTIN_SUPPRESSION_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 22;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, priority);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get cookie from an object of type of_bsn_set_pktin_suppression_request.
 * @param obj Pointer to an object of type of_bsn_set_pktin_suppression_request.
 * @param cookie Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_bsn_set_pktin_suppression_request_cookie_get(
    of_bsn_set_pktin_suppression_request_t *obj,
    uint64_t *cookie)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_PKTIN_SUPPRESSION_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 24;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, cookie);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set cookie in an object of type of_bsn_set_pktin_suppression_request.
 * @param obj Pointer to an object of type of_bsn_set_pktin_suppression_request.
 * @param cookie The value to write into the object
 */
void
of_bsn_set_pktin_suppression_request_cookie_set(
    of_bsn_set_pktin_suppression_request_t *obj,
    uint64_t cookie)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SET_PKTIN_SUPPRESSION_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 24;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, cookie);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_bsn_shell_command */
/** \ingroup of_bsn_shell_command 
 * @{ */

/**
 * Get xid from an object of type of_bsn_shell_command.
 * @param obj Pointer to an object of type of_bsn_shell_command.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_shell_command_xid_get(
    of_bsn_shell_command_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SHELL_COMMAND);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_bsn_shell_command.
 * @param obj Pointer to an object of type of_bsn_shell_command.
 * @param xid The value to write into the object
 */
void
of_bsn_shell_command_xid_set(
    of_bsn_shell_command_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SHELL_COMMAND);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get experimenter from an object of type of_bsn_shell_command.
 * @param obj Pointer to an object of type of_bsn_shell_command.
 * @param experimenter Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_shell_command_experimenter_get(
    of_bsn_shell_command_t *obj,
    uint32_t *experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SHELL_COMMAND);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set experimenter in an object of type of_bsn_shell_command.
 * @param obj Pointer to an object of type of_bsn_shell_command.
 * @param experimenter The value to write into the object
 */
void
of_bsn_shell_command_experimenter_set(
    of_bsn_shell_command_t *obj,
    uint32_t experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SHELL_COMMAND);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get subtype from an object of type of_bsn_shell_command.
 * @param obj Pointer to an object of type of_bsn_shell_command.
 * @param subtype Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_shell_command_subtype_get(
    of_bsn_shell_command_t *obj,
    uint32_t *subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SHELL_COMMAND);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set subtype in an object of type of_bsn_shell_command.
 * @param obj Pointer to an object of type of_bsn_shell_command.
 * @param subtype The value to write into the object
 */
void
of_bsn_shell_command_subtype_set(
    of_bsn_shell_command_t *obj,
    uint32_t subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SHELL_COMMAND);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get service from an object of type of_bsn_shell_command.
 * @param obj Pointer to an object of type of_bsn_shell_command.
 * @param service Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_shell_command_service_get(
    of_bsn_shell_command_t *obj,
    uint32_t *service)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SHELL_COMMAND);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, service);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set service in an object of type of_bsn_shell_command.
 * @param obj Pointer to an object of type of_bsn_shell_command.
 * @param service The value to write into the object
 */
void
of_bsn_shell_command_service_set(
    of_bsn_shell_command_t *obj,
    uint32_t service)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SHELL_COMMAND);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, service);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get data from an object of type of_bsn_shell_command.
 * @param obj Pointer to an object of type of_bsn_shell_command.
 * @param data Pointer to the child object of type
 * of_octets_t to be filled out.
 *
 */
void
of_bsn_shell_command_data_get(
    of_bsn_shell_command_t *obj,
    of_octets_t *data)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_BSN_SHELL_COMMAND);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 20;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);
    ASSERT(cur_len + abs_offset <= WBUF_CURRENT_BYTES(wbuf));
    data->bytes = cur_len;
    data->data = OF_WIRE_BUFFER_INDEX(wbuf, abs_offset);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set data in an object of type of_bsn_shell_command.
 * @param obj Pointer to an object of type of_bsn_shell_command.
 * @param data The value to write into the object
 */
int WARN_UNUSED_RESULT
of_bsn_shell_command_data_set(
    of_bsn_shell_command_t *obj,
    of_octets_t *data)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_BSN_SHELL_COMMAND);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 20;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);
    new_len = data->bytes;
    of_wire_buffer_grow(wbuf, abs_offset + (new_len - cur_len));
    of_wire_buffer_octets_data_set(wbuf, abs_offset, data, cur_len);

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_bsn_shell_output */
/** \ingroup of_bsn_shell_output 
 * @{ */

/**
 * Get xid from an object of type of_bsn_shell_output.
 * @param obj Pointer to an object of type of_bsn_shell_output.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_shell_output_xid_get(
    of_bsn_shell_output_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SHELL_OUTPUT);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_bsn_shell_output.
 * @param obj Pointer to an object of type of_bsn_shell_output.
 * @param xid The value to write into the object
 */
void
of_bsn_shell_output_xid_set(
    of_bsn_shell_output_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SHELL_OUTPUT);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get experimenter from an object of type of_bsn_shell_output.
 * @param obj Pointer to an object of type of_bsn_shell_output.
 * @param experimenter Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_shell_output_experimenter_get(
    of_bsn_shell_output_t *obj,
    uint32_t *experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SHELL_OUTPUT);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set experimenter in an object of type of_bsn_shell_output.
 * @param obj Pointer to an object of type of_bsn_shell_output.
 * @param experimenter The value to write into the object
 */
void
of_bsn_shell_output_experimenter_set(
    of_bsn_shell_output_t *obj,
    uint32_t experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SHELL_OUTPUT);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get subtype from an object of type of_bsn_shell_output.
 * @param obj Pointer to an object of type of_bsn_shell_output.
 * @param subtype Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_shell_output_subtype_get(
    of_bsn_shell_output_t *obj,
    uint32_t *subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SHELL_OUTPUT);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set subtype in an object of type of_bsn_shell_output.
 * @param obj Pointer to an object of type of_bsn_shell_output.
 * @param subtype The value to write into the object
 */
void
of_bsn_shell_output_subtype_set(
    of_bsn_shell_output_t *obj,
    uint32_t subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SHELL_OUTPUT);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get data from an object of type of_bsn_shell_output.
 * @param obj Pointer to an object of type of_bsn_shell_output.
 * @param data Pointer to the child object of type
 * of_octets_t to be filled out.
 *
 */
void
of_bsn_shell_output_data_get(
    of_bsn_shell_output_t *obj,
    of_octets_t *data)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_BSN_SHELL_OUTPUT);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 16;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);
    ASSERT(cur_len + abs_offset <= WBUF_CURRENT_BYTES(wbuf));
    data->bytes = cur_len;
    data->data = OF_WIRE_BUFFER_INDEX(wbuf, abs_offset);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set data in an object of type of_bsn_shell_output.
 * @param obj Pointer to an object of type of_bsn_shell_output.
 * @param data The value to write into the object
 */
int WARN_UNUSED_RESULT
of_bsn_shell_output_data_set(
    of_bsn_shell_output_t *obj,
    of_octets_t *data)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_BSN_SHELL_OUTPUT);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 16;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);
    new_len = data->bytes;
    of_wire_buffer_grow(wbuf, abs_offset + (new_len - cur_len));
    of_wire_buffer_octets_data_set(wbuf, abs_offset, data, cur_len);

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_bsn_shell_status */
/** \ingroup of_bsn_shell_status 
 * @{ */

/**
 * Get xid from an object of type of_bsn_shell_status.
 * @param obj Pointer to an object of type of_bsn_shell_status.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_shell_status_xid_get(
    of_bsn_shell_status_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SHELL_STATUS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_bsn_shell_status.
 * @param obj Pointer to an object of type of_bsn_shell_status.
 * @param xid The value to write into the object
 */
void
of_bsn_shell_status_xid_set(
    of_bsn_shell_status_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SHELL_STATUS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get experimenter from an object of type of_bsn_shell_status.
 * @param obj Pointer to an object of type of_bsn_shell_status.
 * @param experimenter Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_shell_status_experimenter_get(
    of_bsn_shell_status_t *obj,
    uint32_t *experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SHELL_STATUS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set experimenter in an object of type of_bsn_shell_status.
 * @param obj Pointer to an object of type of_bsn_shell_status.
 * @param experimenter The value to write into the object
 */
void
of_bsn_shell_status_experimenter_set(
    of_bsn_shell_status_t *obj,
    uint32_t experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SHELL_STATUS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get subtype from an object of type of_bsn_shell_status.
 * @param obj Pointer to an object of type of_bsn_shell_status.
 * @param subtype Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_shell_status_subtype_get(
    of_bsn_shell_status_t *obj,
    uint32_t *subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SHELL_STATUS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set subtype in an object of type of_bsn_shell_status.
 * @param obj Pointer to an object of type of_bsn_shell_status.
 * @param subtype The value to write into the object
 */
void
of_bsn_shell_status_subtype_set(
    of_bsn_shell_status_t *obj,
    uint32_t subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SHELL_STATUS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get status from an object of type of_bsn_shell_status.
 * @param obj Pointer to an object of type of_bsn_shell_status.
 * @param status Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_shell_status_status_get(
    of_bsn_shell_status_t *obj,
    uint32_t *status)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SHELL_STATUS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, status);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set status in an object of type of_bsn_shell_status.
 * @param obj Pointer to an object of type of_bsn_shell_status.
 * @param status The value to write into the object
 */
void
of_bsn_shell_status_status_set(
    of_bsn_shell_status_t *obj,
    uint32_t status)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_SHELL_STATUS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, status);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_bsn_virtual_port_create_reply */
/** \ingroup of_bsn_virtual_port_create_reply 
 * @{ */

/**
 * Get xid from an object of type of_bsn_virtual_port_create_reply.
 * @param obj Pointer to an object of type of_bsn_virtual_port_create_reply.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_virtual_port_create_reply_xid_get(
    of_bsn_virtual_port_create_reply_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_VIRTUAL_PORT_CREATE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_bsn_virtual_port_create_reply.
 * @param obj Pointer to an object of type of_bsn_virtual_port_create_reply.
 * @param xid The value to write into the object
 */
void
of_bsn_virtual_port_create_reply_xid_set(
    of_bsn_virtual_port_create_reply_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_VIRTUAL_PORT_CREATE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get experimenter from an object of type of_bsn_virtual_port_create_reply.
 * @param obj Pointer to an object of type of_bsn_virtual_port_create_reply.
 * @param experimenter Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_virtual_port_create_reply_experimenter_get(
    of_bsn_virtual_port_create_reply_t *obj,
    uint32_t *experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_VIRTUAL_PORT_CREATE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set experimenter in an object of type of_bsn_virtual_port_create_reply.
 * @param obj Pointer to an object of type of_bsn_virtual_port_create_reply.
 * @param experimenter The value to write into the object
 */
void
of_bsn_virtual_port_create_reply_experimenter_set(
    of_bsn_virtual_port_create_reply_t *obj,
    uint32_t experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_VIRTUAL_PORT_CREATE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get subtype from an object of type of_bsn_virtual_port_create_reply.
 * @param obj Pointer to an object of type of_bsn_virtual_port_create_reply.
 * @param subtype Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_virtual_port_create_reply_subtype_get(
    of_bsn_virtual_port_create_reply_t *obj,
    uint32_t *subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_VIRTUAL_PORT_CREATE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set subtype in an object of type of_bsn_virtual_port_create_reply.
 * @param obj Pointer to an object of type of_bsn_virtual_port_create_reply.
 * @param subtype The value to write into the object
 */
void
of_bsn_virtual_port_create_reply_subtype_set(
    of_bsn_virtual_port_create_reply_t *obj,
    uint32_t subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_VIRTUAL_PORT_CREATE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get status from an object of type of_bsn_virtual_port_create_reply.
 * @param obj Pointer to an object of type of_bsn_virtual_port_create_reply.
 * @param status Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_virtual_port_create_reply_status_get(
    of_bsn_virtual_port_create_reply_t *obj,
    uint32_t *status)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_VIRTUAL_PORT_CREATE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, status);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set status in an object of type of_bsn_virtual_port_create_reply.
 * @param obj Pointer to an object of type of_bsn_virtual_port_create_reply.
 * @param status The value to write into the object
 */
void
of_bsn_virtual_port_create_reply_status_set(
    of_bsn_virtual_port_create_reply_t *obj,
    uint32_t status)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_VIRTUAL_PORT_CREATE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, status);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get vport_no from an object of type of_bsn_virtual_port_create_reply.
 * @param obj Pointer to an object of type of_bsn_virtual_port_create_reply.
 * @param vport_no Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_virtual_port_create_reply_vport_no_get(
    of_bsn_virtual_port_create_reply_t *obj,
    uint32_t *vport_no)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_VIRTUAL_PORT_CREATE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 20;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, vport_no);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set vport_no in an object of type of_bsn_virtual_port_create_reply.
 * @param obj Pointer to an object of type of_bsn_virtual_port_create_reply.
 * @param vport_no The value to write into the object
 */
void
of_bsn_virtual_port_create_reply_vport_no_set(
    of_bsn_virtual_port_create_reply_t *obj,
    uint32_t vport_no)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_VIRTUAL_PORT_CREATE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 20;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, vport_no);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_bsn_virtual_port_create_request */
/** \ingroup of_bsn_virtual_port_create_request 
 * @{ */

/**
 * Get xid from an object of type of_bsn_virtual_port_create_request.
 * @param obj Pointer to an object of type of_bsn_virtual_port_create_request.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_virtual_port_create_request_xid_get(
    of_bsn_virtual_port_create_request_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_VIRTUAL_PORT_CREATE_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_bsn_virtual_port_create_request.
 * @param obj Pointer to an object of type of_bsn_virtual_port_create_request.
 * @param xid The value to write into the object
 */
void
of_bsn_virtual_port_create_request_xid_set(
    of_bsn_virtual_port_create_request_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_VIRTUAL_PORT_CREATE_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get experimenter from an object of type of_bsn_virtual_port_create_request.
 * @param obj Pointer to an object of type of_bsn_virtual_port_create_request.
 * @param experimenter Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_virtual_port_create_request_experimenter_get(
    of_bsn_virtual_port_create_request_t *obj,
    uint32_t *experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_VIRTUAL_PORT_CREATE_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set experimenter in an object of type of_bsn_virtual_port_create_request.
 * @param obj Pointer to an object of type of_bsn_virtual_port_create_request.
 * @param experimenter The value to write into the object
 */
void
of_bsn_virtual_port_create_request_experimenter_set(
    of_bsn_virtual_port_create_request_t *obj,
    uint32_t experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_VIRTUAL_PORT_CREATE_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get subtype from an object of type of_bsn_virtual_port_create_request.
 * @param obj Pointer to an object of type of_bsn_virtual_port_create_request.
 * @param subtype Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_virtual_port_create_request_subtype_get(
    of_bsn_virtual_port_create_request_t *obj,
    uint32_t *subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_VIRTUAL_PORT_CREATE_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set subtype in an object of type of_bsn_virtual_port_create_request.
 * @param obj Pointer to an object of type of_bsn_virtual_port_create_request.
 * @param subtype The value to write into the object
 */
void
of_bsn_virtual_port_create_request_subtype_set(
    of_bsn_virtual_port_create_request_t *obj,
    uint32_t subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_VIRTUAL_PORT_CREATE_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Bind an object of type of_bsn_vport_q_in_q_t to the parent of type of_bsn_virtual_port_create_request for
 * member vport
 * @param obj Pointer to an object of type of_bsn_virtual_port_create_request.
 * @param vport Pointer to the child object of type
 * of_bsn_vport_q_in_q_t to be filled out.
 * \ingroup of_bsn_virtual_port_create_request
 *
 * The parameter vport is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_bsn_virtual_port_create_request_vport_bind(
    of_bsn_virtual_port_create_request_t *obj,
    of_bsn_vport_q_in_q_t *vport)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_BSN_VIRTUAL_PORT_CREATE_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        cur_len = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_bsn_vport_q_in_q_init(vport, obj->version, 0, 1);
    /* Attach to parent */
    vport->parent = (of_object_t *)obj;
    vport->wire_object.wbuf = obj->wire_object.wbuf;
    vport->wire_object.obj_offset = abs_offset;
    vport->wire_object.owned = 0;
    vport->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of vport into a new variable of type of_bsn_vport_q_in_q_t from
 * a of_bsn_virtual_port_create_request instance.
 *
 * @param obj Pointer to the source of type of_bsn_virtual_port_create_request_t
 * @returns A pointer to a new instance of type of_bsn_vport_q_in_q_t whose contents
 * match that of vport from source
 * @returns NULL if an error occurs
 */
of_bsn_vport_q_in_q_t *
of_bsn_virtual_port_create_request_vport_get(of_bsn_virtual_port_create_request_t *obj) {
    of_bsn_vport_q_in_q_t _vport;
    of_bsn_vport_q_in_q_t *_vport_ptr;

    of_bsn_virtual_port_create_request_vport_bind(obj, &_vport);
    _vport_ptr = (of_bsn_vport_q_in_q_t *)of_object_dup(&_vport);
    return _vport_ptr;
}

/**
 * Set vport in an object of type of_bsn_virtual_port_create_request.
 * @param obj Pointer to an object of type of_bsn_virtual_port_create_request.
 * @param vport Pointer to the child of type of_bsn_vport_q_in_q_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
void
of_bsn_virtual_port_create_request_vport_set(
    of_bsn_virtual_port_create_request_t *obj,
    of_bsn_vport_q_in_q_t *vport)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_BSN_VIRTUAL_PORT_CREATE_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        cur_len = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = vport->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == vport->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(vport, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return ;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(vport, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (vport->wire_length_set != NULL) {
        vport->wire_length_set((of_object_t *)vport, vport->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_bsn_virtual_port_remove_reply */
/** \ingroup of_bsn_virtual_port_remove_reply 
 * @{ */

/**
 * Get xid from an object of type of_bsn_virtual_port_remove_reply.
 * @param obj Pointer to an object of type of_bsn_virtual_port_remove_reply.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_virtual_port_remove_reply_xid_get(
    of_bsn_virtual_port_remove_reply_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_VIRTUAL_PORT_REMOVE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_bsn_virtual_port_remove_reply.
 * @param obj Pointer to an object of type of_bsn_virtual_port_remove_reply.
 * @param xid The value to write into the object
 */
void
of_bsn_virtual_port_remove_reply_xid_set(
    of_bsn_virtual_port_remove_reply_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_VIRTUAL_PORT_REMOVE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get experimenter from an object of type of_bsn_virtual_port_remove_reply.
 * @param obj Pointer to an object of type of_bsn_virtual_port_remove_reply.
 * @param experimenter Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_virtual_port_remove_reply_experimenter_get(
    of_bsn_virtual_port_remove_reply_t *obj,
    uint32_t *experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_VIRTUAL_PORT_REMOVE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set experimenter in an object of type of_bsn_virtual_port_remove_reply.
 * @param obj Pointer to an object of type of_bsn_virtual_port_remove_reply.
 * @param experimenter The value to write into the object
 */
void
of_bsn_virtual_port_remove_reply_experimenter_set(
    of_bsn_virtual_port_remove_reply_t *obj,
    uint32_t experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_VIRTUAL_PORT_REMOVE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get subtype from an object of type of_bsn_virtual_port_remove_reply.
 * @param obj Pointer to an object of type of_bsn_virtual_port_remove_reply.
 * @param subtype Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_virtual_port_remove_reply_subtype_get(
    of_bsn_virtual_port_remove_reply_t *obj,
    uint32_t *subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_VIRTUAL_PORT_REMOVE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set subtype in an object of type of_bsn_virtual_port_remove_reply.
 * @param obj Pointer to an object of type of_bsn_virtual_port_remove_reply.
 * @param subtype The value to write into the object
 */
void
of_bsn_virtual_port_remove_reply_subtype_set(
    of_bsn_virtual_port_remove_reply_t *obj,
    uint32_t subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_VIRTUAL_PORT_REMOVE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get status from an object of type of_bsn_virtual_port_remove_reply.
 * @param obj Pointer to an object of type of_bsn_virtual_port_remove_reply.
 * @param status Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_virtual_port_remove_reply_status_get(
    of_bsn_virtual_port_remove_reply_t *obj,
    uint32_t *status)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_VIRTUAL_PORT_REMOVE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, status);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set status in an object of type of_bsn_virtual_port_remove_reply.
 * @param obj Pointer to an object of type of_bsn_virtual_port_remove_reply.
 * @param status The value to write into the object
 */
void
of_bsn_virtual_port_remove_reply_status_set(
    of_bsn_virtual_port_remove_reply_t *obj,
    uint32_t status)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_VIRTUAL_PORT_REMOVE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, status);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_bsn_virtual_port_remove_request */
/** \ingroup of_bsn_virtual_port_remove_request 
 * @{ */

/**
 * Get xid from an object of type of_bsn_virtual_port_remove_request.
 * @param obj Pointer to an object of type of_bsn_virtual_port_remove_request.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_virtual_port_remove_request_xid_get(
    of_bsn_virtual_port_remove_request_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_VIRTUAL_PORT_REMOVE_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_bsn_virtual_port_remove_request.
 * @param obj Pointer to an object of type of_bsn_virtual_port_remove_request.
 * @param xid The value to write into the object
 */
void
of_bsn_virtual_port_remove_request_xid_set(
    of_bsn_virtual_port_remove_request_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_VIRTUAL_PORT_REMOVE_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get experimenter from an object of type of_bsn_virtual_port_remove_request.
 * @param obj Pointer to an object of type of_bsn_virtual_port_remove_request.
 * @param experimenter Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_virtual_port_remove_request_experimenter_get(
    of_bsn_virtual_port_remove_request_t *obj,
    uint32_t *experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_VIRTUAL_PORT_REMOVE_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set experimenter in an object of type of_bsn_virtual_port_remove_request.
 * @param obj Pointer to an object of type of_bsn_virtual_port_remove_request.
 * @param experimenter The value to write into the object
 */
void
of_bsn_virtual_port_remove_request_experimenter_set(
    of_bsn_virtual_port_remove_request_t *obj,
    uint32_t experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_VIRTUAL_PORT_REMOVE_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get subtype from an object of type of_bsn_virtual_port_remove_request.
 * @param obj Pointer to an object of type of_bsn_virtual_port_remove_request.
 * @param subtype Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_virtual_port_remove_request_subtype_get(
    of_bsn_virtual_port_remove_request_t *obj,
    uint32_t *subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_VIRTUAL_PORT_REMOVE_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set subtype in an object of type of_bsn_virtual_port_remove_request.
 * @param obj Pointer to an object of type of_bsn_virtual_port_remove_request.
 * @param subtype The value to write into the object
 */
void
of_bsn_virtual_port_remove_request_subtype_set(
    of_bsn_virtual_port_remove_request_t *obj,
    uint32_t subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_VIRTUAL_PORT_REMOVE_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get vport_no from an object of type of_bsn_virtual_port_remove_request.
 * @param obj Pointer to an object of type of_bsn_virtual_port_remove_request.
 * @param vport_no Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_virtual_port_remove_request_vport_no_get(
    of_bsn_virtual_port_remove_request_t *obj,
    uint32_t *vport_no)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_VIRTUAL_PORT_REMOVE_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, vport_no);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set vport_no in an object of type of_bsn_virtual_port_remove_request.
 * @param obj Pointer to an object of type of_bsn_virtual_port_remove_request.
 * @param vport_no The value to write into the object
 */
void
of_bsn_virtual_port_remove_request_vport_no_set(
    of_bsn_virtual_port_remove_request_t *obj,
    uint32_t vport_no)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_VIRTUAL_PORT_REMOVE_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, vport_no);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_desc_stats_reply */
/** \ingroup of_desc_stats_reply 
 * @{ */

/**
 * Get xid from an object of type of_desc_stats_reply.
 * @param obj Pointer to an object of type of_desc_stats_reply.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_desc_stats_reply_xid_get(
    of_desc_stats_reply_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_DESC_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_desc_stats_reply.
 * @param obj Pointer to an object of type of_desc_stats_reply.
 * @param xid The value to write into the object
 */
void
of_desc_stats_reply_xid_set(
    of_desc_stats_reply_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_DESC_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get flags from an object of type of_desc_stats_reply.
 * @param obj Pointer to an object of type of_desc_stats_reply.
 * @param flags Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_desc_stats_reply_flags_get(
    of_desc_stats_reply_t *obj,
    uint16_t *flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_DESC_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set flags in an object of type of_desc_stats_reply.
 * @param obj Pointer to an object of type of_desc_stats_reply.
 * @param flags The value to write into the object
 */
void
of_desc_stats_reply_flags_set(
    of_desc_stats_reply_t *obj,
    uint16_t flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_DESC_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get mfr_desc from an object of type of_desc_stats_reply.
 * @param obj Pointer to an object of type of_desc_stats_reply.
 * @param mfr_desc Pointer to the child object of type
 * of_desc_str_t to be filled out.
 *
 */
void
of_desc_stats_reply_mfr_desc_get(
    of_desc_stats_reply_t *obj,
    of_desc_str_t *mfr_desc)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_DESC_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_desc_str_get(wbuf, abs_offset, mfr_desc);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set mfr_desc in an object of type of_desc_stats_reply.
 * @param obj Pointer to an object of type of_desc_stats_reply.
 * @param mfr_desc The value to write into the object
 */
void
of_desc_stats_reply_mfr_desc_set(
    of_desc_stats_reply_t *obj,
    of_desc_str_t mfr_desc)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_DESC_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_desc_str_set(wbuf, abs_offset, mfr_desc);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get hw_desc from an object of type of_desc_stats_reply.
 * @param obj Pointer to an object of type of_desc_stats_reply.
 * @param hw_desc Pointer to the child object of type
 * of_desc_str_t to be filled out.
 *
 */
void
of_desc_stats_reply_hw_desc_get(
    of_desc_stats_reply_t *obj,
    of_desc_str_t *hw_desc)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_DESC_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 268;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 272;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_desc_str_get(wbuf, abs_offset, hw_desc);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set hw_desc in an object of type of_desc_stats_reply.
 * @param obj Pointer to an object of type of_desc_stats_reply.
 * @param hw_desc The value to write into the object
 */
void
of_desc_stats_reply_hw_desc_set(
    of_desc_stats_reply_t *obj,
    of_desc_str_t hw_desc)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_DESC_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 268;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 272;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_desc_str_set(wbuf, abs_offset, hw_desc);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get sw_desc from an object of type of_desc_stats_reply.
 * @param obj Pointer to an object of type of_desc_stats_reply.
 * @param sw_desc Pointer to the child object of type
 * of_desc_str_t to be filled out.
 *
 */
void
of_desc_stats_reply_sw_desc_get(
    of_desc_stats_reply_t *obj,
    of_desc_str_t *sw_desc)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_DESC_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 524;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 528;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_desc_str_get(wbuf, abs_offset, sw_desc);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set sw_desc in an object of type of_desc_stats_reply.
 * @param obj Pointer to an object of type of_desc_stats_reply.
 * @param sw_desc The value to write into the object
 */
void
of_desc_stats_reply_sw_desc_set(
    of_desc_stats_reply_t *obj,
    of_desc_str_t sw_desc)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_DESC_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 524;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 528;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_desc_str_set(wbuf, abs_offset, sw_desc);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get serial_num from an object of type of_desc_stats_reply.
 * @param obj Pointer to an object of type of_desc_stats_reply.
 * @param serial_num Pointer to the child object of type
 * of_serial_num_t to be filled out.
 *
 */
void
of_desc_stats_reply_serial_num_get(
    of_desc_stats_reply_t *obj,
    of_serial_num_t *serial_num)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_DESC_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 780;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 784;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_ser_num_get(wbuf, abs_offset, serial_num);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set serial_num in an object of type of_desc_stats_reply.
 * @param obj Pointer to an object of type of_desc_stats_reply.
 * @param serial_num The value to write into the object
 */
void
of_desc_stats_reply_serial_num_set(
    of_desc_stats_reply_t *obj,
    of_serial_num_t serial_num)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_DESC_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 780;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 784;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_ser_num_set(wbuf, abs_offset, serial_num);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get dp_desc from an object of type of_desc_stats_reply.
 * @param obj Pointer to an object of type of_desc_stats_reply.
 * @param dp_desc Pointer to the child object of type
 * of_desc_str_t to be filled out.
 *
 */
void
of_desc_stats_reply_dp_desc_get(
    of_desc_stats_reply_t *obj,
    of_desc_str_t *dp_desc)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_DESC_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 812;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 816;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_desc_str_get(wbuf, abs_offset, dp_desc);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set dp_desc in an object of type of_desc_stats_reply.
 * @param obj Pointer to an object of type of_desc_stats_reply.
 * @param dp_desc The value to write into the object
 */
void
of_desc_stats_reply_dp_desc_set(
    of_desc_stats_reply_t *obj,
    of_desc_str_t dp_desc)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_DESC_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 812;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 816;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_desc_str_set(wbuf, abs_offset, dp_desc);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_desc_stats_request */
/** \ingroup of_desc_stats_request 
 * @{ */

/**
 * Get xid from an object of type of_desc_stats_request.
 * @param obj Pointer to an object of type of_desc_stats_request.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_desc_stats_request_xid_get(
    of_desc_stats_request_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_DESC_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_desc_stats_request.
 * @param obj Pointer to an object of type of_desc_stats_request.
 * @param xid The value to write into the object
 */
void
of_desc_stats_request_xid_set(
    of_desc_stats_request_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_DESC_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get flags from an object of type of_desc_stats_request.
 * @param obj Pointer to an object of type of_desc_stats_request.
 * @param flags Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_desc_stats_request_flags_get(
    of_desc_stats_request_t *obj,
    uint16_t *flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_DESC_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set flags in an object of type of_desc_stats_request.
 * @param obj Pointer to an object of type of_desc_stats_request.
 * @param flags The value to write into the object
 */
void
of_desc_stats_request_flags_set(
    of_desc_stats_request_t *obj,
    uint16_t flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_DESC_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_echo_reply */
/** \ingroup of_echo_reply 
 * @{ */

/**
 * Get xid from an object of type of_echo_reply.
 * @param obj Pointer to an object of type of_echo_reply.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_echo_reply_xid_get(
    of_echo_reply_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ECHO_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_echo_reply.
 * @param obj Pointer to an object of type of_echo_reply.
 * @param xid The value to write into the object
 */
void
of_echo_reply_xid_set(
    of_echo_reply_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ECHO_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get data from an object of type of_echo_reply.
 * @param obj Pointer to an object of type of_echo_reply.
 * @param data Pointer to the child object of type
 * of_octets_t to be filled out.
 *
 */
void
of_echo_reply_data_get(
    of_echo_reply_t *obj,
    of_octets_t *data)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_ECHO_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);
    ASSERT(cur_len + abs_offset <= WBUF_CURRENT_BYTES(wbuf));
    data->bytes = cur_len;
    data->data = OF_WIRE_BUFFER_INDEX(wbuf, abs_offset);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set data in an object of type of_echo_reply.
 * @param obj Pointer to an object of type of_echo_reply.
 * @param data The value to write into the object
 */
int WARN_UNUSED_RESULT
of_echo_reply_data_set(
    of_echo_reply_t *obj,
    of_octets_t *data)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_ECHO_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);
    new_len = data->bytes;
    of_wire_buffer_grow(wbuf, abs_offset + (new_len - cur_len));
    of_wire_buffer_octets_data_set(wbuf, abs_offset, data, cur_len);

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_echo_request */
/** \ingroup of_echo_request 
 * @{ */

/**
 * Get xid from an object of type of_echo_request.
 * @param obj Pointer to an object of type of_echo_request.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_echo_request_xid_get(
    of_echo_request_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ECHO_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_echo_request.
 * @param obj Pointer to an object of type of_echo_request.
 * @param xid The value to write into the object
 */
void
of_echo_request_xid_set(
    of_echo_request_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ECHO_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get data from an object of type of_echo_request.
 * @param obj Pointer to an object of type of_echo_request.
 * @param data Pointer to the child object of type
 * of_octets_t to be filled out.
 *
 */
void
of_echo_request_data_get(
    of_echo_request_t *obj,
    of_octets_t *data)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_ECHO_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);
    ASSERT(cur_len + abs_offset <= WBUF_CURRENT_BYTES(wbuf));
    data->bytes = cur_len;
    data->data = OF_WIRE_BUFFER_INDEX(wbuf, abs_offset);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set data in an object of type of_echo_request.
 * @param obj Pointer to an object of type of_echo_request.
 * @param data The value to write into the object
 */
int WARN_UNUSED_RESULT
of_echo_request_data_set(
    of_echo_request_t *obj,
    of_octets_t *data)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_ECHO_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);
    new_len = data->bytes;
    of_wire_buffer_grow(wbuf, abs_offset + (new_len - cur_len));
    of_wire_buffer_octets_data_set(wbuf, abs_offset, data, cur_len);

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_error_msg */
/** \ingroup of_error_msg 
 * @{ */

/**
 * Get xid from an object of type of_error_msg.
 * @param obj Pointer to an object of type of_error_msg.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_error_msg_xid_get(
    of_error_msg_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ERROR_MSG);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_error_msg.
 * @param obj Pointer to an object of type of_error_msg.
 * @param xid The value to write into the object
 */
void
of_error_msg_xid_set(
    of_error_msg_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ERROR_MSG);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get err_type from an object of type of_error_msg.
 * @param obj Pointer to an object of type of_error_msg.
 * @param err_type Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_error_msg_err_type_get(
    of_error_msg_t *obj,
    uint16_t *err_type)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ERROR_MSG);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, err_type);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set err_type in an object of type of_error_msg.
 * @param obj Pointer to an object of type of_error_msg.
 * @param err_type The value to write into the object
 */
void
of_error_msg_err_type_set(
    of_error_msg_t *obj,
    uint16_t err_type)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ERROR_MSG);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, err_type);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get code from an object of type of_error_msg.
 * @param obj Pointer to an object of type of_error_msg.
 * @param code Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_error_msg_code_get(
    of_error_msg_t *obj,
    uint16_t *code)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ERROR_MSG);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, code);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set code in an object of type of_error_msg.
 * @param obj Pointer to an object of type of_error_msg.
 * @param code The value to write into the object
 */
void
of_error_msg_code_set(
    of_error_msg_t *obj,
    uint16_t code)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ERROR_MSG);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, code);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get data from an object of type of_error_msg.
 * @param obj Pointer to an object of type of_error_msg.
 * @param data Pointer to the child object of type
 * of_octets_t to be filled out.
 *
 */
void
of_error_msg_data_get(
    of_error_msg_t *obj,
    of_octets_t *data)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_ERROR_MSG);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);
    ASSERT(cur_len + abs_offset <= WBUF_CURRENT_BYTES(wbuf));
    data->bytes = cur_len;
    data->data = OF_WIRE_BUFFER_INDEX(wbuf, abs_offset);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set data in an object of type of_error_msg.
 * @param obj Pointer to an object of type of_error_msg.
 * @param data The value to write into the object
 */
int WARN_UNUSED_RESULT
of_error_msg_data_set(
    of_error_msg_t *obj,
    of_octets_t *data)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_ERROR_MSG);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);
    new_len = data->bytes;
    of_wire_buffer_grow(wbuf, abs_offset + (new_len - cur_len));
    of_wire_buffer_octets_data_set(wbuf, abs_offset, data, cur_len);

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_experimenter */
/** \ingroup of_experimenter 
 * @{ */

/**
 * Get xid from an object of type of_experimenter.
 * @param obj Pointer to an object of type of_experimenter.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_experimenter_xid_get(
    of_experimenter_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_EXPERIMENTER);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_experimenter.
 * @param obj Pointer to an object of type of_experimenter.
 * @param xid The value to write into the object
 */
void
of_experimenter_xid_set(
    of_experimenter_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_EXPERIMENTER);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get experimenter from an object of type of_experimenter.
 * @param obj Pointer to an object of type of_experimenter.
 * @param experimenter Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_experimenter_experimenter_get(
    of_experimenter_t *obj,
    uint32_t *experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_EXPERIMENTER);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set experimenter in an object of type of_experimenter.
 * @param obj Pointer to an object of type of_experimenter.
 * @param experimenter The value to write into the object
 */
void
of_experimenter_experimenter_set(
    of_experimenter_t *obj,
    uint32_t experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_EXPERIMENTER);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get subtype from an object of type of_experimenter.
 * @param obj Pointer to an object of type of_experimenter.
 * @param subtype Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_experimenter_subtype_get(
    of_experimenter_t *obj,
    uint32_t *subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_EXPERIMENTER);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set subtype in an object of type of_experimenter.
 * @param obj Pointer to an object of type of_experimenter.
 * @param subtype The value to write into the object
 */
void
of_experimenter_subtype_set(
    of_experimenter_t *obj,
    uint32_t subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_EXPERIMENTER);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get data from an object of type of_experimenter.
 * @param obj Pointer to an object of type of_experimenter.
 * @param data Pointer to the child object of type
 * of_octets_t to be filled out.
 *
 */
void
of_experimenter_data_get(
    of_experimenter_t *obj,
    of_octets_t *data)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_EXPERIMENTER);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);
    ASSERT(cur_len + abs_offset <= WBUF_CURRENT_BYTES(wbuf));
    data->bytes = cur_len;
    data->data = OF_WIRE_BUFFER_INDEX(wbuf, abs_offset);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set data in an object of type of_experimenter.
 * @param obj Pointer to an object of type of_experimenter.
 * @param data The value to write into the object
 */
int WARN_UNUSED_RESULT
of_experimenter_data_set(
    of_experimenter_t *obj,
    of_octets_t *data)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_EXPERIMENTER);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);
    new_len = data->bytes;
    of_wire_buffer_grow(wbuf, abs_offset + (new_len - cur_len));
    of_wire_buffer_octets_data_set(wbuf, abs_offset, data, cur_len);

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_experimenter_stats_reply */
/** \ingroup of_experimenter_stats_reply 
 * @{ */

/**
 * Get xid from an object of type of_experimenter_stats_reply.
 * @param obj Pointer to an object of type of_experimenter_stats_reply.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_experimenter_stats_reply_xid_get(
    of_experimenter_stats_reply_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_EXPERIMENTER_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_experimenter_stats_reply.
 * @param obj Pointer to an object of type of_experimenter_stats_reply.
 * @param xid The value to write into the object
 */
void
of_experimenter_stats_reply_xid_set(
    of_experimenter_stats_reply_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_EXPERIMENTER_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get flags from an object of type of_experimenter_stats_reply.
 * @param obj Pointer to an object of type of_experimenter_stats_reply.
 * @param flags Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_experimenter_stats_reply_flags_get(
    of_experimenter_stats_reply_t *obj,
    uint16_t *flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_EXPERIMENTER_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set flags in an object of type of_experimenter_stats_reply.
 * @param obj Pointer to an object of type of_experimenter_stats_reply.
 * @param flags The value to write into the object
 */
void
of_experimenter_stats_reply_flags_set(
    of_experimenter_stats_reply_t *obj,
    uint16_t flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_EXPERIMENTER_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get experimenter from an object of type of_experimenter_stats_reply.
 * @param obj Pointer to an object of type of_experimenter_stats_reply.
 * @param experimenter Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_experimenter_stats_reply_experimenter_get(
    of_experimenter_stats_reply_t *obj,
    uint32_t *experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_EXPERIMENTER_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set experimenter in an object of type of_experimenter_stats_reply.
 * @param obj Pointer to an object of type of_experimenter_stats_reply.
 * @param experimenter The value to write into the object
 */
void
of_experimenter_stats_reply_experimenter_set(
    of_experimenter_stats_reply_t *obj,
    uint32_t experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_EXPERIMENTER_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get subtype from an object of type of_experimenter_stats_reply.
 * @param obj Pointer to an object of type of_experimenter_stats_reply.
 * @param subtype Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_experimenter_stats_reply_subtype_get(
    of_experimenter_stats_reply_t *obj,
    uint32_t *subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_EXPERIMENTER_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
        offset = 20;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set subtype in an object of type of_experimenter_stats_reply.
 * @param obj Pointer to an object of type of_experimenter_stats_reply.
 * @param subtype The value to write into the object
 */
void
of_experimenter_stats_reply_subtype_set(
    of_experimenter_stats_reply_t *obj,
    uint32_t subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_EXPERIMENTER_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
        offset = 20;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get data from an object of type of_experimenter_stats_reply.
 * @param obj Pointer to an object of type of_experimenter_stats_reply.
 * @param data Pointer to the child object of type
 * of_octets_t to be filled out.
 *
 */
void
of_experimenter_stats_reply_data_get(
    of_experimenter_stats_reply_t *obj,
    of_octets_t *data)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_EXPERIMENTER_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 16;
        cur_len = _END_LEN(obj, offset);
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
        offset = 24;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);
    ASSERT(cur_len + abs_offset <= WBUF_CURRENT_BYTES(wbuf));
    data->bytes = cur_len;
    data->data = OF_WIRE_BUFFER_INDEX(wbuf, abs_offset);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set data in an object of type of_experimenter_stats_reply.
 * @param obj Pointer to an object of type of_experimenter_stats_reply.
 * @param data The value to write into the object
 */
int WARN_UNUSED_RESULT
of_experimenter_stats_reply_data_set(
    of_experimenter_stats_reply_t *obj,
    of_octets_t *data)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_EXPERIMENTER_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 16;
        cur_len = _END_LEN(obj, offset);
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
        offset = 24;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);
    new_len = data->bytes;
    of_wire_buffer_grow(wbuf, abs_offset + (new_len - cur_len));
    of_wire_buffer_octets_data_set(wbuf, abs_offset, data, cur_len);

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_experimenter_stats_request */
/** \ingroup of_experimenter_stats_request 
 * @{ */

/**
 * Get xid from an object of type of_experimenter_stats_request.
 * @param obj Pointer to an object of type of_experimenter_stats_request.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_experimenter_stats_request_xid_get(
    of_experimenter_stats_request_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_EXPERIMENTER_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_experimenter_stats_request.
 * @param obj Pointer to an object of type of_experimenter_stats_request.
 * @param xid The value to write into the object
 */
void
of_experimenter_stats_request_xid_set(
    of_experimenter_stats_request_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_EXPERIMENTER_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get flags from an object of type of_experimenter_stats_request.
 * @param obj Pointer to an object of type of_experimenter_stats_request.
 * @param flags Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_experimenter_stats_request_flags_get(
    of_experimenter_stats_request_t *obj,
    uint16_t *flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_EXPERIMENTER_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set flags in an object of type of_experimenter_stats_request.
 * @param obj Pointer to an object of type of_experimenter_stats_request.
 * @param flags The value to write into the object
 */
void
of_experimenter_stats_request_flags_set(
    of_experimenter_stats_request_t *obj,
    uint16_t flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_EXPERIMENTER_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get experimenter from an object of type of_experimenter_stats_request.
 * @param obj Pointer to an object of type of_experimenter_stats_request.
 * @param experimenter Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_experimenter_stats_request_experimenter_get(
    of_experimenter_stats_request_t *obj,
    uint32_t *experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_EXPERIMENTER_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set experimenter in an object of type of_experimenter_stats_request.
 * @param obj Pointer to an object of type of_experimenter_stats_request.
 * @param experimenter The value to write into the object
 */
void
of_experimenter_stats_request_experimenter_set(
    of_experimenter_stats_request_t *obj,
    uint32_t experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_EXPERIMENTER_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get subtype from an object of type of_experimenter_stats_request.
 * @param obj Pointer to an object of type of_experimenter_stats_request.
 * @param subtype Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_experimenter_stats_request_subtype_get(
    of_experimenter_stats_request_t *obj,
    uint32_t *subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_EXPERIMENTER_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
        offset = 20;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set subtype in an object of type of_experimenter_stats_request.
 * @param obj Pointer to an object of type of_experimenter_stats_request.
 * @param subtype The value to write into the object
 */
void
of_experimenter_stats_request_subtype_set(
    of_experimenter_stats_request_t *obj,
    uint32_t subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_EXPERIMENTER_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
        offset = 20;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get data from an object of type of_experimenter_stats_request.
 * @param obj Pointer to an object of type of_experimenter_stats_request.
 * @param data Pointer to the child object of type
 * of_octets_t to be filled out.
 *
 */
void
of_experimenter_stats_request_data_get(
    of_experimenter_stats_request_t *obj,
    of_octets_t *data)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_EXPERIMENTER_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 16;
        cur_len = _END_LEN(obj, offset);
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
        offset = 24;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);
    ASSERT(cur_len + abs_offset <= WBUF_CURRENT_BYTES(wbuf));
    data->bytes = cur_len;
    data->data = OF_WIRE_BUFFER_INDEX(wbuf, abs_offset);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set data in an object of type of_experimenter_stats_request.
 * @param obj Pointer to an object of type of_experimenter_stats_request.
 * @param data The value to write into the object
 */
int WARN_UNUSED_RESULT
of_experimenter_stats_request_data_set(
    of_experimenter_stats_request_t *obj,
    of_octets_t *data)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_EXPERIMENTER_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 16;
        cur_len = _END_LEN(obj, offset);
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
        offset = 24;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);
    new_len = data->bytes;
    of_wire_buffer_grow(wbuf, abs_offset + (new_len - cur_len));
    of_wire_buffer_octets_data_set(wbuf, abs_offset, data, cur_len);

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_features_reply */
/** \ingroup of_features_reply 
 * @{ */

/**
 * Get xid from an object of type of_features_reply.
 * @param obj Pointer to an object of type of_features_reply.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_features_reply_xid_get(
    of_features_reply_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FEATURES_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_features_reply.
 * @param obj Pointer to an object of type of_features_reply.
 * @param xid The value to write into the object
 */
void
of_features_reply_xid_set(
    of_features_reply_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FEATURES_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get datapath_id from an object of type of_features_reply.
 * @param obj Pointer to an object of type of_features_reply.
 * @param datapath_id Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_features_reply_datapath_id_get(
    of_features_reply_t *obj,
    uint64_t *datapath_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FEATURES_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, datapath_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set datapath_id in an object of type of_features_reply.
 * @param obj Pointer to an object of type of_features_reply.
 * @param datapath_id The value to write into the object
 */
void
of_features_reply_datapath_id_set(
    of_features_reply_t *obj,
    uint64_t datapath_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FEATURES_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, datapath_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get n_buffers from an object of type of_features_reply.
 * @param obj Pointer to an object of type of_features_reply.
 * @param n_buffers Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_features_reply_n_buffers_get(
    of_features_reply_t *obj,
    uint32_t *n_buffers)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FEATURES_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, n_buffers);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set n_buffers in an object of type of_features_reply.
 * @param obj Pointer to an object of type of_features_reply.
 * @param n_buffers The value to write into the object
 */
void
of_features_reply_n_buffers_set(
    of_features_reply_t *obj,
    uint32_t n_buffers)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FEATURES_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, n_buffers);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get n_tables from an object of type of_features_reply.
 * @param obj Pointer to an object of type of_features_reply.
 * @param n_tables Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_features_reply_n_tables_get(
    of_features_reply_t *obj,
    uint8_t *n_tables)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FEATURES_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 20;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, n_tables);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set n_tables in an object of type of_features_reply.
 * @param obj Pointer to an object of type of_features_reply.
 * @param n_tables The value to write into the object
 */
void
of_features_reply_n_tables_set(
    of_features_reply_t *obj,
    uint8_t n_tables)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FEATURES_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 20;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, n_tables);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get auxiliary_id from an object of type of_features_reply.
 * @param obj Pointer to an object of type of_features_reply.
 * @param auxiliary_id Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_features_reply_auxiliary_id_get(
    of_features_reply_t *obj,
    uint8_t *auxiliary_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FEATURES_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 21;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, auxiliary_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set auxiliary_id in an object of type of_features_reply.
 * @param obj Pointer to an object of type of_features_reply.
 * @param auxiliary_id The value to write into the object
 */
void
of_features_reply_auxiliary_id_set(
    of_features_reply_t *obj,
    uint8_t auxiliary_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FEATURES_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 21;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, auxiliary_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get capabilities from an object of type of_features_reply.
 * @param obj Pointer to an object of type of_features_reply.
 * @param capabilities Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_features_reply_capabilities_get(
    of_features_reply_t *obj,
    uint32_t *capabilities)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FEATURES_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 24;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, capabilities);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set capabilities in an object of type of_features_reply.
 * @param obj Pointer to an object of type of_features_reply.
 * @param capabilities The value to write into the object
 */
void
of_features_reply_capabilities_set(
    of_features_reply_t *obj,
    uint32_t capabilities)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FEATURES_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 24;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, capabilities);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get reserved from an object of type of_features_reply.
 * @param obj Pointer to an object of type of_features_reply.
 * @param reserved Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_features_reply_reserved_get(
    of_features_reply_t *obj,
    uint32_t *reserved)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FEATURES_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 28;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, reserved);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set reserved in an object of type of_features_reply.
 * @param obj Pointer to an object of type of_features_reply.
 * @param reserved The value to write into the object
 */
void
of_features_reply_reserved_set(
    of_features_reply_t *obj,
    uint32_t reserved)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FEATURES_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 28;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, reserved);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Bind an object of type of_list_port_desc_t to the parent of type of_features_reply for
 * member ports
 * @param obj Pointer to an object of type of_features_reply.
 * @param ports Pointer to the child object of type
 * of_list_port_desc_t to be filled out.
 * \ingroup of_features_reply
 *
 * The parameter ports is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_features_reply_ports_bind(
    of_features_reply_t *obj,
    of_list_port_desc_t *ports)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_FEATURES_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
        offset = 32;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_port_desc_init(ports, obj->version, 0, 1);
    /* Attach to parent */
    ports->parent = (of_object_t *)obj;
    ports->wire_object.wbuf = obj->wire_object.wbuf;
    ports->wire_object.obj_offset = abs_offset;
    ports->wire_object.owned = 0;
    ports->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of ports into a new variable of type of_list_port_desc_t from
 * a of_features_reply instance.
 *
 * @param obj Pointer to the source of type of_features_reply_t
 * @returns A pointer to a new instance of type of_list_port_desc_t whose contents
 * match that of ports from source
 * @returns NULL if an error occurs
 */
of_list_port_desc_t *
of_features_reply_ports_get(of_features_reply_t *obj) {
    of_list_port_desc_t _ports;
    of_list_port_desc_t *_ports_ptr;

    of_features_reply_ports_bind(obj, &_ports);
    _ports_ptr = (of_list_port_desc_t *)of_object_dup(&_ports);
    return _ports_ptr;
}

/**
 * Set ports in an object of type of_features_reply.
 * @param obj Pointer to an object of type of_features_reply.
 * @param ports Pointer to the child of type of_list_port_desc_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_features_reply_ports_set(
    of_features_reply_t *obj,
    of_list_port_desc_t *ports)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_FEATURES_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
        offset = 32;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = ports->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == ports->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(ports, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(ports, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (ports->wire_length_set != NULL) {
        ports->wire_length_set((of_object_t *)ports, ports->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/**
 * Get actions from an object of type of_features_reply.
 * @param obj Pointer to an object of type of_features_reply.
 * @param actions Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_features_reply_actions_get(
    of_features_reply_t *obj,
    uint32_t *actions)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FEATURES_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 28;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, actions);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set actions in an object of type of_features_reply.
 * @param obj Pointer to an object of type of_features_reply.
 * @param actions The value to write into the object
 */
void
of_features_reply_actions_set(
    of_features_reply_t *obj,
    uint32_t actions)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FEATURES_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 28;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, actions);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_features_request */
/** \ingroup of_features_request 
 * @{ */

/**
 * Get xid from an object of type of_features_request.
 * @param obj Pointer to an object of type of_features_request.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_features_request_xid_get(
    of_features_request_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FEATURES_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_features_request.
 * @param obj Pointer to an object of type of_features_request.
 * @param xid The value to write into the object
 */
void
of_features_request_xid_set(
    of_features_request_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FEATURES_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_flow_add */
/** \ingroup of_flow_add 
 * @{ */

/**
 * Get xid from an object of type of_flow_add.
 * @param obj Pointer to an object of type of_flow_add.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_flow_add_xid_get(
    of_flow_add_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_flow_add.
 * @param obj Pointer to an object of type of_flow_add.
 * @param xid The value to write into the object
 */
void
of_flow_add_xid_set(
    of_flow_add_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get cookie from an object of type of_flow_add.
 * @param obj Pointer to an object of type of_flow_add.
 * @param cookie Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_flow_add_cookie_get(
    of_flow_add_t *obj,
    uint64_t *cookie)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 48;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, cookie);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set cookie in an object of type of_flow_add.
 * @param obj Pointer to an object of type of_flow_add.
 * @param cookie The value to write into the object
 */
void
of_flow_add_cookie_set(
    of_flow_add_t *obj,
    uint64_t cookie)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 48;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, cookie);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get cookie_mask from an object of type of_flow_add.
 * @param obj Pointer to an object of type of_flow_add.
 * @param cookie_mask Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_flow_add_cookie_mask_get(
    of_flow_add_t *obj,
    uint64_t *cookie_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, cookie_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set cookie_mask in an object of type of_flow_add.
 * @param obj Pointer to an object of type of_flow_add.
 * @param cookie_mask The value to write into the object
 */
void
of_flow_add_cookie_mask_set(
    of_flow_add_t *obj,
    uint64_t cookie_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, cookie_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get table_id from an object of type of_flow_add.
 * @param obj Pointer to an object of type of_flow_add.
 * @param table_id Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_flow_add_table_id_get(
    of_flow_add_t *obj,
    uint8_t *table_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 24;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, table_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set table_id in an object of type of_flow_add.
 * @param obj Pointer to an object of type of_flow_add.
 * @param table_id The value to write into the object
 */
void
of_flow_add_table_id_set(
    of_flow_add_t *obj,
    uint8_t table_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 24;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, table_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get idle_timeout from an object of type of_flow_add.
 * @param obj Pointer to an object of type of_flow_add.
 * @param idle_timeout Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_flow_add_idle_timeout_get(
    of_flow_add_t *obj,
    uint16_t *idle_timeout)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 58;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 26;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, idle_timeout);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set idle_timeout in an object of type of_flow_add.
 * @param obj Pointer to an object of type of_flow_add.
 * @param idle_timeout The value to write into the object
 */
void
of_flow_add_idle_timeout_set(
    of_flow_add_t *obj,
    uint16_t idle_timeout)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 58;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 26;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, idle_timeout);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get hard_timeout from an object of type of_flow_add.
 * @param obj Pointer to an object of type of_flow_add.
 * @param hard_timeout Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_flow_add_hard_timeout_get(
    of_flow_add_t *obj,
    uint16_t *hard_timeout)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 60;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 28;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, hard_timeout);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set hard_timeout in an object of type of_flow_add.
 * @param obj Pointer to an object of type of_flow_add.
 * @param hard_timeout The value to write into the object
 */
void
of_flow_add_hard_timeout_set(
    of_flow_add_t *obj,
    uint16_t hard_timeout)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 60;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 28;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, hard_timeout);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get priority from an object of type of_flow_add.
 * @param obj Pointer to an object of type of_flow_add.
 * @param priority Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_flow_add_priority_get(
    of_flow_add_t *obj,
    uint16_t *priority)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 62;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 30;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, priority);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set priority in an object of type of_flow_add.
 * @param obj Pointer to an object of type of_flow_add.
 * @param priority The value to write into the object
 */
void
of_flow_add_priority_set(
    of_flow_add_t *obj,
    uint16_t priority)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 62;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 30;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, priority);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get buffer_id from an object of type of_flow_add.
 * @param obj Pointer to an object of type of_flow_add.
 * @param buffer_id Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_flow_add_buffer_id_get(
    of_flow_add_t *obj,
    uint32_t *buffer_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 64;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 32;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, buffer_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set buffer_id in an object of type of_flow_add.
 * @param obj Pointer to an object of type of_flow_add.
 * @param buffer_id The value to write into the object
 */
void
of_flow_add_buffer_id_set(
    of_flow_add_t *obj,
    uint32_t buffer_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 64;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 32;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, buffer_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get out_port from an object of type of_flow_add.
 * @param obj Pointer to an object of type of_flow_add.
 * @param out_port Pointer to the child object of type
 * of_port_no_t to be filled out.
 *
 */
void
of_flow_add_out_port_get(
    of_flow_add_t *obj,
    of_port_no_t *out_port)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 68;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 36;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_get(ver, wbuf, abs_offset, out_port);
    OF_PORT_NO_VALUE_CHECK(*out_port, ver);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set out_port in an object of type of_flow_add.
 * @param obj Pointer to an object of type of_flow_add.
 * @param out_port The value to write into the object
 */
void
of_flow_add_out_port_set(
    of_flow_add_t *obj,
    of_port_no_t out_port)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 68;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 36;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_set(ver, wbuf, abs_offset, out_port);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get out_group from an object of type of_flow_add.
 * @param obj Pointer to an object of type of_flow_add.
 * @param out_group Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_flow_add_out_group_get(
    of_flow_add_t *obj,
    uint32_t *out_group)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 40;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, out_group);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set out_group in an object of type of_flow_add.
 * @param obj Pointer to an object of type of_flow_add.
 * @param out_group The value to write into the object
 */
void
of_flow_add_out_group_set(
    of_flow_add_t *obj,
    uint32_t out_group)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 40;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, out_group);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get flags from an object of type of_flow_add.
 * @param obj Pointer to an object of type of_flow_add.
 * @param flags Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_flow_add_flags_get(
    of_flow_add_t *obj,
    uint16_t *flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 70;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 44;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set flags in an object of type of_flow_add.
 * @param obj Pointer to an object of type of_flow_add.
 * @param flags The value to write into the object
 */
void
of_flow_add_flags_set(
    of_flow_add_t *obj,
    uint16_t flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 70;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 44;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get match from an object of type of_flow_add.
 * @param obj Pointer to an object of type of_flow_add.
 * @param match Pointer to the child object of type
 * of_match_t to be filled out.
 *
 */
int WARN_UNUSED_RESULT
of_flow_add_match_get(
    of_flow_add_t *obj,
    of_match_t *match)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    of_octets_t match_octets; /* Serialized string for match */

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 8;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    case OF_VERSION_1_1:
        offset = 48;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 48;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    ASSERT(cur_len + abs_offset <= WBUF_CURRENT_BYTES(wbuf));
    match_octets.bytes = cur_len;
    match_octets.data = OF_OBJECT_BUFFER_INDEX(obj, offset);
    OF_TRY(of_match_deserialize(ver, match, &match_octets));

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/**
 * Set match in an object of type of_flow_add.
 * @param obj Pointer to an object of type of_flow_add.
 * @param match Pointer to the child of type of_match_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_flow_add_match_set(
    of_flow_add_t *obj,
    of_match_t *match)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */
    of_octets_t match_octets; /* Serialized string for match */

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 8;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    case OF_VERSION_1_1:
        offset = 48;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 48;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Match object */
    OF_TRY(of_match_serialize(ver, match, &match_octets));
    new_len = match_octets.bytes;
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        match_octets.data, new_len);
    /* Free match serialized octets */
    FREE(match_octets.data);

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/**
 * Bind an object of type of_list_instruction_t to the parent of type of_flow_add for
 * member instructions
 * @param obj Pointer to an object of type of_flow_add.
 * @param instructions Pointer to the child object of type
 * of_list_instruction_t to be filled out.
 * \ingroup of_flow_add
 *
 * The parameter instructions is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_flow_add_instructions_bind(
    of_flow_add_t *obj,
    of_list_instruction_t *instructions)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 136;
        cur_len = _END_LEN(obj, offset);
        break;
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = _FLOW_ADD_INSTRUCTIONS_OFFSET(obj);
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_instruction_init(instructions, obj->version, 0, 1);
    /* Attach to parent */
    instructions->parent = (of_object_t *)obj;
    instructions->wire_object.wbuf = obj->wire_object.wbuf;
    instructions->wire_object.obj_offset = abs_offset;
    instructions->wire_object.owned = 0;
    instructions->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of instructions into a new variable of type of_list_instruction_t from
 * a of_flow_add instance.
 *
 * @param obj Pointer to the source of type of_flow_add_t
 * @returns A pointer to a new instance of type of_list_instruction_t whose contents
 * match that of instructions from source
 * @returns NULL if an error occurs
 */
of_list_instruction_t *
of_flow_add_instructions_get(of_flow_add_t *obj) {
    of_list_instruction_t _instructions;
    of_list_instruction_t *_instructions_ptr;

    of_flow_add_instructions_bind(obj, &_instructions);
    _instructions_ptr = (of_list_instruction_t *)of_object_dup(&_instructions);
    return _instructions_ptr;
}

/**
 * Set instructions in an object of type of_flow_add.
 * @param obj Pointer to an object of type of_flow_add.
 * @param instructions Pointer to the child of type of_list_instruction_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_flow_add_instructions_set(
    of_flow_add_t *obj,
    of_list_instruction_t *instructions)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 136;
        cur_len = _END_LEN(obj, offset);
        break;
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = _FLOW_ADD_INSTRUCTIONS_OFFSET(obj);
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = instructions->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == instructions->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(instructions, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(instructions, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (instructions->wire_length_set != NULL) {
        instructions->wire_length_set((of_object_t *)instructions, instructions->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/**
 * Bind an object of type of_list_action_t to the parent of type of_flow_add for
 * member actions
 * @param obj Pointer to an object of type of_flow_add.
 * @param actions Pointer to the child object of type
 * of_list_action_t to be filled out.
 * \ingroup of_flow_add
 *
 * The parameter actions is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_flow_add_actions_bind(
    of_flow_add_t *obj,
    of_list_action_t *actions)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 72;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_action_init(actions, obj->version, 0, 1);
    /* Attach to parent */
    actions->parent = (of_object_t *)obj;
    actions->wire_object.wbuf = obj->wire_object.wbuf;
    actions->wire_object.obj_offset = abs_offset;
    actions->wire_object.owned = 0;
    actions->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of actions into a new variable of type of_list_action_t from
 * a of_flow_add instance.
 *
 * @param obj Pointer to the source of type of_flow_add_t
 * @returns A pointer to a new instance of type of_list_action_t whose contents
 * match that of actions from source
 * @returns NULL if an error occurs
 */
of_list_action_t *
of_flow_add_actions_get(of_flow_add_t *obj) {
    of_list_action_t _actions;
    of_list_action_t *_actions_ptr;

    of_flow_add_actions_bind(obj, &_actions);
    _actions_ptr = (of_list_action_t *)of_object_dup(&_actions);
    return _actions_ptr;
}

/**
 * Set actions in an object of type of_flow_add.
 * @param obj Pointer to an object of type of_flow_add.
 * @param actions Pointer to the child of type of_list_action_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_flow_add_actions_set(
    of_flow_add_t *obj,
    of_list_action_t *actions)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 72;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = actions->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == actions->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(actions, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(actions, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (actions->wire_length_set != NULL) {
        actions->wire_length_set((of_object_t *)actions, actions->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_flow_delete */
/** \ingroup of_flow_delete 
 * @{ */

/**
 * Get xid from an object of type of_flow_delete.
 * @param obj Pointer to an object of type of_flow_delete.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_flow_delete_xid_get(
    of_flow_delete_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_flow_delete.
 * @param obj Pointer to an object of type of_flow_delete.
 * @param xid The value to write into the object
 */
void
of_flow_delete_xid_set(
    of_flow_delete_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get cookie from an object of type of_flow_delete.
 * @param obj Pointer to an object of type of_flow_delete.
 * @param cookie Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_flow_delete_cookie_get(
    of_flow_delete_t *obj,
    uint64_t *cookie)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 48;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, cookie);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set cookie in an object of type of_flow_delete.
 * @param obj Pointer to an object of type of_flow_delete.
 * @param cookie The value to write into the object
 */
void
of_flow_delete_cookie_set(
    of_flow_delete_t *obj,
    uint64_t cookie)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 48;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, cookie);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get cookie_mask from an object of type of_flow_delete.
 * @param obj Pointer to an object of type of_flow_delete.
 * @param cookie_mask Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_flow_delete_cookie_mask_get(
    of_flow_delete_t *obj,
    uint64_t *cookie_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, cookie_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set cookie_mask in an object of type of_flow_delete.
 * @param obj Pointer to an object of type of_flow_delete.
 * @param cookie_mask The value to write into the object
 */
void
of_flow_delete_cookie_mask_set(
    of_flow_delete_t *obj,
    uint64_t cookie_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, cookie_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get table_id from an object of type of_flow_delete.
 * @param obj Pointer to an object of type of_flow_delete.
 * @param table_id Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_flow_delete_table_id_get(
    of_flow_delete_t *obj,
    uint8_t *table_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 24;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, table_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set table_id in an object of type of_flow_delete.
 * @param obj Pointer to an object of type of_flow_delete.
 * @param table_id The value to write into the object
 */
void
of_flow_delete_table_id_set(
    of_flow_delete_t *obj,
    uint8_t table_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 24;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, table_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get idle_timeout from an object of type of_flow_delete.
 * @param obj Pointer to an object of type of_flow_delete.
 * @param idle_timeout Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_flow_delete_idle_timeout_get(
    of_flow_delete_t *obj,
    uint16_t *idle_timeout)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 58;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 26;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, idle_timeout);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set idle_timeout in an object of type of_flow_delete.
 * @param obj Pointer to an object of type of_flow_delete.
 * @param idle_timeout The value to write into the object
 */
void
of_flow_delete_idle_timeout_set(
    of_flow_delete_t *obj,
    uint16_t idle_timeout)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 58;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 26;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, idle_timeout);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get hard_timeout from an object of type of_flow_delete.
 * @param obj Pointer to an object of type of_flow_delete.
 * @param hard_timeout Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_flow_delete_hard_timeout_get(
    of_flow_delete_t *obj,
    uint16_t *hard_timeout)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 60;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 28;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, hard_timeout);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set hard_timeout in an object of type of_flow_delete.
 * @param obj Pointer to an object of type of_flow_delete.
 * @param hard_timeout The value to write into the object
 */
void
of_flow_delete_hard_timeout_set(
    of_flow_delete_t *obj,
    uint16_t hard_timeout)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 60;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 28;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, hard_timeout);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get priority from an object of type of_flow_delete.
 * @param obj Pointer to an object of type of_flow_delete.
 * @param priority Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_flow_delete_priority_get(
    of_flow_delete_t *obj,
    uint16_t *priority)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 62;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 30;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, priority);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set priority in an object of type of_flow_delete.
 * @param obj Pointer to an object of type of_flow_delete.
 * @param priority The value to write into the object
 */
void
of_flow_delete_priority_set(
    of_flow_delete_t *obj,
    uint16_t priority)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 62;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 30;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, priority);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get buffer_id from an object of type of_flow_delete.
 * @param obj Pointer to an object of type of_flow_delete.
 * @param buffer_id Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_flow_delete_buffer_id_get(
    of_flow_delete_t *obj,
    uint32_t *buffer_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 64;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 32;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, buffer_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set buffer_id in an object of type of_flow_delete.
 * @param obj Pointer to an object of type of_flow_delete.
 * @param buffer_id The value to write into the object
 */
void
of_flow_delete_buffer_id_set(
    of_flow_delete_t *obj,
    uint32_t buffer_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 64;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 32;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, buffer_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get out_port from an object of type of_flow_delete.
 * @param obj Pointer to an object of type of_flow_delete.
 * @param out_port Pointer to the child object of type
 * of_port_no_t to be filled out.
 *
 */
void
of_flow_delete_out_port_get(
    of_flow_delete_t *obj,
    of_port_no_t *out_port)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 68;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 36;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_get(ver, wbuf, abs_offset, out_port);
    OF_PORT_NO_VALUE_CHECK(*out_port, ver);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set out_port in an object of type of_flow_delete.
 * @param obj Pointer to an object of type of_flow_delete.
 * @param out_port The value to write into the object
 */
void
of_flow_delete_out_port_set(
    of_flow_delete_t *obj,
    of_port_no_t out_port)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 68;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 36;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_set(ver, wbuf, abs_offset, out_port);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get out_group from an object of type of_flow_delete.
 * @param obj Pointer to an object of type of_flow_delete.
 * @param out_group Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_flow_delete_out_group_get(
    of_flow_delete_t *obj,
    uint32_t *out_group)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 40;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, out_group);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set out_group in an object of type of_flow_delete.
 * @param obj Pointer to an object of type of_flow_delete.
 * @param out_group The value to write into the object
 */
void
of_flow_delete_out_group_set(
    of_flow_delete_t *obj,
    uint32_t out_group)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 40;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, out_group);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get flags from an object of type of_flow_delete.
 * @param obj Pointer to an object of type of_flow_delete.
 * @param flags Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_flow_delete_flags_get(
    of_flow_delete_t *obj,
    uint16_t *flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 70;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 44;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set flags in an object of type of_flow_delete.
 * @param obj Pointer to an object of type of_flow_delete.
 * @param flags The value to write into the object
 */
void
of_flow_delete_flags_set(
    of_flow_delete_t *obj,
    uint16_t flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 70;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 44;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get match from an object of type of_flow_delete.
 * @param obj Pointer to an object of type of_flow_delete.
 * @param match Pointer to the child object of type
 * of_match_t to be filled out.
 *
 */
int WARN_UNUSED_RESULT
of_flow_delete_match_get(
    of_flow_delete_t *obj,
    of_match_t *match)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    of_octets_t match_octets; /* Serialized string for match */

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 8;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    case OF_VERSION_1_1:
        offset = 48;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 48;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    ASSERT(cur_len + abs_offset <= WBUF_CURRENT_BYTES(wbuf));
    match_octets.bytes = cur_len;
    match_octets.data = OF_OBJECT_BUFFER_INDEX(obj, offset);
    OF_TRY(of_match_deserialize(ver, match, &match_octets));

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/**
 * Set match in an object of type of_flow_delete.
 * @param obj Pointer to an object of type of_flow_delete.
 * @param match Pointer to the child of type of_match_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_flow_delete_match_set(
    of_flow_delete_t *obj,
    of_match_t *match)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */
    of_octets_t match_octets; /* Serialized string for match */

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 8;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    case OF_VERSION_1_1:
        offset = 48;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 48;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Match object */
    OF_TRY(of_match_serialize(ver, match, &match_octets));
    new_len = match_octets.bytes;
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        match_octets.data, new_len);
    /* Free match serialized octets */
    FREE(match_octets.data);

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/**
 * Bind an object of type of_list_instruction_t to the parent of type of_flow_delete for
 * member instructions
 * @param obj Pointer to an object of type of_flow_delete.
 * @param instructions Pointer to the child object of type
 * of_list_instruction_t to be filled out.
 * \ingroup of_flow_delete
 *
 * The parameter instructions is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_flow_delete_instructions_bind(
    of_flow_delete_t *obj,
    of_list_instruction_t *instructions)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 136;
        cur_len = _END_LEN(obj, offset);
        break;
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = _FLOW_DELETE_INSTRUCTIONS_OFFSET(obj);
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_instruction_init(instructions, obj->version, 0, 1);
    /* Attach to parent */
    instructions->parent = (of_object_t *)obj;
    instructions->wire_object.wbuf = obj->wire_object.wbuf;
    instructions->wire_object.obj_offset = abs_offset;
    instructions->wire_object.owned = 0;
    instructions->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of instructions into a new variable of type of_list_instruction_t from
 * a of_flow_delete instance.
 *
 * @param obj Pointer to the source of type of_flow_delete_t
 * @returns A pointer to a new instance of type of_list_instruction_t whose contents
 * match that of instructions from source
 * @returns NULL if an error occurs
 */
of_list_instruction_t *
of_flow_delete_instructions_get(of_flow_delete_t *obj) {
    of_list_instruction_t _instructions;
    of_list_instruction_t *_instructions_ptr;

    of_flow_delete_instructions_bind(obj, &_instructions);
    _instructions_ptr = (of_list_instruction_t *)of_object_dup(&_instructions);
    return _instructions_ptr;
}

/**
 * Set instructions in an object of type of_flow_delete.
 * @param obj Pointer to an object of type of_flow_delete.
 * @param instructions Pointer to the child of type of_list_instruction_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_flow_delete_instructions_set(
    of_flow_delete_t *obj,
    of_list_instruction_t *instructions)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 136;
        cur_len = _END_LEN(obj, offset);
        break;
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = _FLOW_DELETE_INSTRUCTIONS_OFFSET(obj);
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = instructions->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == instructions->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(instructions, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(instructions, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (instructions->wire_length_set != NULL) {
        instructions->wire_length_set((of_object_t *)instructions, instructions->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/**
 * Bind an object of type of_list_action_t to the parent of type of_flow_delete for
 * member actions
 * @param obj Pointer to an object of type of_flow_delete.
 * @param actions Pointer to the child object of type
 * of_list_action_t to be filled out.
 * \ingroup of_flow_delete
 *
 * The parameter actions is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_flow_delete_actions_bind(
    of_flow_delete_t *obj,
    of_list_action_t *actions)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 72;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_action_init(actions, obj->version, 0, 1);
    /* Attach to parent */
    actions->parent = (of_object_t *)obj;
    actions->wire_object.wbuf = obj->wire_object.wbuf;
    actions->wire_object.obj_offset = abs_offset;
    actions->wire_object.owned = 0;
    actions->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of actions into a new variable of type of_list_action_t from
 * a of_flow_delete instance.
 *
 * @param obj Pointer to the source of type of_flow_delete_t
 * @returns A pointer to a new instance of type of_list_action_t whose contents
 * match that of actions from source
 * @returns NULL if an error occurs
 */
of_list_action_t *
of_flow_delete_actions_get(of_flow_delete_t *obj) {
    of_list_action_t _actions;
    of_list_action_t *_actions_ptr;

    of_flow_delete_actions_bind(obj, &_actions);
    _actions_ptr = (of_list_action_t *)of_object_dup(&_actions);
    return _actions_ptr;
}

/**
 * Set actions in an object of type of_flow_delete.
 * @param obj Pointer to an object of type of_flow_delete.
 * @param actions Pointer to the child of type of_list_action_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_flow_delete_actions_set(
    of_flow_delete_t *obj,
    of_list_action_t *actions)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 72;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = actions->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == actions->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(actions, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(actions, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (actions->wire_length_set != NULL) {
        actions->wire_length_set((of_object_t *)actions, actions->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_flow_delete_strict */
/** \ingroup of_flow_delete_strict 
 * @{ */

/**
 * Get xid from an object of type of_flow_delete_strict.
 * @param obj Pointer to an object of type of_flow_delete_strict.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_flow_delete_strict_xid_get(
    of_flow_delete_strict_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_flow_delete_strict.
 * @param obj Pointer to an object of type of_flow_delete_strict.
 * @param xid The value to write into the object
 */
void
of_flow_delete_strict_xid_set(
    of_flow_delete_strict_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get cookie from an object of type of_flow_delete_strict.
 * @param obj Pointer to an object of type of_flow_delete_strict.
 * @param cookie Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_flow_delete_strict_cookie_get(
    of_flow_delete_strict_t *obj,
    uint64_t *cookie)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 48;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, cookie);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set cookie in an object of type of_flow_delete_strict.
 * @param obj Pointer to an object of type of_flow_delete_strict.
 * @param cookie The value to write into the object
 */
void
of_flow_delete_strict_cookie_set(
    of_flow_delete_strict_t *obj,
    uint64_t cookie)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 48;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, cookie);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get cookie_mask from an object of type of_flow_delete_strict.
 * @param obj Pointer to an object of type of_flow_delete_strict.
 * @param cookie_mask Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_flow_delete_strict_cookie_mask_get(
    of_flow_delete_strict_t *obj,
    uint64_t *cookie_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, cookie_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set cookie_mask in an object of type of_flow_delete_strict.
 * @param obj Pointer to an object of type of_flow_delete_strict.
 * @param cookie_mask The value to write into the object
 */
void
of_flow_delete_strict_cookie_mask_set(
    of_flow_delete_strict_t *obj,
    uint64_t cookie_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, cookie_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get table_id from an object of type of_flow_delete_strict.
 * @param obj Pointer to an object of type of_flow_delete_strict.
 * @param table_id Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_flow_delete_strict_table_id_get(
    of_flow_delete_strict_t *obj,
    uint8_t *table_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 24;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, table_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set table_id in an object of type of_flow_delete_strict.
 * @param obj Pointer to an object of type of_flow_delete_strict.
 * @param table_id The value to write into the object
 */
void
of_flow_delete_strict_table_id_set(
    of_flow_delete_strict_t *obj,
    uint8_t table_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 24;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, table_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get idle_timeout from an object of type of_flow_delete_strict.
 * @param obj Pointer to an object of type of_flow_delete_strict.
 * @param idle_timeout Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_flow_delete_strict_idle_timeout_get(
    of_flow_delete_strict_t *obj,
    uint16_t *idle_timeout)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 58;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 26;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, idle_timeout);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set idle_timeout in an object of type of_flow_delete_strict.
 * @param obj Pointer to an object of type of_flow_delete_strict.
 * @param idle_timeout The value to write into the object
 */
void
of_flow_delete_strict_idle_timeout_set(
    of_flow_delete_strict_t *obj,
    uint16_t idle_timeout)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 58;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 26;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, idle_timeout);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get hard_timeout from an object of type of_flow_delete_strict.
 * @param obj Pointer to an object of type of_flow_delete_strict.
 * @param hard_timeout Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_flow_delete_strict_hard_timeout_get(
    of_flow_delete_strict_t *obj,
    uint16_t *hard_timeout)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 60;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 28;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, hard_timeout);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set hard_timeout in an object of type of_flow_delete_strict.
 * @param obj Pointer to an object of type of_flow_delete_strict.
 * @param hard_timeout The value to write into the object
 */
void
of_flow_delete_strict_hard_timeout_set(
    of_flow_delete_strict_t *obj,
    uint16_t hard_timeout)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 60;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 28;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, hard_timeout);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get priority from an object of type of_flow_delete_strict.
 * @param obj Pointer to an object of type of_flow_delete_strict.
 * @param priority Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_flow_delete_strict_priority_get(
    of_flow_delete_strict_t *obj,
    uint16_t *priority)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 62;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 30;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, priority);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set priority in an object of type of_flow_delete_strict.
 * @param obj Pointer to an object of type of_flow_delete_strict.
 * @param priority The value to write into the object
 */
void
of_flow_delete_strict_priority_set(
    of_flow_delete_strict_t *obj,
    uint16_t priority)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 62;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 30;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, priority);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get buffer_id from an object of type of_flow_delete_strict.
 * @param obj Pointer to an object of type of_flow_delete_strict.
 * @param buffer_id Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_flow_delete_strict_buffer_id_get(
    of_flow_delete_strict_t *obj,
    uint32_t *buffer_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 64;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 32;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, buffer_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set buffer_id in an object of type of_flow_delete_strict.
 * @param obj Pointer to an object of type of_flow_delete_strict.
 * @param buffer_id The value to write into the object
 */
void
of_flow_delete_strict_buffer_id_set(
    of_flow_delete_strict_t *obj,
    uint32_t buffer_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 64;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 32;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, buffer_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get out_port from an object of type of_flow_delete_strict.
 * @param obj Pointer to an object of type of_flow_delete_strict.
 * @param out_port Pointer to the child object of type
 * of_port_no_t to be filled out.
 *
 */
void
of_flow_delete_strict_out_port_get(
    of_flow_delete_strict_t *obj,
    of_port_no_t *out_port)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 68;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 36;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_get(ver, wbuf, abs_offset, out_port);
    OF_PORT_NO_VALUE_CHECK(*out_port, ver);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set out_port in an object of type of_flow_delete_strict.
 * @param obj Pointer to an object of type of_flow_delete_strict.
 * @param out_port The value to write into the object
 */
void
of_flow_delete_strict_out_port_set(
    of_flow_delete_strict_t *obj,
    of_port_no_t out_port)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 68;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 36;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_set(ver, wbuf, abs_offset, out_port);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get out_group from an object of type of_flow_delete_strict.
 * @param obj Pointer to an object of type of_flow_delete_strict.
 * @param out_group Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_flow_delete_strict_out_group_get(
    of_flow_delete_strict_t *obj,
    uint32_t *out_group)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 40;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, out_group);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set out_group in an object of type of_flow_delete_strict.
 * @param obj Pointer to an object of type of_flow_delete_strict.
 * @param out_group The value to write into the object
 */
void
of_flow_delete_strict_out_group_set(
    of_flow_delete_strict_t *obj,
    uint32_t out_group)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 40;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, out_group);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get flags from an object of type of_flow_delete_strict.
 * @param obj Pointer to an object of type of_flow_delete_strict.
 * @param flags Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_flow_delete_strict_flags_get(
    of_flow_delete_strict_t *obj,
    uint16_t *flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 70;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 44;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set flags in an object of type of_flow_delete_strict.
 * @param obj Pointer to an object of type of_flow_delete_strict.
 * @param flags The value to write into the object
 */
void
of_flow_delete_strict_flags_set(
    of_flow_delete_strict_t *obj,
    uint16_t flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 70;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 44;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get match from an object of type of_flow_delete_strict.
 * @param obj Pointer to an object of type of_flow_delete_strict.
 * @param match Pointer to the child object of type
 * of_match_t to be filled out.
 *
 */
int WARN_UNUSED_RESULT
of_flow_delete_strict_match_get(
    of_flow_delete_strict_t *obj,
    of_match_t *match)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    of_octets_t match_octets; /* Serialized string for match */

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 8;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    case OF_VERSION_1_1:
        offset = 48;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 48;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    ASSERT(cur_len + abs_offset <= WBUF_CURRENT_BYTES(wbuf));
    match_octets.bytes = cur_len;
    match_octets.data = OF_OBJECT_BUFFER_INDEX(obj, offset);
    OF_TRY(of_match_deserialize(ver, match, &match_octets));

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/**
 * Set match in an object of type of_flow_delete_strict.
 * @param obj Pointer to an object of type of_flow_delete_strict.
 * @param match Pointer to the child of type of_match_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_flow_delete_strict_match_set(
    of_flow_delete_strict_t *obj,
    of_match_t *match)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */
    of_octets_t match_octets; /* Serialized string for match */

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 8;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    case OF_VERSION_1_1:
        offset = 48;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 48;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Match object */
    OF_TRY(of_match_serialize(ver, match, &match_octets));
    new_len = match_octets.bytes;
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        match_octets.data, new_len);
    /* Free match serialized octets */
    FREE(match_octets.data);

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/**
 * Bind an object of type of_list_instruction_t to the parent of type of_flow_delete_strict for
 * member instructions
 * @param obj Pointer to an object of type of_flow_delete_strict.
 * @param instructions Pointer to the child object of type
 * of_list_instruction_t to be filled out.
 * \ingroup of_flow_delete_strict
 *
 * The parameter instructions is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_flow_delete_strict_instructions_bind(
    of_flow_delete_strict_t *obj,
    of_list_instruction_t *instructions)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 136;
        cur_len = _END_LEN(obj, offset);
        break;
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = _FLOW_DELETE_STRICT_INSTRUCTIONS_OFFSET(obj);
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_instruction_init(instructions, obj->version, 0, 1);
    /* Attach to parent */
    instructions->parent = (of_object_t *)obj;
    instructions->wire_object.wbuf = obj->wire_object.wbuf;
    instructions->wire_object.obj_offset = abs_offset;
    instructions->wire_object.owned = 0;
    instructions->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of instructions into a new variable of type of_list_instruction_t from
 * a of_flow_delete_strict instance.
 *
 * @param obj Pointer to the source of type of_flow_delete_strict_t
 * @returns A pointer to a new instance of type of_list_instruction_t whose contents
 * match that of instructions from source
 * @returns NULL if an error occurs
 */
of_list_instruction_t *
of_flow_delete_strict_instructions_get(of_flow_delete_strict_t *obj) {
    of_list_instruction_t _instructions;
    of_list_instruction_t *_instructions_ptr;

    of_flow_delete_strict_instructions_bind(obj, &_instructions);
    _instructions_ptr = (of_list_instruction_t *)of_object_dup(&_instructions);
    return _instructions_ptr;
}

/**
 * Set instructions in an object of type of_flow_delete_strict.
 * @param obj Pointer to an object of type of_flow_delete_strict.
 * @param instructions Pointer to the child of type of_list_instruction_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_flow_delete_strict_instructions_set(
    of_flow_delete_strict_t *obj,
    of_list_instruction_t *instructions)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 136;
        cur_len = _END_LEN(obj, offset);
        break;
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = _FLOW_DELETE_STRICT_INSTRUCTIONS_OFFSET(obj);
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = instructions->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == instructions->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(instructions, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(instructions, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (instructions->wire_length_set != NULL) {
        instructions->wire_length_set((of_object_t *)instructions, instructions->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/**
 * Bind an object of type of_list_action_t to the parent of type of_flow_delete_strict for
 * member actions
 * @param obj Pointer to an object of type of_flow_delete_strict.
 * @param actions Pointer to the child object of type
 * of_list_action_t to be filled out.
 * \ingroup of_flow_delete_strict
 *
 * The parameter actions is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_flow_delete_strict_actions_bind(
    of_flow_delete_strict_t *obj,
    of_list_action_t *actions)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 72;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_action_init(actions, obj->version, 0, 1);
    /* Attach to parent */
    actions->parent = (of_object_t *)obj;
    actions->wire_object.wbuf = obj->wire_object.wbuf;
    actions->wire_object.obj_offset = abs_offset;
    actions->wire_object.owned = 0;
    actions->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of actions into a new variable of type of_list_action_t from
 * a of_flow_delete_strict instance.
 *
 * @param obj Pointer to the source of type of_flow_delete_strict_t
 * @returns A pointer to a new instance of type of_list_action_t whose contents
 * match that of actions from source
 * @returns NULL if an error occurs
 */
of_list_action_t *
of_flow_delete_strict_actions_get(of_flow_delete_strict_t *obj) {
    of_list_action_t _actions;
    of_list_action_t *_actions_ptr;

    of_flow_delete_strict_actions_bind(obj, &_actions);
    _actions_ptr = (of_list_action_t *)of_object_dup(&_actions);
    return _actions_ptr;
}

/**
 * Set actions in an object of type of_flow_delete_strict.
 * @param obj Pointer to an object of type of_flow_delete_strict.
 * @param actions Pointer to the child of type of_list_action_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_flow_delete_strict_actions_set(
    of_flow_delete_strict_t *obj,
    of_list_action_t *actions)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 72;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = actions->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == actions->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(actions, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(actions, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (actions->wire_length_set != NULL) {
        actions->wire_length_set((of_object_t *)actions, actions->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_flow_modify */
/** \ingroup of_flow_modify 
 * @{ */

/**
 * Get xid from an object of type of_flow_modify.
 * @param obj Pointer to an object of type of_flow_modify.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_flow_modify_xid_get(
    of_flow_modify_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_flow_modify.
 * @param obj Pointer to an object of type of_flow_modify.
 * @param xid The value to write into the object
 */
void
of_flow_modify_xid_set(
    of_flow_modify_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get cookie from an object of type of_flow_modify.
 * @param obj Pointer to an object of type of_flow_modify.
 * @param cookie Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_flow_modify_cookie_get(
    of_flow_modify_t *obj,
    uint64_t *cookie)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 48;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, cookie);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set cookie in an object of type of_flow_modify.
 * @param obj Pointer to an object of type of_flow_modify.
 * @param cookie The value to write into the object
 */
void
of_flow_modify_cookie_set(
    of_flow_modify_t *obj,
    uint64_t cookie)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 48;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, cookie);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get cookie_mask from an object of type of_flow_modify.
 * @param obj Pointer to an object of type of_flow_modify.
 * @param cookie_mask Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_flow_modify_cookie_mask_get(
    of_flow_modify_t *obj,
    uint64_t *cookie_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, cookie_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set cookie_mask in an object of type of_flow_modify.
 * @param obj Pointer to an object of type of_flow_modify.
 * @param cookie_mask The value to write into the object
 */
void
of_flow_modify_cookie_mask_set(
    of_flow_modify_t *obj,
    uint64_t cookie_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, cookie_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get table_id from an object of type of_flow_modify.
 * @param obj Pointer to an object of type of_flow_modify.
 * @param table_id Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_flow_modify_table_id_get(
    of_flow_modify_t *obj,
    uint8_t *table_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 24;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, table_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set table_id in an object of type of_flow_modify.
 * @param obj Pointer to an object of type of_flow_modify.
 * @param table_id The value to write into the object
 */
void
of_flow_modify_table_id_set(
    of_flow_modify_t *obj,
    uint8_t table_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 24;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, table_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get idle_timeout from an object of type of_flow_modify.
 * @param obj Pointer to an object of type of_flow_modify.
 * @param idle_timeout Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_flow_modify_idle_timeout_get(
    of_flow_modify_t *obj,
    uint16_t *idle_timeout)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 58;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 26;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, idle_timeout);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set idle_timeout in an object of type of_flow_modify.
 * @param obj Pointer to an object of type of_flow_modify.
 * @param idle_timeout The value to write into the object
 */
void
of_flow_modify_idle_timeout_set(
    of_flow_modify_t *obj,
    uint16_t idle_timeout)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 58;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 26;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, idle_timeout);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get hard_timeout from an object of type of_flow_modify.
 * @param obj Pointer to an object of type of_flow_modify.
 * @param hard_timeout Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_flow_modify_hard_timeout_get(
    of_flow_modify_t *obj,
    uint16_t *hard_timeout)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 60;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 28;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, hard_timeout);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set hard_timeout in an object of type of_flow_modify.
 * @param obj Pointer to an object of type of_flow_modify.
 * @param hard_timeout The value to write into the object
 */
void
of_flow_modify_hard_timeout_set(
    of_flow_modify_t *obj,
    uint16_t hard_timeout)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 60;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 28;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, hard_timeout);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get priority from an object of type of_flow_modify.
 * @param obj Pointer to an object of type of_flow_modify.
 * @param priority Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_flow_modify_priority_get(
    of_flow_modify_t *obj,
    uint16_t *priority)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 62;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 30;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, priority);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set priority in an object of type of_flow_modify.
 * @param obj Pointer to an object of type of_flow_modify.
 * @param priority The value to write into the object
 */
void
of_flow_modify_priority_set(
    of_flow_modify_t *obj,
    uint16_t priority)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 62;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 30;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, priority);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get buffer_id from an object of type of_flow_modify.
 * @param obj Pointer to an object of type of_flow_modify.
 * @param buffer_id Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_flow_modify_buffer_id_get(
    of_flow_modify_t *obj,
    uint32_t *buffer_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 64;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 32;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, buffer_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set buffer_id in an object of type of_flow_modify.
 * @param obj Pointer to an object of type of_flow_modify.
 * @param buffer_id The value to write into the object
 */
void
of_flow_modify_buffer_id_set(
    of_flow_modify_t *obj,
    uint32_t buffer_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 64;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 32;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, buffer_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get out_port from an object of type of_flow_modify.
 * @param obj Pointer to an object of type of_flow_modify.
 * @param out_port Pointer to the child object of type
 * of_port_no_t to be filled out.
 *
 */
void
of_flow_modify_out_port_get(
    of_flow_modify_t *obj,
    of_port_no_t *out_port)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 68;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 36;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_get(ver, wbuf, abs_offset, out_port);
    OF_PORT_NO_VALUE_CHECK(*out_port, ver);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set out_port in an object of type of_flow_modify.
 * @param obj Pointer to an object of type of_flow_modify.
 * @param out_port The value to write into the object
 */
void
of_flow_modify_out_port_set(
    of_flow_modify_t *obj,
    of_port_no_t out_port)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 68;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 36;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_set(ver, wbuf, abs_offset, out_port);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get out_group from an object of type of_flow_modify.
 * @param obj Pointer to an object of type of_flow_modify.
 * @param out_group Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_flow_modify_out_group_get(
    of_flow_modify_t *obj,
    uint32_t *out_group)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 40;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, out_group);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set out_group in an object of type of_flow_modify.
 * @param obj Pointer to an object of type of_flow_modify.
 * @param out_group The value to write into the object
 */
void
of_flow_modify_out_group_set(
    of_flow_modify_t *obj,
    uint32_t out_group)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 40;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, out_group);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get flags from an object of type of_flow_modify.
 * @param obj Pointer to an object of type of_flow_modify.
 * @param flags Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_flow_modify_flags_get(
    of_flow_modify_t *obj,
    uint16_t *flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 70;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 44;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set flags in an object of type of_flow_modify.
 * @param obj Pointer to an object of type of_flow_modify.
 * @param flags The value to write into the object
 */
void
of_flow_modify_flags_set(
    of_flow_modify_t *obj,
    uint16_t flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 70;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 44;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get match from an object of type of_flow_modify.
 * @param obj Pointer to an object of type of_flow_modify.
 * @param match Pointer to the child object of type
 * of_match_t to be filled out.
 *
 */
int WARN_UNUSED_RESULT
of_flow_modify_match_get(
    of_flow_modify_t *obj,
    of_match_t *match)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    of_octets_t match_octets; /* Serialized string for match */

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 8;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    case OF_VERSION_1_1:
        offset = 48;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 48;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    ASSERT(cur_len + abs_offset <= WBUF_CURRENT_BYTES(wbuf));
    match_octets.bytes = cur_len;
    match_octets.data = OF_OBJECT_BUFFER_INDEX(obj, offset);
    OF_TRY(of_match_deserialize(ver, match, &match_octets));

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/**
 * Set match in an object of type of_flow_modify.
 * @param obj Pointer to an object of type of_flow_modify.
 * @param match Pointer to the child of type of_match_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_flow_modify_match_set(
    of_flow_modify_t *obj,
    of_match_t *match)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */
    of_octets_t match_octets; /* Serialized string for match */

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 8;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    case OF_VERSION_1_1:
        offset = 48;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 48;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Match object */
    OF_TRY(of_match_serialize(ver, match, &match_octets));
    new_len = match_octets.bytes;
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        match_octets.data, new_len);
    /* Free match serialized octets */
    FREE(match_octets.data);

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/**
 * Bind an object of type of_list_instruction_t to the parent of type of_flow_modify for
 * member instructions
 * @param obj Pointer to an object of type of_flow_modify.
 * @param instructions Pointer to the child object of type
 * of_list_instruction_t to be filled out.
 * \ingroup of_flow_modify
 *
 * The parameter instructions is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_flow_modify_instructions_bind(
    of_flow_modify_t *obj,
    of_list_instruction_t *instructions)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 136;
        cur_len = _END_LEN(obj, offset);
        break;
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = _FLOW_MODIFY_INSTRUCTIONS_OFFSET(obj);
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_instruction_init(instructions, obj->version, 0, 1);
    /* Attach to parent */
    instructions->parent = (of_object_t *)obj;
    instructions->wire_object.wbuf = obj->wire_object.wbuf;
    instructions->wire_object.obj_offset = abs_offset;
    instructions->wire_object.owned = 0;
    instructions->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of instructions into a new variable of type of_list_instruction_t from
 * a of_flow_modify instance.
 *
 * @param obj Pointer to the source of type of_flow_modify_t
 * @returns A pointer to a new instance of type of_list_instruction_t whose contents
 * match that of instructions from source
 * @returns NULL if an error occurs
 */
of_list_instruction_t *
of_flow_modify_instructions_get(of_flow_modify_t *obj) {
    of_list_instruction_t _instructions;
    of_list_instruction_t *_instructions_ptr;

    of_flow_modify_instructions_bind(obj, &_instructions);
    _instructions_ptr = (of_list_instruction_t *)of_object_dup(&_instructions);
    return _instructions_ptr;
}

/**
 * Set instructions in an object of type of_flow_modify.
 * @param obj Pointer to an object of type of_flow_modify.
 * @param instructions Pointer to the child of type of_list_instruction_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_flow_modify_instructions_set(
    of_flow_modify_t *obj,
    of_list_instruction_t *instructions)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 136;
        cur_len = _END_LEN(obj, offset);
        break;
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = _FLOW_MODIFY_INSTRUCTIONS_OFFSET(obj);
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = instructions->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == instructions->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(instructions, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(instructions, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (instructions->wire_length_set != NULL) {
        instructions->wire_length_set((of_object_t *)instructions, instructions->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/**
 * Bind an object of type of_list_action_t to the parent of type of_flow_modify for
 * member actions
 * @param obj Pointer to an object of type of_flow_modify.
 * @param actions Pointer to the child object of type
 * of_list_action_t to be filled out.
 * \ingroup of_flow_modify
 *
 * The parameter actions is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_flow_modify_actions_bind(
    of_flow_modify_t *obj,
    of_list_action_t *actions)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 72;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_action_init(actions, obj->version, 0, 1);
    /* Attach to parent */
    actions->parent = (of_object_t *)obj;
    actions->wire_object.wbuf = obj->wire_object.wbuf;
    actions->wire_object.obj_offset = abs_offset;
    actions->wire_object.owned = 0;
    actions->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of actions into a new variable of type of_list_action_t from
 * a of_flow_modify instance.
 *
 * @param obj Pointer to the source of type of_flow_modify_t
 * @returns A pointer to a new instance of type of_list_action_t whose contents
 * match that of actions from source
 * @returns NULL if an error occurs
 */
of_list_action_t *
of_flow_modify_actions_get(of_flow_modify_t *obj) {
    of_list_action_t _actions;
    of_list_action_t *_actions_ptr;

    of_flow_modify_actions_bind(obj, &_actions);
    _actions_ptr = (of_list_action_t *)of_object_dup(&_actions);
    return _actions_ptr;
}

/**
 * Set actions in an object of type of_flow_modify.
 * @param obj Pointer to an object of type of_flow_modify.
 * @param actions Pointer to the child of type of_list_action_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_flow_modify_actions_set(
    of_flow_modify_t *obj,
    of_list_action_t *actions)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 72;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = actions->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == actions->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(actions, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(actions, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (actions->wire_length_set != NULL) {
        actions->wire_length_set((of_object_t *)actions, actions->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_flow_modify_strict */
/** \ingroup of_flow_modify_strict 
 * @{ */

/**
 * Get xid from an object of type of_flow_modify_strict.
 * @param obj Pointer to an object of type of_flow_modify_strict.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_flow_modify_strict_xid_get(
    of_flow_modify_strict_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_flow_modify_strict.
 * @param obj Pointer to an object of type of_flow_modify_strict.
 * @param xid The value to write into the object
 */
void
of_flow_modify_strict_xid_set(
    of_flow_modify_strict_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get cookie from an object of type of_flow_modify_strict.
 * @param obj Pointer to an object of type of_flow_modify_strict.
 * @param cookie Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_flow_modify_strict_cookie_get(
    of_flow_modify_strict_t *obj,
    uint64_t *cookie)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 48;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, cookie);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set cookie in an object of type of_flow_modify_strict.
 * @param obj Pointer to an object of type of_flow_modify_strict.
 * @param cookie The value to write into the object
 */
void
of_flow_modify_strict_cookie_set(
    of_flow_modify_strict_t *obj,
    uint64_t cookie)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 48;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, cookie);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get cookie_mask from an object of type of_flow_modify_strict.
 * @param obj Pointer to an object of type of_flow_modify_strict.
 * @param cookie_mask Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_flow_modify_strict_cookie_mask_get(
    of_flow_modify_strict_t *obj,
    uint64_t *cookie_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, cookie_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set cookie_mask in an object of type of_flow_modify_strict.
 * @param obj Pointer to an object of type of_flow_modify_strict.
 * @param cookie_mask The value to write into the object
 */
void
of_flow_modify_strict_cookie_mask_set(
    of_flow_modify_strict_t *obj,
    uint64_t cookie_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, cookie_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get table_id from an object of type of_flow_modify_strict.
 * @param obj Pointer to an object of type of_flow_modify_strict.
 * @param table_id Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_flow_modify_strict_table_id_get(
    of_flow_modify_strict_t *obj,
    uint8_t *table_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 24;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, table_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set table_id in an object of type of_flow_modify_strict.
 * @param obj Pointer to an object of type of_flow_modify_strict.
 * @param table_id The value to write into the object
 */
void
of_flow_modify_strict_table_id_set(
    of_flow_modify_strict_t *obj,
    uint8_t table_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 24;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, table_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get idle_timeout from an object of type of_flow_modify_strict.
 * @param obj Pointer to an object of type of_flow_modify_strict.
 * @param idle_timeout Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_flow_modify_strict_idle_timeout_get(
    of_flow_modify_strict_t *obj,
    uint16_t *idle_timeout)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 58;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 26;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, idle_timeout);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set idle_timeout in an object of type of_flow_modify_strict.
 * @param obj Pointer to an object of type of_flow_modify_strict.
 * @param idle_timeout The value to write into the object
 */
void
of_flow_modify_strict_idle_timeout_set(
    of_flow_modify_strict_t *obj,
    uint16_t idle_timeout)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 58;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 26;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, idle_timeout);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get hard_timeout from an object of type of_flow_modify_strict.
 * @param obj Pointer to an object of type of_flow_modify_strict.
 * @param hard_timeout Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_flow_modify_strict_hard_timeout_get(
    of_flow_modify_strict_t *obj,
    uint16_t *hard_timeout)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 60;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 28;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, hard_timeout);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set hard_timeout in an object of type of_flow_modify_strict.
 * @param obj Pointer to an object of type of_flow_modify_strict.
 * @param hard_timeout The value to write into the object
 */
void
of_flow_modify_strict_hard_timeout_set(
    of_flow_modify_strict_t *obj,
    uint16_t hard_timeout)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 60;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 28;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, hard_timeout);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get priority from an object of type of_flow_modify_strict.
 * @param obj Pointer to an object of type of_flow_modify_strict.
 * @param priority Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_flow_modify_strict_priority_get(
    of_flow_modify_strict_t *obj,
    uint16_t *priority)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 62;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 30;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, priority);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set priority in an object of type of_flow_modify_strict.
 * @param obj Pointer to an object of type of_flow_modify_strict.
 * @param priority The value to write into the object
 */
void
of_flow_modify_strict_priority_set(
    of_flow_modify_strict_t *obj,
    uint16_t priority)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 62;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 30;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, priority);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get buffer_id from an object of type of_flow_modify_strict.
 * @param obj Pointer to an object of type of_flow_modify_strict.
 * @param buffer_id Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_flow_modify_strict_buffer_id_get(
    of_flow_modify_strict_t *obj,
    uint32_t *buffer_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 64;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 32;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, buffer_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set buffer_id in an object of type of_flow_modify_strict.
 * @param obj Pointer to an object of type of_flow_modify_strict.
 * @param buffer_id The value to write into the object
 */
void
of_flow_modify_strict_buffer_id_set(
    of_flow_modify_strict_t *obj,
    uint32_t buffer_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 64;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 32;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, buffer_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get out_port from an object of type of_flow_modify_strict.
 * @param obj Pointer to an object of type of_flow_modify_strict.
 * @param out_port Pointer to the child object of type
 * of_port_no_t to be filled out.
 *
 */
void
of_flow_modify_strict_out_port_get(
    of_flow_modify_strict_t *obj,
    of_port_no_t *out_port)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 68;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 36;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_get(ver, wbuf, abs_offset, out_port);
    OF_PORT_NO_VALUE_CHECK(*out_port, ver);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set out_port in an object of type of_flow_modify_strict.
 * @param obj Pointer to an object of type of_flow_modify_strict.
 * @param out_port The value to write into the object
 */
void
of_flow_modify_strict_out_port_set(
    of_flow_modify_strict_t *obj,
    of_port_no_t out_port)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 68;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 36;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_set(ver, wbuf, abs_offset, out_port);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get out_group from an object of type of_flow_modify_strict.
 * @param obj Pointer to an object of type of_flow_modify_strict.
 * @param out_group Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_flow_modify_strict_out_group_get(
    of_flow_modify_strict_t *obj,
    uint32_t *out_group)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 40;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, out_group);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set out_group in an object of type of_flow_modify_strict.
 * @param obj Pointer to an object of type of_flow_modify_strict.
 * @param out_group The value to write into the object
 */
void
of_flow_modify_strict_out_group_set(
    of_flow_modify_strict_t *obj,
    uint32_t out_group)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 40;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, out_group);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get flags from an object of type of_flow_modify_strict.
 * @param obj Pointer to an object of type of_flow_modify_strict.
 * @param flags Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_flow_modify_strict_flags_get(
    of_flow_modify_strict_t *obj,
    uint16_t *flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 70;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 44;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set flags in an object of type of_flow_modify_strict.
 * @param obj Pointer to an object of type of_flow_modify_strict.
 * @param flags The value to write into the object
 */
void
of_flow_modify_strict_flags_set(
    of_flow_modify_strict_t *obj,
    uint16_t flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 70;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 44;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get match from an object of type of_flow_modify_strict.
 * @param obj Pointer to an object of type of_flow_modify_strict.
 * @param match Pointer to the child object of type
 * of_match_t to be filled out.
 *
 */
int WARN_UNUSED_RESULT
of_flow_modify_strict_match_get(
    of_flow_modify_strict_t *obj,
    of_match_t *match)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    of_octets_t match_octets; /* Serialized string for match */

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 8;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    case OF_VERSION_1_1:
        offset = 48;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 48;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    ASSERT(cur_len + abs_offset <= WBUF_CURRENT_BYTES(wbuf));
    match_octets.bytes = cur_len;
    match_octets.data = OF_OBJECT_BUFFER_INDEX(obj, offset);
    OF_TRY(of_match_deserialize(ver, match, &match_octets));

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/**
 * Set match in an object of type of_flow_modify_strict.
 * @param obj Pointer to an object of type of_flow_modify_strict.
 * @param match Pointer to the child of type of_match_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_flow_modify_strict_match_set(
    of_flow_modify_strict_t *obj,
    of_match_t *match)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */
    of_octets_t match_octets; /* Serialized string for match */

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 8;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    case OF_VERSION_1_1:
        offset = 48;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 48;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Match object */
    OF_TRY(of_match_serialize(ver, match, &match_octets));
    new_len = match_octets.bytes;
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        match_octets.data, new_len);
    /* Free match serialized octets */
    FREE(match_octets.data);

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/**
 * Bind an object of type of_list_instruction_t to the parent of type of_flow_modify_strict for
 * member instructions
 * @param obj Pointer to an object of type of_flow_modify_strict.
 * @param instructions Pointer to the child object of type
 * of_list_instruction_t to be filled out.
 * \ingroup of_flow_modify_strict
 *
 * The parameter instructions is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_flow_modify_strict_instructions_bind(
    of_flow_modify_strict_t *obj,
    of_list_instruction_t *instructions)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 136;
        cur_len = _END_LEN(obj, offset);
        break;
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = _FLOW_MODIFY_STRICT_INSTRUCTIONS_OFFSET(obj);
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_instruction_init(instructions, obj->version, 0, 1);
    /* Attach to parent */
    instructions->parent = (of_object_t *)obj;
    instructions->wire_object.wbuf = obj->wire_object.wbuf;
    instructions->wire_object.obj_offset = abs_offset;
    instructions->wire_object.owned = 0;
    instructions->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of instructions into a new variable of type of_list_instruction_t from
 * a of_flow_modify_strict instance.
 *
 * @param obj Pointer to the source of type of_flow_modify_strict_t
 * @returns A pointer to a new instance of type of_list_instruction_t whose contents
 * match that of instructions from source
 * @returns NULL if an error occurs
 */
of_list_instruction_t *
of_flow_modify_strict_instructions_get(of_flow_modify_strict_t *obj) {
    of_list_instruction_t _instructions;
    of_list_instruction_t *_instructions_ptr;

    of_flow_modify_strict_instructions_bind(obj, &_instructions);
    _instructions_ptr = (of_list_instruction_t *)of_object_dup(&_instructions);
    return _instructions_ptr;
}

/**
 * Set instructions in an object of type of_flow_modify_strict.
 * @param obj Pointer to an object of type of_flow_modify_strict.
 * @param instructions Pointer to the child of type of_list_instruction_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_flow_modify_strict_instructions_set(
    of_flow_modify_strict_t *obj,
    of_list_instruction_t *instructions)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 136;
        cur_len = _END_LEN(obj, offset);
        break;
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = _FLOW_MODIFY_STRICT_INSTRUCTIONS_OFFSET(obj);
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = instructions->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == instructions->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(instructions, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(instructions, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (instructions->wire_length_set != NULL) {
        instructions->wire_length_set((of_object_t *)instructions, instructions->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/**
 * Bind an object of type of_list_action_t to the parent of type of_flow_modify_strict for
 * member actions
 * @param obj Pointer to an object of type of_flow_modify_strict.
 * @param actions Pointer to the child object of type
 * of_list_action_t to be filled out.
 * \ingroup of_flow_modify_strict
 *
 * The parameter actions is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_flow_modify_strict_actions_bind(
    of_flow_modify_strict_t *obj,
    of_list_action_t *actions)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 72;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_action_init(actions, obj->version, 0, 1);
    /* Attach to parent */
    actions->parent = (of_object_t *)obj;
    actions->wire_object.wbuf = obj->wire_object.wbuf;
    actions->wire_object.obj_offset = abs_offset;
    actions->wire_object.owned = 0;
    actions->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of actions into a new variable of type of_list_action_t from
 * a of_flow_modify_strict instance.
 *
 * @param obj Pointer to the source of type of_flow_modify_strict_t
 * @returns A pointer to a new instance of type of_list_action_t whose contents
 * match that of actions from source
 * @returns NULL if an error occurs
 */
of_list_action_t *
of_flow_modify_strict_actions_get(of_flow_modify_strict_t *obj) {
    of_list_action_t _actions;
    of_list_action_t *_actions_ptr;

    of_flow_modify_strict_actions_bind(obj, &_actions);
    _actions_ptr = (of_list_action_t *)of_object_dup(&_actions);
    return _actions_ptr;
}

/**
 * Set actions in an object of type of_flow_modify_strict.
 * @param obj Pointer to an object of type of_flow_modify_strict.
 * @param actions Pointer to the child of type of_list_action_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_flow_modify_strict_actions_set(
    of_flow_modify_strict_t *obj,
    of_list_action_t *actions)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(IS_FLOW_MOD_SUBTYPE(obj->object_id));
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 72;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = actions->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == actions->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(actions, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(actions, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (actions->wire_length_set != NULL) {
        actions->wire_length_set((of_object_t *)actions, actions->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_flow_removed */
/** \ingroup of_flow_removed 
 * @{ */

/**
 * Get xid from an object of type of_flow_removed.
 * @param obj Pointer to an object of type of_flow_removed.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_flow_removed_xid_get(
    of_flow_removed_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_REMOVED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_flow_removed.
 * @param obj Pointer to an object of type of_flow_removed.
 * @param xid The value to write into the object
 */
void
of_flow_removed_xid_set(
    of_flow_removed_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_REMOVED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get cookie from an object of type of_flow_removed.
 * @param obj Pointer to an object of type of_flow_removed.
 * @param cookie Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_flow_removed_cookie_get(
    of_flow_removed_t *obj,
    uint64_t *cookie)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_REMOVED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 48;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, cookie);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set cookie in an object of type of_flow_removed.
 * @param obj Pointer to an object of type of_flow_removed.
 * @param cookie The value to write into the object
 */
void
of_flow_removed_cookie_set(
    of_flow_removed_t *obj,
    uint64_t cookie)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_REMOVED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 48;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, cookie);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get priority from an object of type of_flow_removed.
 * @param obj Pointer to an object of type of_flow_removed.
 * @param priority Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_flow_removed_priority_get(
    of_flow_removed_t *obj,
    uint16_t *priority)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_REMOVED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 56;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, priority);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set priority in an object of type of_flow_removed.
 * @param obj Pointer to an object of type of_flow_removed.
 * @param priority The value to write into the object
 */
void
of_flow_removed_priority_set(
    of_flow_removed_t *obj,
    uint16_t priority)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_REMOVED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 56;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, priority);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get reason from an object of type of_flow_removed.
 * @param obj Pointer to an object of type of_flow_removed.
 * @param reason Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_flow_removed_reason_get(
    of_flow_removed_t *obj,
    uint8_t *reason)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_REMOVED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 58;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 18;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, reason);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set reason in an object of type of_flow_removed.
 * @param obj Pointer to an object of type of_flow_removed.
 * @param reason The value to write into the object
 */
void
of_flow_removed_reason_set(
    of_flow_removed_t *obj,
    uint8_t reason)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_REMOVED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 58;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 18;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, reason);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get table_id from an object of type of_flow_removed.
 * @param obj Pointer to an object of type of_flow_removed.
 * @param table_id Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_flow_removed_table_id_get(
    of_flow_removed_t *obj,
    uint8_t *table_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_REMOVED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 19;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, table_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set table_id in an object of type of_flow_removed.
 * @param obj Pointer to an object of type of_flow_removed.
 * @param table_id The value to write into the object
 */
void
of_flow_removed_table_id_set(
    of_flow_removed_t *obj,
    uint8_t table_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_REMOVED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 19;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, table_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get duration_sec from an object of type of_flow_removed.
 * @param obj Pointer to an object of type of_flow_removed.
 * @param duration_sec Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_flow_removed_duration_sec_get(
    of_flow_removed_t *obj,
    uint32_t *duration_sec)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_REMOVED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 60;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 20;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, duration_sec);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set duration_sec in an object of type of_flow_removed.
 * @param obj Pointer to an object of type of_flow_removed.
 * @param duration_sec The value to write into the object
 */
void
of_flow_removed_duration_sec_set(
    of_flow_removed_t *obj,
    uint32_t duration_sec)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_REMOVED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 60;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 20;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, duration_sec);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get duration_nsec from an object of type of_flow_removed.
 * @param obj Pointer to an object of type of_flow_removed.
 * @param duration_nsec Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_flow_removed_duration_nsec_get(
    of_flow_removed_t *obj,
    uint32_t *duration_nsec)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_REMOVED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 64;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 24;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, duration_nsec);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set duration_nsec in an object of type of_flow_removed.
 * @param obj Pointer to an object of type of_flow_removed.
 * @param duration_nsec The value to write into the object
 */
void
of_flow_removed_duration_nsec_set(
    of_flow_removed_t *obj,
    uint32_t duration_nsec)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_REMOVED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 64;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 24;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, duration_nsec);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get idle_timeout from an object of type of_flow_removed.
 * @param obj Pointer to an object of type of_flow_removed.
 * @param idle_timeout Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_flow_removed_idle_timeout_get(
    of_flow_removed_t *obj,
    uint16_t *idle_timeout)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_REMOVED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 68;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 28;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, idle_timeout);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set idle_timeout in an object of type of_flow_removed.
 * @param obj Pointer to an object of type of_flow_removed.
 * @param idle_timeout The value to write into the object
 */
void
of_flow_removed_idle_timeout_set(
    of_flow_removed_t *obj,
    uint16_t idle_timeout)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_REMOVED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 68;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 28;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, idle_timeout);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get hard_timeout from an object of type of_flow_removed.
 * @param obj Pointer to an object of type of_flow_removed.
 * @param hard_timeout Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_flow_removed_hard_timeout_get(
    of_flow_removed_t *obj,
    uint16_t *hard_timeout)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_REMOVED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 30;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, hard_timeout);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set hard_timeout in an object of type of_flow_removed.
 * @param obj Pointer to an object of type of_flow_removed.
 * @param hard_timeout The value to write into the object
 */
void
of_flow_removed_hard_timeout_set(
    of_flow_removed_t *obj,
    uint16_t hard_timeout)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_REMOVED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 30;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, hard_timeout);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get packet_count from an object of type of_flow_removed.
 * @param obj Pointer to an object of type of_flow_removed.
 * @param packet_count Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_flow_removed_packet_count_get(
    of_flow_removed_t *obj,
    uint64_t *packet_count)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_REMOVED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 72;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 32;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, packet_count);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set packet_count in an object of type of_flow_removed.
 * @param obj Pointer to an object of type of_flow_removed.
 * @param packet_count The value to write into the object
 */
void
of_flow_removed_packet_count_set(
    of_flow_removed_t *obj,
    uint64_t packet_count)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_REMOVED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 72;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 32;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, packet_count);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get byte_count from an object of type of_flow_removed.
 * @param obj Pointer to an object of type of_flow_removed.
 * @param byte_count Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_flow_removed_byte_count_get(
    of_flow_removed_t *obj,
    uint64_t *byte_count)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_REMOVED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 80;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 40;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, byte_count);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set byte_count in an object of type of_flow_removed.
 * @param obj Pointer to an object of type of_flow_removed.
 * @param byte_count The value to write into the object
 */
void
of_flow_removed_byte_count_set(
    of_flow_removed_t *obj,
    uint64_t byte_count)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_REMOVED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 80;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 40;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, byte_count);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get match from an object of type of_flow_removed.
 * @param obj Pointer to an object of type of_flow_removed.
 * @param match Pointer to the child object of type
 * of_match_t to be filled out.
 *
 */
int WARN_UNUSED_RESULT
of_flow_removed_match_get(
    of_flow_removed_t *obj,
    of_match_t *match)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    of_octets_t match_octets; /* Serialized string for match */

    ASSERT(obj->object_id == OF_FLOW_REMOVED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 8;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    case OF_VERSION_1_1:
        offset = 48;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 48;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    ASSERT(cur_len + abs_offset <= WBUF_CURRENT_BYTES(wbuf));
    match_octets.bytes = cur_len;
    match_octets.data = OF_OBJECT_BUFFER_INDEX(obj, offset);
    OF_TRY(of_match_deserialize(ver, match, &match_octets));

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/**
 * Set match in an object of type of_flow_removed.
 * @param obj Pointer to an object of type of_flow_removed.
 * @param match Pointer to the child of type of_match_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_flow_removed_match_set(
    of_flow_removed_t *obj,
    of_match_t *match)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */
    of_octets_t match_octets; /* Serialized string for match */

    ASSERT(obj->object_id == OF_FLOW_REMOVED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 8;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    case OF_VERSION_1_1:
        offset = 48;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 48;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Match object */
    OF_TRY(of_match_serialize(ver, match, &match_octets));
    new_len = match_octets.bytes;
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        match_octets.data, new_len);
    /* Free match serialized octets */
    FREE(match_octets.data);

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_flow_stats_reply */
/** \ingroup of_flow_stats_reply 
 * @{ */

/**
 * Get xid from an object of type of_flow_stats_reply.
 * @param obj Pointer to an object of type of_flow_stats_reply.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_flow_stats_reply_xid_get(
    of_flow_stats_reply_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_flow_stats_reply.
 * @param obj Pointer to an object of type of_flow_stats_reply.
 * @param xid The value to write into the object
 */
void
of_flow_stats_reply_xid_set(
    of_flow_stats_reply_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get flags from an object of type of_flow_stats_reply.
 * @param obj Pointer to an object of type of_flow_stats_reply.
 * @param flags Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_flow_stats_reply_flags_get(
    of_flow_stats_reply_t *obj,
    uint16_t *flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set flags in an object of type of_flow_stats_reply.
 * @param obj Pointer to an object of type of_flow_stats_reply.
 * @param flags The value to write into the object
 */
void
of_flow_stats_reply_flags_set(
    of_flow_stats_reply_t *obj,
    uint16_t flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Bind an object of type of_list_flow_stats_entry_t to the parent of type of_flow_stats_reply for
 * member entries
 * @param obj Pointer to an object of type of_flow_stats_reply.
 * @param entries Pointer to the child object of type
 * of_list_flow_stats_entry_t to be filled out.
 * \ingroup of_flow_stats_reply
 *
 * The parameter entries is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_flow_stats_reply_entries_bind(
    of_flow_stats_reply_t *obj,
    of_list_flow_stats_entry_t *entries)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_FLOW_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        cur_len = _END_LEN(obj, offset);
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_flow_stats_entry_init(entries, obj->version, 0, 1);
    /* Attach to parent */
    entries->parent = (of_object_t *)obj;
    entries->wire_object.wbuf = obj->wire_object.wbuf;
    entries->wire_object.obj_offset = abs_offset;
    entries->wire_object.owned = 0;
    entries->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of entries into a new variable of type of_list_flow_stats_entry_t from
 * a of_flow_stats_reply instance.
 *
 * @param obj Pointer to the source of type of_flow_stats_reply_t
 * @returns A pointer to a new instance of type of_list_flow_stats_entry_t whose contents
 * match that of entries from source
 * @returns NULL if an error occurs
 */
of_list_flow_stats_entry_t *
of_flow_stats_reply_entries_get(of_flow_stats_reply_t *obj) {
    of_list_flow_stats_entry_t _entries;
    of_list_flow_stats_entry_t *_entries_ptr;

    of_flow_stats_reply_entries_bind(obj, &_entries);
    _entries_ptr = (of_list_flow_stats_entry_t *)of_object_dup(&_entries);
    return _entries_ptr;
}

/**
 * Set entries in an object of type of_flow_stats_reply.
 * @param obj Pointer to an object of type of_flow_stats_reply.
 * @param entries Pointer to the child of type of_list_flow_stats_entry_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_flow_stats_reply_entries_set(
    of_flow_stats_reply_t *obj,
    of_list_flow_stats_entry_t *entries)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_FLOW_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        cur_len = _END_LEN(obj, offset);
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = entries->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == entries->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(entries, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(entries, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (entries->wire_length_set != NULL) {
        entries->wire_length_set((of_object_t *)entries, entries->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_flow_stats_request */
/** \ingroup of_flow_stats_request 
 * @{ */

/**
 * Get xid from an object of type of_flow_stats_request.
 * @param obj Pointer to an object of type of_flow_stats_request.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_flow_stats_request_xid_get(
    of_flow_stats_request_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_flow_stats_request.
 * @param obj Pointer to an object of type of_flow_stats_request.
 * @param xid The value to write into the object
 */
void
of_flow_stats_request_xid_set(
    of_flow_stats_request_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get flags from an object of type of_flow_stats_request.
 * @param obj Pointer to an object of type of_flow_stats_request.
 * @param flags Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_flow_stats_request_flags_get(
    of_flow_stats_request_t *obj,
    uint16_t *flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set flags in an object of type of_flow_stats_request.
 * @param obj Pointer to an object of type of_flow_stats_request.
 * @param flags The value to write into the object
 */
void
of_flow_stats_request_flags_set(
    of_flow_stats_request_t *obj,
    uint16_t flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get table_id from an object of type of_flow_stats_request.
 * @param obj Pointer to an object of type of_flow_stats_request.
 * @param table_id Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_flow_stats_request_table_id_get(
    of_flow_stats_request_t *obj,
    uint8_t *table_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 52;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, table_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set table_id in an object of type of_flow_stats_request.
 * @param obj Pointer to an object of type of_flow_stats_request.
 * @param table_id The value to write into the object
 */
void
of_flow_stats_request_table_id_set(
    of_flow_stats_request_t *obj,
    uint8_t table_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 52;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, table_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get out_port from an object of type of_flow_stats_request.
 * @param obj Pointer to an object of type of_flow_stats_request.
 * @param out_port Pointer to the child object of type
 * of_port_no_t to be filled out.
 *
 */
void
of_flow_stats_request_out_port_get(
    of_flow_stats_request_t *obj,
    of_port_no_t *out_port)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 54;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 20;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_get(ver, wbuf, abs_offset, out_port);
    OF_PORT_NO_VALUE_CHECK(*out_port, ver);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set out_port in an object of type of_flow_stats_request.
 * @param obj Pointer to an object of type of_flow_stats_request.
 * @param out_port The value to write into the object
 */
void
of_flow_stats_request_out_port_set(
    of_flow_stats_request_t *obj,
    of_port_no_t out_port)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 54;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 20;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_set(ver, wbuf, abs_offset, out_port);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get out_group from an object of type of_flow_stats_request.
 * @param obj Pointer to an object of type of_flow_stats_request.
 * @param out_group Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_flow_stats_request_out_group_get(
    of_flow_stats_request_t *obj,
    uint32_t *out_group)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 24;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, out_group);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set out_group in an object of type of_flow_stats_request.
 * @param obj Pointer to an object of type of_flow_stats_request.
 * @param out_group The value to write into the object
 */
void
of_flow_stats_request_out_group_set(
    of_flow_stats_request_t *obj,
    uint32_t out_group)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 24;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, out_group);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get cookie from an object of type of_flow_stats_request.
 * @param obj Pointer to an object of type of_flow_stats_request.
 * @param cookie Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_flow_stats_request_cookie_get(
    of_flow_stats_request_t *obj,
    uint64_t *cookie)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 32;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, cookie);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set cookie in an object of type of_flow_stats_request.
 * @param obj Pointer to an object of type of_flow_stats_request.
 * @param cookie The value to write into the object
 */
void
of_flow_stats_request_cookie_set(
    of_flow_stats_request_t *obj,
    uint64_t cookie)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 32;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, cookie);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get cookie_mask from an object of type of_flow_stats_request.
 * @param obj Pointer to an object of type of_flow_stats_request.
 * @param cookie_mask Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_flow_stats_request_cookie_mask_get(
    of_flow_stats_request_t *obj,
    uint64_t *cookie_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 40;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, cookie_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set cookie_mask in an object of type of_flow_stats_request.
 * @param obj Pointer to an object of type of_flow_stats_request.
 * @param cookie_mask The value to write into the object
 */
void
of_flow_stats_request_cookie_mask_set(
    of_flow_stats_request_t *obj,
    uint64_t cookie_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 40;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, cookie_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get match from an object of type of_flow_stats_request.
 * @param obj Pointer to an object of type of_flow_stats_request.
 * @param match Pointer to the child object of type
 * of_match_t to be filled out.
 *
 */
int WARN_UNUSED_RESULT
of_flow_stats_request_match_get(
    of_flow_stats_request_t *obj,
    of_match_t *match)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    of_octets_t match_octets; /* Serialized string for match */

    ASSERT(obj->object_id == OF_FLOW_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    case OF_VERSION_1_1:
        offset = 48;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 48;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    ASSERT(cur_len + abs_offset <= WBUF_CURRENT_BYTES(wbuf));
    match_octets.bytes = cur_len;
    match_octets.data = OF_OBJECT_BUFFER_INDEX(obj, offset);
    OF_TRY(of_match_deserialize(ver, match, &match_octets));

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/**
 * Set match in an object of type of_flow_stats_request.
 * @param obj Pointer to an object of type of_flow_stats_request.
 * @param match Pointer to the child of type of_match_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_flow_stats_request_match_set(
    of_flow_stats_request_t *obj,
    of_match_t *match)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */
    of_octets_t match_octets; /* Serialized string for match */

    ASSERT(obj->object_id == OF_FLOW_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    case OF_VERSION_1_1:
        offset = 48;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 48;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Match object */
    OF_TRY(of_match_serialize(ver, match, &match_octets));
    new_len = match_octets.bytes;
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        match_octets.data, new_len);
    /* Free match serialized octets */
    FREE(match_octets.data);

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_get_config_reply */
/** \ingroup of_get_config_reply 
 * @{ */

/**
 * Get xid from an object of type of_get_config_reply.
 * @param obj Pointer to an object of type of_get_config_reply.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_get_config_reply_xid_get(
    of_get_config_reply_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GET_CONFIG_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_get_config_reply.
 * @param obj Pointer to an object of type of_get_config_reply.
 * @param xid The value to write into the object
 */
void
of_get_config_reply_xid_set(
    of_get_config_reply_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GET_CONFIG_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get flags from an object of type of_get_config_reply.
 * @param obj Pointer to an object of type of_get_config_reply.
 * @param flags Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_get_config_reply_flags_get(
    of_get_config_reply_t *obj,
    uint16_t *flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GET_CONFIG_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set flags in an object of type of_get_config_reply.
 * @param obj Pointer to an object of type of_get_config_reply.
 * @param flags The value to write into the object
 */
void
of_get_config_reply_flags_set(
    of_get_config_reply_t *obj,
    uint16_t flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GET_CONFIG_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get miss_send_len from an object of type of_get_config_reply.
 * @param obj Pointer to an object of type of_get_config_reply.
 * @param miss_send_len Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_get_config_reply_miss_send_len_get(
    of_get_config_reply_t *obj,
    uint16_t *miss_send_len)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GET_CONFIG_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, miss_send_len);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set miss_send_len in an object of type of_get_config_reply.
 * @param obj Pointer to an object of type of_get_config_reply.
 * @param miss_send_len The value to write into the object
 */
void
of_get_config_reply_miss_send_len_set(
    of_get_config_reply_t *obj,
    uint16_t miss_send_len)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GET_CONFIG_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, miss_send_len);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_get_config_request */
/** \ingroup of_get_config_request 
 * @{ */

/**
 * Get xid from an object of type of_get_config_request.
 * @param obj Pointer to an object of type of_get_config_request.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_get_config_request_xid_get(
    of_get_config_request_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GET_CONFIG_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_get_config_request.
 * @param obj Pointer to an object of type of_get_config_request.
 * @param xid The value to write into the object
 */
void
of_get_config_request_xid_set(
    of_get_config_request_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GET_CONFIG_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_group_desc_stats_reply */
/** \ingroup of_group_desc_stats_reply 
 * @{ */

/**
 * Get xid from an object of type of_group_desc_stats_reply.
 * @param obj Pointer to an object of type of_group_desc_stats_reply.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_group_desc_stats_reply_xid_get(
    of_group_desc_stats_reply_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_DESC_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_group_desc_stats_reply.
 * @param obj Pointer to an object of type of_group_desc_stats_reply.
 * @param xid The value to write into the object
 */
void
of_group_desc_stats_reply_xid_set(
    of_group_desc_stats_reply_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_DESC_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get flags from an object of type of_group_desc_stats_reply.
 * @param obj Pointer to an object of type of_group_desc_stats_reply.
 * @param flags Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_group_desc_stats_reply_flags_get(
    of_group_desc_stats_reply_t *obj,
    uint16_t *flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_DESC_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set flags in an object of type of_group_desc_stats_reply.
 * @param obj Pointer to an object of type of_group_desc_stats_reply.
 * @param flags The value to write into the object
 */
void
of_group_desc_stats_reply_flags_set(
    of_group_desc_stats_reply_t *obj,
    uint16_t flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_DESC_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Bind an object of type of_list_group_desc_stats_entry_t to the parent of type of_group_desc_stats_reply for
 * member entries
 * @param obj Pointer to an object of type of_group_desc_stats_reply.
 * @param entries Pointer to the child object of type
 * of_list_group_desc_stats_entry_t to be filled out.
 * \ingroup of_group_desc_stats_reply
 *
 * The parameter entries is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_group_desc_stats_reply_entries_bind(
    of_group_desc_stats_reply_t *obj,
    of_list_group_desc_stats_entry_t *entries)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_GROUP_DESC_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_group_desc_stats_entry_init(entries, obj->version, 0, 1);
    /* Attach to parent */
    entries->parent = (of_object_t *)obj;
    entries->wire_object.wbuf = obj->wire_object.wbuf;
    entries->wire_object.obj_offset = abs_offset;
    entries->wire_object.owned = 0;
    entries->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of entries into a new variable of type of_list_group_desc_stats_entry_t from
 * a of_group_desc_stats_reply instance.
 *
 * @param obj Pointer to the source of type of_group_desc_stats_reply_t
 * @returns A pointer to a new instance of type of_list_group_desc_stats_entry_t whose contents
 * match that of entries from source
 * @returns NULL if an error occurs
 */
of_list_group_desc_stats_entry_t *
of_group_desc_stats_reply_entries_get(of_group_desc_stats_reply_t *obj) {
    of_list_group_desc_stats_entry_t _entries;
    of_list_group_desc_stats_entry_t *_entries_ptr;

    of_group_desc_stats_reply_entries_bind(obj, &_entries);
    _entries_ptr = (of_list_group_desc_stats_entry_t *)of_object_dup(&_entries);
    return _entries_ptr;
}

/**
 * Set entries in an object of type of_group_desc_stats_reply.
 * @param obj Pointer to an object of type of_group_desc_stats_reply.
 * @param entries Pointer to the child of type of_list_group_desc_stats_entry_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_group_desc_stats_reply_entries_set(
    of_group_desc_stats_reply_t *obj,
    of_list_group_desc_stats_entry_t *entries)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_GROUP_DESC_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = entries->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == entries->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(entries, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(entries, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (entries->wire_length_set != NULL) {
        entries->wire_length_set((of_object_t *)entries, entries->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_group_desc_stats_request */
/** \ingroup of_group_desc_stats_request 
 * @{ */

/**
 * Get xid from an object of type of_group_desc_stats_request.
 * @param obj Pointer to an object of type of_group_desc_stats_request.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_group_desc_stats_request_xid_get(
    of_group_desc_stats_request_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_DESC_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_group_desc_stats_request.
 * @param obj Pointer to an object of type of_group_desc_stats_request.
 * @param xid The value to write into the object
 */
void
of_group_desc_stats_request_xid_set(
    of_group_desc_stats_request_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_DESC_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get flags from an object of type of_group_desc_stats_request.
 * @param obj Pointer to an object of type of_group_desc_stats_request.
 * @param flags Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_group_desc_stats_request_flags_get(
    of_group_desc_stats_request_t *obj,
    uint16_t *flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_DESC_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set flags in an object of type of_group_desc_stats_request.
 * @param obj Pointer to an object of type of_group_desc_stats_request.
 * @param flags The value to write into the object
 */
void
of_group_desc_stats_request_flags_set(
    of_group_desc_stats_request_t *obj,
    uint16_t flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_DESC_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_group_features_stats_reply */
/** \ingroup of_group_features_stats_reply 
 * @{ */

/**
 * Get xid from an object of type of_group_features_stats_reply.
 * @param obj Pointer to an object of type of_group_features_stats_reply.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_group_features_stats_reply_xid_get(
    of_group_features_stats_reply_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_FEATURES_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_group_features_stats_reply.
 * @param obj Pointer to an object of type of_group_features_stats_reply.
 * @param xid The value to write into the object
 */
void
of_group_features_stats_reply_xid_set(
    of_group_features_stats_reply_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_FEATURES_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get flags from an object of type of_group_features_stats_reply.
 * @param obj Pointer to an object of type of_group_features_stats_reply.
 * @param flags Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_group_features_stats_reply_flags_get(
    of_group_features_stats_reply_t *obj,
    uint16_t *flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_FEATURES_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set flags in an object of type of_group_features_stats_reply.
 * @param obj Pointer to an object of type of_group_features_stats_reply.
 * @param flags The value to write into the object
 */
void
of_group_features_stats_reply_flags_set(
    of_group_features_stats_reply_t *obj,
    uint16_t flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_FEATURES_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get types from an object of type of_group_features_stats_reply.
 * @param obj Pointer to an object of type of_group_features_stats_reply.
 * @param types Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_group_features_stats_reply_types_get(
    of_group_features_stats_reply_t *obj,
    uint32_t *types)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_FEATURES_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, types);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set types in an object of type of_group_features_stats_reply.
 * @param obj Pointer to an object of type of_group_features_stats_reply.
 * @param types The value to write into the object
 */
void
of_group_features_stats_reply_types_set(
    of_group_features_stats_reply_t *obj,
    uint32_t types)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_FEATURES_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, types);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get capabilities from an object of type of_group_features_stats_reply.
 * @param obj Pointer to an object of type of_group_features_stats_reply.
 * @param capabilities Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_group_features_stats_reply_capabilities_get(
    of_group_features_stats_reply_t *obj,
    uint32_t *capabilities)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_FEATURES_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 20;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, capabilities);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set capabilities in an object of type of_group_features_stats_reply.
 * @param obj Pointer to an object of type of_group_features_stats_reply.
 * @param capabilities The value to write into the object
 */
void
of_group_features_stats_reply_capabilities_set(
    of_group_features_stats_reply_t *obj,
    uint32_t capabilities)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_FEATURES_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 20;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, capabilities);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get max_groups_all from an object of type of_group_features_stats_reply.
 * @param obj Pointer to an object of type of_group_features_stats_reply.
 * @param max_groups_all Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_group_features_stats_reply_max_groups_all_get(
    of_group_features_stats_reply_t *obj,
    uint32_t *max_groups_all)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_FEATURES_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 24;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, max_groups_all);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set max_groups_all in an object of type of_group_features_stats_reply.
 * @param obj Pointer to an object of type of_group_features_stats_reply.
 * @param max_groups_all The value to write into the object
 */
void
of_group_features_stats_reply_max_groups_all_set(
    of_group_features_stats_reply_t *obj,
    uint32_t max_groups_all)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_FEATURES_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 24;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, max_groups_all);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get max_groups_select from an object of type of_group_features_stats_reply.
 * @param obj Pointer to an object of type of_group_features_stats_reply.
 * @param max_groups_select Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_group_features_stats_reply_max_groups_select_get(
    of_group_features_stats_reply_t *obj,
    uint32_t *max_groups_select)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_FEATURES_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 28;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, max_groups_select);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set max_groups_select in an object of type of_group_features_stats_reply.
 * @param obj Pointer to an object of type of_group_features_stats_reply.
 * @param max_groups_select The value to write into the object
 */
void
of_group_features_stats_reply_max_groups_select_set(
    of_group_features_stats_reply_t *obj,
    uint32_t max_groups_select)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_FEATURES_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 28;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, max_groups_select);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get max_groups_indirect from an object of type of_group_features_stats_reply.
 * @param obj Pointer to an object of type of_group_features_stats_reply.
 * @param max_groups_indirect Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_group_features_stats_reply_max_groups_indirect_get(
    of_group_features_stats_reply_t *obj,
    uint32_t *max_groups_indirect)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_FEATURES_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 32;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, max_groups_indirect);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set max_groups_indirect in an object of type of_group_features_stats_reply.
 * @param obj Pointer to an object of type of_group_features_stats_reply.
 * @param max_groups_indirect The value to write into the object
 */
void
of_group_features_stats_reply_max_groups_indirect_set(
    of_group_features_stats_reply_t *obj,
    uint32_t max_groups_indirect)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_FEATURES_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 32;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, max_groups_indirect);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get max_groups_ff from an object of type of_group_features_stats_reply.
 * @param obj Pointer to an object of type of_group_features_stats_reply.
 * @param max_groups_ff Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_group_features_stats_reply_max_groups_ff_get(
    of_group_features_stats_reply_t *obj,
    uint32_t *max_groups_ff)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_FEATURES_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 36;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, max_groups_ff);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set max_groups_ff in an object of type of_group_features_stats_reply.
 * @param obj Pointer to an object of type of_group_features_stats_reply.
 * @param max_groups_ff The value to write into the object
 */
void
of_group_features_stats_reply_max_groups_ff_set(
    of_group_features_stats_reply_t *obj,
    uint32_t max_groups_ff)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_FEATURES_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 36;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, max_groups_ff);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get actions_all from an object of type of_group_features_stats_reply.
 * @param obj Pointer to an object of type of_group_features_stats_reply.
 * @param actions_all Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_group_features_stats_reply_actions_all_get(
    of_group_features_stats_reply_t *obj,
    uint32_t *actions_all)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_FEATURES_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 40;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, actions_all);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set actions_all in an object of type of_group_features_stats_reply.
 * @param obj Pointer to an object of type of_group_features_stats_reply.
 * @param actions_all The value to write into the object
 */
void
of_group_features_stats_reply_actions_all_set(
    of_group_features_stats_reply_t *obj,
    uint32_t actions_all)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_FEATURES_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 40;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, actions_all);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get actions_select from an object of type of_group_features_stats_reply.
 * @param obj Pointer to an object of type of_group_features_stats_reply.
 * @param actions_select Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_group_features_stats_reply_actions_select_get(
    of_group_features_stats_reply_t *obj,
    uint32_t *actions_select)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_FEATURES_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 44;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, actions_select);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set actions_select in an object of type of_group_features_stats_reply.
 * @param obj Pointer to an object of type of_group_features_stats_reply.
 * @param actions_select The value to write into the object
 */
void
of_group_features_stats_reply_actions_select_set(
    of_group_features_stats_reply_t *obj,
    uint32_t actions_select)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_FEATURES_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 44;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, actions_select);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get actions_indirect from an object of type of_group_features_stats_reply.
 * @param obj Pointer to an object of type of_group_features_stats_reply.
 * @param actions_indirect Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_group_features_stats_reply_actions_indirect_get(
    of_group_features_stats_reply_t *obj,
    uint32_t *actions_indirect)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_FEATURES_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 48;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, actions_indirect);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set actions_indirect in an object of type of_group_features_stats_reply.
 * @param obj Pointer to an object of type of_group_features_stats_reply.
 * @param actions_indirect The value to write into the object
 */
void
of_group_features_stats_reply_actions_indirect_set(
    of_group_features_stats_reply_t *obj,
    uint32_t actions_indirect)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_FEATURES_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 48;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, actions_indirect);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get actions_ff from an object of type of_group_features_stats_reply.
 * @param obj Pointer to an object of type of_group_features_stats_reply.
 * @param actions_ff Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_group_features_stats_reply_actions_ff_get(
    of_group_features_stats_reply_t *obj,
    uint32_t *actions_ff)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_FEATURES_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 52;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, actions_ff);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set actions_ff in an object of type of_group_features_stats_reply.
 * @param obj Pointer to an object of type of_group_features_stats_reply.
 * @param actions_ff The value to write into the object
 */
void
of_group_features_stats_reply_actions_ff_set(
    of_group_features_stats_reply_t *obj,
    uint32_t actions_ff)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_FEATURES_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 52;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, actions_ff);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_group_features_stats_request */
/** \ingroup of_group_features_stats_request 
 * @{ */

/**
 * Get xid from an object of type of_group_features_stats_request.
 * @param obj Pointer to an object of type of_group_features_stats_request.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_group_features_stats_request_xid_get(
    of_group_features_stats_request_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_FEATURES_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_group_features_stats_request.
 * @param obj Pointer to an object of type of_group_features_stats_request.
 * @param xid The value to write into the object
 */
void
of_group_features_stats_request_xid_set(
    of_group_features_stats_request_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_FEATURES_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get flags from an object of type of_group_features_stats_request.
 * @param obj Pointer to an object of type of_group_features_stats_request.
 * @param flags Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_group_features_stats_request_flags_get(
    of_group_features_stats_request_t *obj,
    uint16_t *flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_FEATURES_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set flags in an object of type of_group_features_stats_request.
 * @param obj Pointer to an object of type of_group_features_stats_request.
 * @param flags The value to write into the object
 */
void
of_group_features_stats_request_flags_set(
    of_group_features_stats_request_t *obj,
    uint16_t flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_FEATURES_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_group_mod */
/** \ingroup of_group_mod 
 * @{ */

/**
 * Get xid from an object of type of_group_mod.
 * @param obj Pointer to an object of type of_group_mod.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_group_mod_xid_get(
    of_group_mod_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_MOD);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_group_mod.
 * @param obj Pointer to an object of type of_group_mod.
 * @param xid The value to write into the object
 */
void
of_group_mod_xid_set(
    of_group_mod_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_MOD);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get command from an object of type of_group_mod.
 * @param obj Pointer to an object of type of_group_mod.
 * @param command Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_group_mod_command_get(
    of_group_mod_t *obj,
    uint16_t *command)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_MOD);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, command);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set command in an object of type of_group_mod.
 * @param obj Pointer to an object of type of_group_mod.
 * @param command The value to write into the object
 */
void
of_group_mod_command_set(
    of_group_mod_t *obj,
    uint16_t command)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_MOD);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, command);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get group_type from an object of type of_group_mod.
 * @param obj Pointer to an object of type of_group_mod.
 * @param group_type Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_group_mod_group_type_get(
    of_group_mod_t *obj,
    uint8_t *group_type)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_MOD);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, group_type);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set group_type in an object of type of_group_mod.
 * @param obj Pointer to an object of type of_group_mod.
 * @param group_type The value to write into the object
 */
void
of_group_mod_group_type_set(
    of_group_mod_t *obj,
    uint8_t group_type)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_MOD);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, group_type);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get group_id from an object of type of_group_mod.
 * @param obj Pointer to an object of type of_group_mod.
 * @param group_id Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_group_mod_group_id_get(
    of_group_mod_t *obj,
    uint32_t *group_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_MOD);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, group_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set group_id in an object of type of_group_mod.
 * @param obj Pointer to an object of type of_group_mod.
 * @param group_id The value to write into the object
 */
void
of_group_mod_group_id_set(
    of_group_mod_t *obj,
    uint32_t group_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_MOD);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, group_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Bind an object of type of_list_bucket_t to the parent of type of_group_mod for
 * member buckets
 * @param obj Pointer to an object of type of_group_mod.
 * @param buckets Pointer to the child object of type
 * of_list_bucket_t to be filled out.
 * \ingroup of_group_mod
 *
 * The parameter buckets is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_group_mod_buckets_bind(
    of_group_mod_t *obj,
    of_list_bucket_t *buckets)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_GROUP_MOD);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_bucket_init(buckets, obj->version, 0, 1);
    /* Attach to parent */
    buckets->parent = (of_object_t *)obj;
    buckets->wire_object.wbuf = obj->wire_object.wbuf;
    buckets->wire_object.obj_offset = abs_offset;
    buckets->wire_object.owned = 0;
    buckets->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of buckets into a new variable of type of_list_bucket_t from
 * a of_group_mod instance.
 *
 * @param obj Pointer to the source of type of_group_mod_t
 * @returns A pointer to a new instance of type of_list_bucket_t whose contents
 * match that of buckets from source
 * @returns NULL if an error occurs
 */
of_list_bucket_t *
of_group_mod_buckets_get(of_group_mod_t *obj) {
    of_list_bucket_t _buckets;
    of_list_bucket_t *_buckets_ptr;

    of_group_mod_buckets_bind(obj, &_buckets);
    _buckets_ptr = (of_list_bucket_t *)of_object_dup(&_buckets);
    return _buckets_ptr;
}

/**
 * Set buckets in an object of type of_group_mod.
 * @param obj Pointer to an object of type of_group_mod.
 * @param buckets Pointer to the child of type of_list_bucket_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_group_mod_buckets_set(
    of_group_mod_t *obj,
    of_list_bucket_t *buckets)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_GROUP_MOD);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = buckets->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == buckets->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(buckets, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(buckets, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (buckets->wire_length_set != NULL) {
        buckets->wire_length_set((of_object_t *)buckets, buckets->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_group_stats_reply */
/** \ingroup of_group_stats_reply 
 * @{ */

/**
 * Get xid from an object of type of_group_stats_reply.
 * @param obj Pointer to an object of type of_group_stats_reply.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_group_stats_reply_xid_get(
    of_group_stats_reply_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_group_stats_reply.
 * @param obj Pointer to an object of type of_group_stats_reply.
 * @param xid The value to write into the object
 */
void
of_group_stats_reply_xid_set(
    of_group_stats_reply_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get flags from an object of type of_group_stats_reply.
 * @param obj Pointer to an object of type of_group_stats_reply.
 * @param flags Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_group_stats_reply_flags_get(
    of_group_stats_reply_t *obj,
    uint16_t *flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set flags in an object of type of_group_stats_reply.
 * @param obj Pointer to an object of type of_group_stats_reply.
 * @param flags The value to write into the object
 */
void
of_group_stats_reply_flags_set(
    of_group_stats_reply_t *obj,
    uint16_t flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Bind an object of type of_list_group_stats_entry_t to the parent of type of_group_stats_reply for
 * member entries
 * @param obj Pointer to an object of type of_group_stats_reply.
 * @param entries Pointer to the child object of type
 * of_list_group_stats_entry_t to be filled out.
 * \ingroup of_group_stats_reply
 *
 * The parameter entries is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_group_stats_reply_entries_bind(
    of_group_stats_reply_t *obj,
    of_list_group_stats_entry_t *entries)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_GROUP_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_group_stats_entry_init(entries, obj->version, 0, 1);
    /* Attach to parent */
    entries->parent = (of_object_t *)obj;
    entries->wire_object.wbuf = obj->wire_object.wbuf;
    entries->wire_object.obj_offset = abs_offset;
    entries->wire_object.owned = 0;
    entries->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of entries into a new variable of type of_list_group_stats_entry_t from
 * a of_group_stats_reply instance.
 *
 * @param obj Pointer to the source of type of_group_stats_reply_t
 * @returns A pointer to a new instance of type of_list_group_stats_entry_t whose contents
 * match that of entries from source
 * @returns NULL if an error occurs
 */
of_list_group_stats_entry_t *
of_group_stats_reply_entries_get(of_group_stats_reply_t *obj) {
    of_list_group_stats_entry_t _entries;
    of_list_group_stats_entry_t *_entries_ptr;

    of_group_stats_reply_entries_bind(obj, &_entries);
    _entries_ptr = (of_list_group_stats_entry_t *)of_object_dup(&_entries);
    return _entries_ptr;
}

/**
 * Set entries in an object of type of_group_stats_reply.
 * @param obj Pointer to an object of type of_group_stats_reply.
 * @param entries Pointer to the child of type of_list_group_stats_entry_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_group_stats_reply_entries_set(
    of_group_stats_reply_t *obj,
    of_list_group_stats_entry_t *entries)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_GROUP_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = entries->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == entries->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(entries, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(entries, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (entries->wire_length_set != NULL) {
        entries->wire_length_set((of_object_t *)entries, entries->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_group_stats_request */
/** \ingroup of_group_stats_request 
 * @{ */

/**
 * Get xid from an object of type of_group_stats_request.
 * @param obj Pointer to an object of type of_group_stats_request.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_group_stats_request_xid_get(
    of_group_stats_request_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_group_stats_request.
 * @param obj Pointer to an object of type of_group_stats_request.
 * @param xid The value to write into the object
 */
void
of_group_stats_request_xid_set(
    of_group_stats_request_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get flags from an object of type of_group_stats_request.
 * @param obj Pointer to an object of type of_group_stats_request.
 * @param flags Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_group_stats_request_flags_get(
    of_group_stats_request_t *obj,
    uint16_t *flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set flags in an object of type of_group_stats_request.
 * @param obj Pointer to an object of type of_group_stats_request.
 * @param flags The value to write into the object
 */
void
of_group_stats_request_flags_set(
    of_group_stats_request_t *obj,
    uint16_t flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get group_id from an object of type of_group_stats_request.
 * @param obj Pointer to an object of type of_group_stats_request.
 * @param group_id Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_group_stats_request_group_id_get(
    of_group_stats_request_t *obj,
    uint32_t *group_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, group_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set group_id in an object of type of_group_stats_request.
 * @param obj Pointer to an object of type of_group_stats_request.
 * @param group_id The value to write into the object
 */
void
of_group_stats_request_group_id_set(
    of_group_stats_request_t *obj,
    uint32_t group_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, group_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_hello */
/** \ingroup of_hello 
 * @{ */

/**
 * Get xid from an object of type of_hello.
 * @param obj Pointer to an object of type of_hello.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_hello_xid_get(
    of_hello_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_HELLO);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_hello.
 * @param obj Pointer to an object of type of_hello.
 * @param xid The value to write into the object
 */
void
of_hello_xid_set(
    of_hello_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_HELLO);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Bind an object of type of_list_hello_elem_t to the parent of type of_hello for
 * member elements
 * @param obj Pointer to an object of type of_hello.
 * @param elements Pointer to the child object of type
 * of_list_hello_elem_t to be filled out.
 * \ingroup of_hello
 *
 * The parameter elements is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_hello_elements_bind(
    of_hello_t *obj,
    of_list_hello_elem_t *elements)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_HELLO);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 8;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_hello_elem_init(elements, obj->version, 0, 1);
    /* Attach to parent */
    elements->parent = (of_object_t *)obj;
    elements->wire_object.wbuf = obj->wire_object.wbuf;
    elements->wire_object.obj_offset = abs_offset;
    elements->wire_object.owned = 0;
    elements->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of elements into a new variable of type of_list_hello_elem_t from
 * a of_hello instance.
 *
 * @param obj Pointer to the source of type of_hello_t
 * @returns A pointer to a new instance of type of_list_hello_elem_t whose contents
 * match that of elements from source
 * @returns NULL if an error occurs
 */
of_list_hello_elem_t *
of_hello_elements_get(of_hello_t *obj) {
    of_list_hello_elem_t _elements;
    of_list_hello_elem_t *_elements_ptr;

    of_hello_elements_bind(obj, &_elements);
    _elements_ptr = (of_list_hello_elem_t *)of_object_dup(&_elements);
    return _elements_ptr;
}

/**
 * Set elements in an object of type of_hello.
 * @param obj Pointer to an object of type of_hello.
 * @param elements Pointer to the child of type of_list_hello_elem_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_hello_elements_set(
    of_hello_t *obj,
    of_list_hello_elem_t *elements)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_HELLO);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 8;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = elements->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == elements->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(elements, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(elements, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (elements->wire_length_set != NULL) {
        elements->wire_length_set((of_object_t *)elements, elements->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_meter_config_stats_reply */
/** \ingroup of_meter_config_stats_reply 
 * @{ */

/**
 * Get xid from an object of type of_meter_config_stats_reply.
 * @param obj Pointer to an object of type of_meter_config_stats_reply.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_meter_config_stats_reply_xid_get(
    of_meter_config_stats_reply_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_CONFIG_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_meter_config_stats_reply.
 * @param obj Pointer to an object of type of_meter_config_stats_reply.
 * @param xid The value to write into the object
 */
void
of_meter_config_stats_reply_xid_set(
    of_meter_config_stats_reply_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_CONFIG_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get flags from an object of type of_meter_config_stats_reply.
 * @param obj Pointer to an object of type of_meter_config_stats_reply.
 * @param flags Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_meter_config_stats_reply_flags_get(
    of_meter_config_stats_reply_t *obj,
    uint16_t *flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_CONFIG_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set flags in an object of type of_meter_config_stats_reply.
 * @param obj Pointer to an object of type of_meter_config_stats_reply.
 * @param flags The value to write into the object
 */
void
of_meter_config_stats_reply_flags_set(
    of_meter_config_stats_reply_t *obj,
    uint16_t flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_CONFIG_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Bind an object of type of_list_meter_band_t to the parent of type of_meter_config_stats_reply for
 * member entries
 * @param obj Pointer to an object of type of_meter_config_stats_reply.
 * @param entries Pointer to the child object of type
 * of_list_meter_band_t to be filled out.
 * \ingroup of_meter_config_stats_reply
 *
 * The parameter entries is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_meter_config_stats_reply_entries_bind(
    of_meter_config_stats_reply_t *obj,
    of_list_meter_band_t *entries)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_METER_CONFIG_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 16;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_meter_band_init(entries, obj->version, 0, 1);
    /* Attach to parent */
    entries->parent = (of_object_t *)obj;
    entries->wire_object.wbuf = obj->wire_object.wbuf;
    entries->wire_object.obj_offset = abs_offset;
    entries->wire_object.owned = 0;
    entries->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of entries into a new variable of type of_list_meter_band_t from
 * a of_meter_config_stats_reply instance.
 *
 * @param obj Pointer to the source of type of_meter_config_stats_reply_t
 * @returns A pointer to a new instance of type of_list_meter_band_t whose contents
 * match that of entries from source
 * @returns NULL if an error occurs
 */
of_list_meter_band_t *
of_meter_config_stats_reply_entries_get(of_meter_config_stats_reply_t *obj) {
    of_list_meter_band_t _entries;
    of_list_meter_band_t *_entries_ptr;

    of_meter_config_stats_reply_entries_bind(obj, &_entries);
    _entries_ptr = (of_list_meter_band_t *)of_object_dup(&_entries);
    return _entries_ptr;
}

/**
 * Set entries in an object of type of_meter_config_stats_reply.
 * @param obj Pointer to an object of type of_meter_config_stats_reply.
 * @param entries Pointer to the child of type of_list_meter_band_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_meter_config_stats_reply_entries_set(
    of_meter_config_stats_reply_t *obj,
    of_list_meter_band_t *entries)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_METER_CONFIG_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 16;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = entries->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == entries->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(entries, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(entries, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (entries->wire_length_set != NULL) {
        entries->wire_length_set((of_object_t *)entries, entries->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_meter_config_stats_request */
/** \ingroup of_meter_config_stats_request 
 * @{ */

/**
 * Get xid from an object of type of_meter_config_stats_request.
 * @param obj Pointer to an object of type of_meter_config_stats_request.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_meter_config_stats_request_xid_get(
    of_meter_config_stats_request_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_CONFIG_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_meter_config_stats_request.
 * @param obj Pointer to an object of type of_meter_config_stats_request.
 * @param xid The value to write into the object
 */
void
of_meter_config_stats_request_xid_set(
    of_meter_config_stats_request_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_CONFIG_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get flags from an object of type of_meter_config_stats_request.
 * @param obj Pointer to an object of type of_meter_config_stats_request.
 * @param flags Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_meter_config_stats_request_flags_get(
    of_meter_config_stats_request_t *obj,
    uint16_t *flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_CONFIG_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set flags in an object of type of_meter_config_stats_request.
 * @param obj Pointer to an object of type of_meter_config_stats_request.
 * @param flags The value to write into the object
 */
void
of_meter_config_stats_request_flags_set(
    of_meter_config_stats_request_t *obj,
    uint16_t flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_CONFIG_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get meter_id from an object of type of_meter_config_stats_request.
 * @param obj Pointer to an object of type of_meter_config_stats_request.
 * @param meter_id Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_meter_config_stats_request_meter_id_get(
    of_meter_config_stats_request_t *obj,
    uint32_t *meter_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_CONFIG_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, meter_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set meter_id in an object of type of_meter_config_stats_request.
 * @param obj Pointer to an object of type of_meter_config_stats_request.
 * @param meter_id The value to write into the object
 */
void
of_meter_config_stats_request_meter_id_set(
    of_meter_config_stats_request_t *obj,
    uint32_t meter_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_CONFIG_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, meter_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_meter_features_stats_reply */
/** \ingroup of_meter_features_stats_reply 
 * @{ */

/**
 * Get xid from an object of type of_meter_features_stats_reply.
 * @param obj Pointer to an object of type of_meter_features_stats_reply.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_meter_features_stats_reply_xid_get(
    of_meter_features_stats_reply_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_FEATURES_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_meter_features_stats_reply.
 * @param obj Pointer to an object of type of_meter_features_stats_reply.
 * @param xid The value to write into the object
 */
void
of_meter_features_stats_reply_xid_set(
    of_meter_features_stats_reply_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_FEATURES_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get flags from an object of type of_meter_features_stats_reply.
 * @param obj Pointer to an object of type of_meter_features_stats_reply.
 * @param flags Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_meter_features_stats_reply_flags_get(
    of_meter_features_stats_reply_t *obj,
    uint16_t *flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_FEATURES_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set flags in an object of type of_meter_features_stats_reply.
 * @param obj Pointer to an object of type of_meter_features_stats_reply.
 * @param flags The value to write into the object
 */
void
of_meter_features_stats_reply_flags_set(
    of_meter_features_stats_reply_t *obj,
    uint16_t flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_FEATURES_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Bind an object of type of_meter_features_t to the parent of type of_meter_features_stats_reply for
 * member features
 * @param obj Pointer to an object of type of_meter_features_stats_reply.
 * @param features Pointer to the child object of type
 * of_meter_features_t to be filled out.
 * \ingroup of_meter_features_stats_reply
 *
 * The parameter features is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_meter_features_stats_reply_features_bind(
    of_meter_features_stats_reply_t *obj,
    of_meter_features_t *features)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_METER_FEATURES_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 16;
        cur_len = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_meter_features_init(features, obj->version, 0, 1);
    /* Attach to parent */
    features->parent = (of_object_t *)obj;
    features->wire_object.wbuf = obj->wire_object.wbuf;
    features->wire_object.obj_offset = abs_offset;
    features->wire_object.owned = 0;
    features->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of features into a new variable of type of_meter_features_t from
 * a of_meter_features_stats_reply instance.
 *
 * @param obj Pointer to the source of type of_meter_features_stats_reply_t
 * @returns A pointer to a new instance of type of_meter_features_t whose contents
 * match that of features from source
 * @returns NULL if an error occurs
 */
of_meter_features_t *
of_meter_features_stats_reply_features_get(of_meter_features_stats_reply_t *obj) {
    of_meter_features_t _features;
    of_meter_features_t *_features_ptr;

    of_meter_features_stats_reply_features_bind(obj, &_features);
    _features_ptr = (of_meter_features_t *)of_object_dup(&_features);
    return _features_ptr;
}

/**
 * Set features in an object of type of_meter_features_stats_reply.
 * @param obj Pointer to an object of type of_meter_features_stats_reply.
 * @param features Pointer to the child of type of_meter_features_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_meter_features_stats_reply_features_set(
    of_meter_features_stats_reply_t *obj,
    of_meter_features_t *features)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_METER_FEATURES_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 16;
        cur_len = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = features->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == features->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(features, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(features, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (features->wire_length_set != NULL) {
        features->wire_length_set((of_object_t *)features, features->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_meter_features_stats_request */
/** \ingroup of_meter_features_stats_request 
 * @{ */

/**
 * Get xid from an object of type of_meter_features_stats_request.
 * @param obj Pointer to an object of type of_meter_features_stats_request.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_meter_features_stats_request_xid_get(
    of_meter_features_stats_request_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_FEATURES_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_meter_features_stats_request.
 * @param obj Pointer to an object of type of_meter_features_stats_request.
 * @param xid The value to write into the object
 */
void
of_meter_features_stats_request_xid_set(
    of_meter_features_stats_request_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_FEATURES_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get flags from an object of type of_meter_features_stats_request.
 * @param obj Pointer to an object of type of_meter_features_stats_request.
 * @param flags Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_meter_features_stats_request_flags_get(
    of_meter_features_stats_request_t *obj,
    uint16_t *flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_FEATURES_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set flags in an object of type of_meter_features_stats_request.
 * @param obj Pointer to an object of type of_meter_features_stats_request.
 * @param flags The value to write into the object
 */
void
of_meter_features_stats_request_flags_set(
    of_meter_features_stats_request_t *obj,
    uint16_t flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_FEATURES_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_meter_mod */
/** \ingroup of_meter_mod 
 * @{ */

/**
 * Get xid from an object of type of_meter_mod.
 * @param obj Pointer to an object of type of_meter_mod.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_meter_mod_xid_get(
    of_meter_mod_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_MOD);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_meter_mod.
 * @param obj Pointer to an object of type of_meter_mod.
 * @param xid The value to write into the object
 */
void
of_meter_mod_xid_set(
    of_meter_mod_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_MOD);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get command from an object of type of_meter_mod.
 * @param obj Pointer to an object of type of_meter_mod.
 * @param command Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_meter_mod_command_get(
    of_meter_mod_t *obj,
    uint16_t *command)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_MOD);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, command);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set command in an object of type of_meter_mod.
 * @param obj Pointer to an object of type of_meter_mod.
 * @param command The value to write into the object
 */
void
of_meter_mod_command_set(
    of_meter_mod_t *obj,
    uint16_t command)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_MOD);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, command);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get flags from an object of type of_meter_mod.
 * @param obj Pointer to an object of type of_meter_mod.
 * @param flags Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_meter_mod_flags_get(
    of_meter_mod_t *obj,
    uint16_t *flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_MOD);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set flags in an object of type of_meter_mod.
 * @param obj Pointer to an object of type of_meter_mod.
 * @param flags The value to write into the object
 */
void
of_meter_mod_flags_set(
    of_meter_mod_t *obj,
    uint16_t flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_MOD);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get meter_id from an object of type of_meter_mod.
 * @param obj Pointer to an object of type of_meter_mod.
 * @param meter_id Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_meter_mod_meter_id_get(
    of_meter_mod_t *obj,
    uint32_t *meter_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_MOD);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, meter_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set meter_id in an object of type of_meter_mod.
 * @param obj Pointer to an object of type of_meter_mod.
 * @param meter_id The value to write into the object
 */
void
of_meter_mod_meter_id_set(
    of_meter_mod_t *obj,
    uint32_t meter_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_MOD);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, meter_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Bind an object of type of_list_meter_band_t to the parent of type of_meter_mod for
 * member meters
 * @param obj Pointer to an object of type of_meter_mod.
 * @param meters Pointer to the child object of type
 * of_list_meter_band_t to be filled out.
 * \ingroup of_meter_mod
 *
 * The parameter meters is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_meter_mod_meters_bind(
    of_meter_mod_t *obj,
    of_list_meter_band_t *meters)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_METER_MOD);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 16;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_meter_band_init(meters, obj->version, 0, 1);
    /* Attach to parent */
    meters->parent = (of_object_t *)obj;
    meters->wire_object.wbuf = obj->wire_object.wbuf;
    meters->wire_object.obj_offset = abs_offset;
    meters->wire_object.owned = 0;
    meters->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of meters into a new variable of type of_list_meter_band_t from
 * a of_meter_mod instance.
 *
 * @param obj Pointer to the source of type of_meter_mod_t
 * @returns A pointer to a new instance of type of_list_meter_band_t whose contents
 * match that of meters from source
 * @returns NULL if an error occurs
 */
of_list_meter_band_t *
of_meter_mod_meters_get(of_meter_mod_t *obj) {
    of_list_meter_band_t _meters;
    of_list_meter_band_t *_meters_ptr;

    of_meter_mod_meters_bind(obj, &_meters);
    _meters_ptr = (of_list_meter_band_t *)of_object_dup(&_meters);
    return _meters_ptr;
}

/**
 * Set meters in an object of type of_meter_mod.
 * @param obj Pointer to an object of type of_meter_mod.
 * @param meters Pointer to the child of type of_list_meter_band_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_meter_mod_meters_set(
    of_meter_mod_t *obj,
    of_list_meter_band_t *meters)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_METER_MOD);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 16;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = meters->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == meters->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(meters, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(meters, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (meters->wire_length_set != NULL) {
        meters->wire_length_set((of_object_t *)meters, meters->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_meter_stats_reply */
/** \ingroup of_meter_stats_reply 
 * @{ */

/**
 * Get xid from an object of type of_meter_stats_reply.
 * @param obj Pointer to an object of type of_meter_stats_reply.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_meter_stats_reply_xid_get(
    of_meter_stats_reply_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_meter_stats_reply.
 * @param obj Pointer to an object of type of_meter_stats_reply.
 * @param xid The value to write into the object
 */
void
of_meter_stats_reply_xid_set(
    of_meter_stats_reply_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get flags from an object of type of_meter_stats_reply.
 * @param obj Pointer to an object of type of_meter_stats_reply.
 * @param flags Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_meter_stats_reply_flags_get(
    of_meter_stats_reply_t *obj,
    uint16_t *flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set flags in an object of type of_meter_stats_reply.
 * @param obj Pointer to an object of type of_meter_stats_reply.
 * @param flags The value to write into the object
 */
void
of_meter_stats_reply_flags_set(
    of_meter_stats_reply_t *obj,
    uint16_t flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Bind an object of type of_list_meter_stats_t to the parent of type of_meter_stats_reply for
 * member entries
 * @param obj Pointer to an object of type of_meter_stats_reply.
 * @param entries Pointer to the child object of type
 * of_list_meter_stats_t to be filled out.
 * \ingroup of_meter_stats_reply
 *
 * The parameter entries is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_meter_stats_reply_entries_bind(
    of_meter_stats_reply_t *obj,
    of_list_meter_stats_t *entries)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_METER_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 16;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_meter_stats_init(entries, obj->version, 0, 1);
    /* Attach to parent */
    entries->parent = (of_object_t *)obj;
    entries->wire_object.wbuf = obj->wire_object.wbuf;
    entries->wire_object.obj_offset = abs_offset;
    entries->wire_object.owned = 0;
    entries->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of entries into a new variable of type of_list_meter_stats_t from
 * a of_meter_stats_reply instance.
 *
 * @param obj Pointer to the source of type of_meter_stats_reply_t
 * @returns A pointer to a new instance of type of_list_meter_stats_t whose contents
 * match that of entries from source
 * @returns NULL if an error occurs
 */
of_list_meter_stats_t *
of_meter_stats_reply_entries_get(of_meter_stats_reply_t *obj) {
    of_list_meter_stats_t _entries;
    of_list_meter_stats_t *_entries_ptr;

    of_meter_stats_reply_entries_bind(obj, &_entries);
    _entries_ptr = (of_list_meter_stats_t *)of_object_dup(&_entries);
    return _entries_ptr;
}

/**
 * Set entries in an object of type of_meter_stats_reply.
 * @param obj Pointer to an object of type of_meter_stats_reply.
 * @param entries Pointer to the child of type of_list_meter_stats_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_meter_stats_reply_entries_set(
    of_meter_stats_reply_t *obj,
    of_list_meter_stats_t *entries)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_METER_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 16;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = entries->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == entries->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(entries, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(entries, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (entries->wire_length_set != NULL) {
        entries->wire_length_set((of_object_t *)entries, entries->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_meter_stats_request */
/** \ingroup of_meter_stats_request 
 * @{ */

/**
 * Get xid from an object of type of_meter_stats_request.
 * @param obj Pointer to an object of type of_meter_stats_request.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_meter_stats_request_xid_get(
    of_meter_stats_request_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_meter_stats_request.
 * @param obj Pointer to an object of type of_meter_stats_request.
 * @param xid The value to write into the object
 */
void
of_meter_stats_request_xid_set(
    of_meter_stats_request_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get flags from an object of type of_meter_stats_request.
 * @param obj Pointer to an object of type of_meter_stats_request.
 * @param flags Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_meter_stats_request_flags_get(
    of_meter_stats_request_t *obj,
    uint16_t *flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set flags in an object of type of_meter_stats_request.
 * @param obj Pointer to an object of type of_meter_stats_request.
 * @param flags The value to write into the object
 */
void
of_meter_stats_request_flags_set(
    of_meter_stats_request_t *obj,
    uint16_t flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get meter_id from an object of type of_meter_stats_request.
 * @param obj Pointer to an object of type of_meter_stats_request.
 * @param meter_id Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_meter_stats_request_meter_id_get(
    of_meter_stats_request_t *obj,
    uint32_t *meter_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, meter_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set meter_id in an object of type of_meter_stats_request.
 * @param obj Pointer to an object of type of_meter_stats_request.
 * @param meter_id The value to write into the object
 */
void
of_meter_stats_request_meter_id_set(
    of_meter_stats_request_t *obj,
    uint32_t meter_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, meter_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_nicira_controller_role_reply */
/** \ingroup of_nicira_controller_role_reply 
 * @{ */

/**
 * Get xid from an object of type of_nicira_controller_role_reply.
 * @param obj Pointer to an object of type of_nicira_controller_role_reply.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_nicira_controller_role_reply_xid_get(
    of_nicira_controller_role_reply_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_NICIRA_CONTROLLER_ROLE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_nicira_controller_role_reply.
 * @param obj Pointer to an object of type of_nicira_controller_role_reply.
 * @param xid The value to write into the object
 */
void
of_nicira_controller_role_reply_xid_set(
    of_nicira_controller_role_reply_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_NICIRA_CONTROLLER_ROLE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get experimenter from an object of type of_nicira_controller_role_reply.
 * @param obj Pointer to an object of type of_nicira_controller_role_reply.
 * @param experimenter Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_nicira_controller_role_reply_experimenter_get(
    of_nicira_controller_role_reply_t *obj,
    uint32_t *experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_NICIRA_CONTROLLER_ROLE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set experimenter in an object of type of_nicira_controller_role_reply.
 * @param obj Pointer to an object of type of_nicira_controller_role_reply.
 * @param experimenter The value to write into the object
 */
void
of_nicira_controller_role_reply_experimenter_set(
    of_nicira_controller_role_reply_t *obj,
    uint32_t experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_NICIRA_CONTROLLER_ROLE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get subtype from an object of type of_nicira_controller_role_reply.
 * @param obj Pointer to an object of type of_nicira_controller_role_reply.
 * @param subtype Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_nicira_controller_role_reply_subtype_get(
    of_nicira_controller_role_reply_t *obj,
    uint32_t *subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_NICIRA_CONTROLLER_ROLE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set subtype in an object of type of_nicira_controller_role_reply.
 * @param obj Pointer to an object of type of_nicira_controller_role_reply.
 * @param subtype The value to write into the object
 */
void
of_nicira_controller_role_reply_subtype_set(
    of_nicira_controller_role_reply_t *obj,
    uint32_t subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_NICIRA_CONTROLLER_ROLE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get role from an object of type of_nicira_controller_role_reply.
 * @param obj Pointer to an object of type of_nicira_controller_role_reply.
 * @param role Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_nicira_controller_role_reply_role_get(
    of_nicira_controller_role_reply_t *obj,
    uint32_t *role)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_NICIRA_CONTROLLER_ROLE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, role);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set role in an object of type of_nicira_controller_role_reply.
 * @param obj Pointer to an object of type of_nicira_controller_role_reply.
 * @param role The value to write into the object
 */
void
of_nicira_controller_role_reply_role_set(
    of_nicira_controller_role_reply_t *obj,
    uint32_t role)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_NICIRA_CONTROLLER_ROLE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, role);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_nicira_controller_role_request */
/** \ingroup of_nicira_controller_role_request 
 * @{ */

/**
 * Get xid from an object of type of_nicira_controller_role_request.
 * @param obj Pointer to an object of type of_nicira_controller_role_request.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_nicira_controller_role_request_xid_get(
    of_nicira_controller_role_request_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_NICIRA_CONTROLLER_ROLE_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_nicira_controller_role_request.
 * @param obj Pointer to an object of type of_nicira_controller_role_request.
 * @param xid The value to write into the object
 */
void
of_nicira_controller_role_request_xid_set(
    of_nicira_controller_role_request_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_NICIRA_CONTROLLER_ROLE_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get experimenter from an object of type of_nicira_controller_role_request.
 * @param obj Pointer to an object of type of_nicira_controller_role_request.
 * @param experimenter Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_nicira_controller_role_request_experimenter_get(
    of_nicira_controller_role_request_t *obj,
    uint32_t *experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_NICIRA_CONTROLLER_ROLE_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set experimenter in an object of type of_nicira_controller_role_request.
 * @param obj Pointer to an object of type of_nicira_controller_role_request.
 * @param experimenter The value to write into the object
 */
void
of_nicira_controller_role_request_experimenter_set(
    of_nicira_controller_role_request_t *obj,
    uint32_t experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_NICIRA_CONTROLLER_ROLE_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get subtype from an object of type of_nicira_controller_role_request.
 * @param obj Pointer to an object of type of_nicira_controller_role_request.
 * @param subtype Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_nicira_controller_role_request_subtype_get(
    of_nicira_controller_role_request_t *obj,
    uint32_t *subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_NICIRA_CONTROLLER_ROLE_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set subtype in an object of type of_nicira_controller_role_request.
 * @param obj Pointer to an object of type of_nicira_controller_role_request.
 * @param subtype The value to write into the object
 */
void
of_nicira_controller_role_request_subtype_set(
    of_nicira_controller_role_request_t *obj,
    uint32_t subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_NICIRA_CONTROLLER_ROLE_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get role from an object of type of_nicira_controller_role_request.
 * @param obj Pointer to an object of type of_nicira_controller_role_request.
 * @param role Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_nicira_controller_role_request_role_get(
    of_nicira_controller_role_request_t *obj,
    uint32_t *role)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_NICIRA_CONTROLLER_ROLE_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, role);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set role in an object of type of_nicira_controller_role_request.
 * @param obj Pointer to an object of type of_nicira_controller_role_request.
 * @param role The value to write into the object
 */
void
of_nicira_controller_role_request_role_set(
    of_nicira_controller_role_request_t *obj,
    uint32_t role)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_NICIRA_CONTROLLER_ROLE_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, role);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_packet_in */
/** \ingroup of_packet_in 
 * @{ */

/**
 * Get xid from an object of type of_packet_in.
 * @param obj Pointer to an object of type of_packet_in.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_packet_in_xid_get(
    of_packet_in_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PACKET_IN);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_packet_in.
 * @param obj Pointer to an object of type of_packet_in.
 * @param xid The value to write into the object
 */
void
of_packet_in_xid_set(
    of_packet_in_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PACKET_IN);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get buffer_id from an object of type of_packet_in.
 * @param obj Pointer to an object of type of_packet_in.
 * @param buffer_id Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_packet_in_buffer_id_get(
    of_packet_in_t *obj,
    uint32_t *buffer_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PACKET_IN);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, buffer_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set buffer_id in an object of type of_packet_in.
 * @param obj Pointer to an object of type of_packet_in.
 * @param buffer_id The value to write into the object
 */
void
of_packet_in_buffer_id_set(
    of_packet_in_t *obj,
    uint32_t buffer_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PACKET_IN);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, buffer_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get total_len from an object of type of_packet_in.
 * @param obj Pointer to an object of type of_packet_in.
 * @param total_len Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_packet_in_total_len_get(
    of_packet_in_t *obj,
    uint16_t *total_len)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PACKET_IN);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        break;
    case OF_VERSION_1_1:
        offset = 20;
        break;
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, total_len);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set total_len in an object of type of_packet_in.
 * @param obj Pointer to an object of type of_packet_in.
 * @param total_len The value to write into the object
 */
void
of_packet_in_total_len_set(
    of_packet_in_t *obj,
    uint16_t total_len)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PACKET_IN);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        break;
    case OF_VERSION_1_1:
        offset = 20;
        break;
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, total_len);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get reason from an object of type of_packet_in.
 * @param obj Pointer to an object of type of_packet_in.
 * @param reason Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_packet_in_reason_get(
    of_packet_in_t *obj,
    uint8_t *reason)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PACKET_IN);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 16;
        break;
    case OF_VERSION_1_1:
        offset = 22;
        break;
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 14;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, reason);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set reason in an object of type of_packet_in.
 * @param obj Pointer to an object of type of_packet_in.
 * @param reason The value to write into the object
 */
void
of_packet_in_reason_set(
    of_packet_in_t *obj,
    uint8_t reason)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PACKET_IN);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 16;
        break;
    case OF_VERSION_1_1:
        offset = 22;
        break;
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 14;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, reason);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get table_id from an object of type of_packet_in.
 * @param obj Pointer to an object of type of_packet_in.
 * @param table_id Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_packet_in_table_id_get(
    of_packet_in_t *obj,
    uint8_t *table_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PACKET_IN);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 23;
        break;
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 15;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, table_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set table_id in an object of type of_packet_in.
 * @param obj Pointer to an object of type of_packet_in.
 * @param table_id The value to write into the object
 */
void
of_packet_in_table_id_set(
    of_packet_in_t *obj,
    uint8_t table_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PACKET_IN);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 23;
        break;
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 15;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, table_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get cookie from an object of type of_packet_in.
 * @param obj Pointer to an object of type of_packet_in.
 * @param cookie Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_packet_in_cookie_get(
    of_packet_in_t *obj,
    uint64_t *cookie)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PACKET_IN);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, cookie);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set cookie in an object of type of_packet_in.
 * @param obj Pointer to an object of type of_packet_in.
 * @param cookie The value to write into the object
 */
void
of_packet_in_cookie_set(
    of_packet_in_t *obj,
    uint64_t cookie)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PACKET_IN);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, cookie);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get match from an object of type of_packet_in.
 * @param obj Pointer to an object of type of_packet_in.
 * @param match Pointer to the child object of type
 * of_match_t to be filled out.
 *
 */
int WARN_UNUSED_RESULT
of_packet_in_match_get(
    of_packet_in_t *obj,
    of_match_t *match)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    of_octets_t match_octets; /* Serialized string for match */

    ASSERT(obj->object_id == OF_PACKET_IN);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
        offset = 16;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    case OF_VERSION_1_3:
        offset = 24;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    ASSERT(cur_len + abs_offset <= WBUF_CURRENT_BYTES(wbuf));
    match_octets.bytes = cur_len;
    match_octets.data = OF_OBJECT_BUFFER_INDEX(obj, offset);
    OF_TRY(of_match_deserialize(ver, match, &match_octets));

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/**
 * Set match in an object of type of_packet_in.
 * @param obj Pointer to an object of type of_packet_in.
 * @param match Pointer to the child of type of_match_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_packet_in_match_set(
    of_packet_in_t *obj,
    of_match_t *match)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */
    of_octets_t match_octets; /* Serialized string for match */

    ASSERT(obj->object_id == OF_PACKET_IN);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
        offset = 16;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    case OF_VERSION_1_3:
        offset = 24;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Match object */
    OF_TRY(of_match_serialize(ver, match, &match_octets));
    new_len = match_octets.bytes;
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        match_octets.data, new_len);
    /* Free match serialized octets */
    FREE(match_octets.data);

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/**
 * Get data from an object of type of_packet_in.
 * @param obj Pointer to an object of type of_packet_in.
 * @param data Pointer to the child object of type
 * of_octets_t to be filled out.
 *
 */
void
of_packet_in_data_get(
    of_packet_in_t *obj,
    of_octets_t *data)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_PACKET_IN);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 18;
        cur_len = _END_LEN(obj, offset);
        break;
    case OF_VERSION_1_1:
        offset = 24;
        cur_len = _END_LEN(obj, offset);
        break;
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = _PACKET_IN_DATA_OFFSET(obj);
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);
    ASSERT(cur_len + abs_offset <= WBUF_CURRENT_BYTES(wbuf));
    data->bytes = cur_len;
    data->data = OF_WIRE_BUFFER_INDEX(wbuf, abs_offset);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set data in an object of type of_packet_in.
 * @param obj Pointer to an object of type of_packet_in.
 * @param data The value to write into the object
 */
int WARN_UNUSED_RESULT
of_packet_in_data_set(
    of_packet_in_t *obj,
    of_octets_t *data)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_PACKET_IN);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 18;
        cur_len = _END_LEN(obj, offset);
        break;
    case OF_VERSION_1_1:
        offset = 24;
        cur_len = _END_LEN(obj, offset);
        break;
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = _PACKET_IN_DATA_OFFSET(obj);
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);
    new_len = data->bytes;
    of_wire_buffer_grow(wbuf, abs_offset + (new_len - cur_len));
    of_wire_buffer_octets_data_set(wbuf, abs_offset, data, cur_len);

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/**
 * Get in_port from an object of type of_packet_in.
 * @param obj Pointer to an object of type of_packet_in.
 * @param in_port Pointer to the child object of type
 * of_port_no_t to be filled out.
 *
 */
void
of_packet_in_in_port_get(
    of_packet_in_t *obj,
    of_port_no_t *in_port)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PACKET_IN);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 14;
        break;
    case OF_VERSION_1_1:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_get(ver, wbuf, abs_offset, in_port);
    OF_PORT_NO_VALUE_CHECK(*in_port, ver);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set in_port in an object of type of_packet_in.
 * @param obj Pointer to an object of type of_packet_in.
 * @param in_port The value to write into the object
 */
void
of_packet_in_in_port_set(
    of_packet_in_t *obj,
    of_port_no_t in_port)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PACKET_IN);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 14;
        break;
    case OF_VERSION_1_1:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_set(ver, wbuf, abs_offset, in_port);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get in_phy_port from an object of type of_packet_in.
 * @param obj Pointer to an object of type of_packet_in.
 * @param in_phy_port Pointer to the child object of type
 * of_port_no_t to be filled out.
 *
 */
void
of_packet_in_in_phy_port_get(
    of_packet_in_t *obj,
    of_port_no_t *in_phy_port)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PACKET_IN);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_get(ver, wbuf, abs_offset, in_phy_port);
    OF_PORT_NO_VALUE_CHECK(*in_phy_port, ver);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set in_phy_port in an object of type of_packet_in.
 * @param obj Pointer to an object of type of_packet_in.
 * @param in_phy_port The value to write into the object
 */
void
of_packet_in_in_phy_port_set(
    of_packet_in_t *obj,
    of_port_no_t in_phy_port)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PACKET_IN);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_set(ver, wbuf, abs_offset, in_phy_port);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_packet_out */
/** \ingroup of_packet_out 
 * @{ */

/**
 * Get xid from an object of type of_packet_out.
 * @param obj Pointer to an object of type of_packet_out.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_packet_out_xid_get(
    of_packet_out_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PACKET_OUT);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_packet_out.
 * @param obj Pointer to an object of type of_packet_out.
 * @param xid The value to write into the object
 */
void
of_packet_out_xid_set(
    of_packet_out_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PACKET_OUT);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get buffer_id from an object of type of_packet_out.
 * @param obj Pointer to an object of type of_packet_out.
 * @param buffer_id Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_packet_out_buffer_id_get(
    of_packet_out_t *obj,
    uint32_t *buffer_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PACKET_OUT);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, buffer_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set buffer_id in an object of type of_packet_out.
 * @param obj Pointer to an object of type of_packet_out.
 * @param buffer_id The value to write into the object
 */
void
of_packet_out_buffer_id_set(
    of_packet_out_t *obj,
    uint32_t buffer_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PACKET_OUT);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, buffer_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get in_port from an object of type of_packet_out.
 * @param obj Pointer to an object of type of_packet_out.
 * @param in_port Pointer to the child object of type
 * of_port_no_t to be filled out.
 *
 */
void
of_packet_out_in_port_get(
    of_packet_out_t *obj,
    of_port_no_t *in_port)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PACKET_OUT);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_get(ver, wbuf, abs_offset, in_port);
    OF_PORT_NO_VALUE_CHECK(*in_port, ver);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set in_port in an object of type of_packet_out.
 * @param obj Pointer to an object of type of_packet_out.
 * @param in_port The value to write into the object
 */
void
of_packet_out_in_port_set(
    of_packet_out_t *obj,
    of_port_no_t in_port)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PACKET_OUT);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_set(ver, wbuf, abs_offset, in_port);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Bind an object of type of_list_action_t to the parent of type of_packet_out for
 * member actions
 * @param obj Pointer to an object of type of_packet_out.
 * @param actions Pointer to the child object of type
 * of_list_action_t to be filled out.
 * \ingroup of_packet_out
 *
 * The parameter actions is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_packet_out_actions_bind(
    of_packet_out_t *obj,
    of_list_action_t *actions)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_PACKET_OUT);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 16;
        cur_len = _PACKET_OUT_ACTION_LEN(obj);
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 24;
        cur_len = _PACKET_OUT_ACTION_LEN(obj);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_action_init(actions, obj->version, 0, 1);
    /* Attach to parent */
    actions->parent = (of_object_t *)obj;
    actions->wire_object.wbuf = obj->wire_object.wbuf;
    actions->wire_object.obj_offset = abs_offset;
    actions->wire_object.owned = 0;
    actions->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of actions into a new variable of type of_list_action_t from
 * a of_packet_out instance.
 *
 * @param obj Pointer to the source of type of_packet_out_t
 * @returns A pointer to a new instance of type of_list_action_t whose contents
 * match that of actions from source
 * @returns NULL if an error occurs
 */
of_list_action_t *
of_packet_out_actions_get(of_packet_out_t *obj) {
    of_list_action_t _actions;
    of_list_action_t *_actions_ptr;

    of_packet_out_actions_bind(obj, &_actions);
    _actions_ptr = (of_list_action_t *)of_object_dup(&_actions);
    return _actions_ptr;
}

/**
 * Set actions in an object of type of_packet_out.
 * @param obj Pointer to an object of type of_packet_out.
 * @param actions Pointer to the child of type of_list_action_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_packet_out_actions_set(
    of_packet_out_t *obj,
    of_list_action_t *actions)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_PACKET_OUT);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 16;
        cur_len = _PACKET_OUT_ACTION_LEN(obj);
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 24;
        cur_len = _PACKET_OUT_ACTION_LEN(obj);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = actions->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == actions->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(actions, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(actions, 0), new_len);

    /* Special case for setting action lengths */
    _PACKET_OUT_ACTION_LEN_SET(obj, actions->length);

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/**
 * Get data from an object of type of_packet_out.
 * @param obj Pointer to an object of type of_packet_out.
 * @param data Pointer to the child object of type
 * of_octets_t to be filled out.
 *
 */
void
of_packet_out_data_get(
    of_packet_out_t *obj,
    of_octets_t *data)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_PACKET_OUT);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = _PACKET_OUT_DATA_OFFSET(obj);
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);
    ASSERT(cur_len + abs_offset <= WBUF_CURRENT_BYTES(wbuf));
    data->bytes = cur_len;
    data->data = OF_WIRE_BUFFER_INDEX(wbuf, abs_offset);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set data in an object of type of_packet_out.
 * @param obj Pointer to an object of type of_packet_out.
 * @param data The value to write into the object
 */
int WARN_UNUSED_RESULT
of_packet_out_data_set(
    of_packet_out_t *obj,
    of_octets_t *data)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_PACKET_OUT);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = _PACKET_OUT_DATA_OFFSET(obj);
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);
    new_len = data->bytes;
    of_wire_buffer_grow(wbuf, abs_offset + (new_len - cur_len));
    of_wire_buffer_octets_data_set(wbuf, abs_offset, data, cur_len);

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_port_desc_stats_reply */
/** \ingroup of_port_desc_stats_reply 
 * @{ */

/**
 * Get xid from an object of type of_port_desc_stats_reply.
 * @param obj Pointer to an object of type of_port_desc_stats_reply.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_port_desc_stats_reply_xid_get(
    of_port_desc_stats_reply_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_DESC_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_port_desc_stats_reply.
 * @param obj Pointer to an object of type of_port_desc_stats_reply.
 * @param xid The value to write into the object
 */
void
of_port_desc_stats_reply_xid_set(
    of_port_desc_stats_reply_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_DESC_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get flags from an object of type of_port_desc_stats_reply.
 * @param obj Pointer to an object of type of_port_desc_stats_reply.
 * @param flags Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_port_desc_stats_reply_flags_get(
    of_port_desc_stats_reply_t *obj,
    uint16_t *flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_DESC_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set flags in an object of type of_port_desc_stats_reply.
 * @param obj Pointer to an object of type of_port_desc_stats_reply.
 * @param flags The value to write into the object
 */
void
of_port_desc_stats_reply_flags_set(
    of_port_desc_stats_reply_t *obj,
    uint16_t flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_DESC_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Bind an object of type of_list_port_desc_t to the parent of type of_port_desc_stats_reply for
 * member entries
 * @param obj Pointer to an object of type of_port_desc_stats_reply.
 * @param entries Pointer to the child object of type
 * of_list_port_desc_t to be filled out.
 * \ingroup of_port_desc_stats_reply
 *
 * The parameter entries is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_port_desc_stats_reply_entries_bind(
    of_port_desc_stats_reply_t *obj,
    of_list_port_desc_t *entries)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_PORT_DESC_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 16;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_port_desc_init(entries, obj->version, 0, 1);
    /* Attach to parent */
    entries->parent = (of_object_t *)obj;
    entries->wire_object.wbuf = obj->wire_object.wbuf;
    entries->wire_object.obj_offset = abs_offset;
    entries->wire_object.owned = 0;
    entries->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of entries into a new variable of type of_list_port_desc_t from
 * a of_port_desc_stats_reply instance.
 *
 * @param obj Pointer to the source of type of_port_desc_stats_reply_t
 * @returns A pointer to a new instance of type of_list_port_desc_t whose contents
 * match that of entries from source
 * @returns NULL if an error occurs
 */
of_list_port_desc_t *
of_port_desc_stats_reply_entries_get(of_port_desc_stats_reply_t *obj) {
    of_list_port_desc_t _entries;
    of_list_port_desc_t *_entries_ptr;

    of_port_desc_stats_reply_entries_bind(obj, &_entries);
    _entries_ptr = (of_list_port_desc_t *)of_object_dup(&_entries);
    return _entries_ptr;
}

/**
 * Set entries in an object of type of_port_desc_stats_reply.
 * @param obj Pointer to an object of type of_port_desc_stats_reply.
 * @param entries Pointer to the child of type of_list_port_desc_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_port_desc_stats_reply_entries_set(
    of_port_desc_stats_reply_t *obj,
    of_list_port_desc_t *entries)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_PORT_DESC_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 16;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = entries->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == entries->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(entries, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(entries, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (entries->wire_length_set != NULL) {
        entries->wire_length_set((of_object_t *)entries, entries->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_port_desc_stats_request */
/** \ingroup of_port_desc_stats_request 
 * @{ */

/**
 * Get xid from an object of type of_port_desc_stats_request.
 * @param obj Pointer to an object of type of_port_desc_stats_request.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_port_desc_stats_request_xid_get(
    of_port_desc_stats_request_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_DESC_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_port_desc_stats_request.
 * @param obj Pointer to an object of type of_port_desc_stats_request.
 * @param xid The value to write into the object
 */
void
of_port_desc_stats_request_xid_set(
    of_port_desc_stats_request_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_DESC_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get flags from an object of type of_port_desc_stats_request.
 * @param obj Pointer to an object of type of_port_desc_stats_request.
 * @param flags Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_port_desc_stats_request_flags_get(
    of_port_desc_stats_request_t *obj,
    uint16_t *flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_DESC_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set flags in an object of type of_port_desc_stats_request.
 * @param obj Pointer to an object of type of_port_desc_stats_request.
 * @param flags The value to write into the object
 */
void
of_port_desc_stats_request_flags_set(
    of_port_desc_stats_request_t *obj,
    uint16_t flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_DESC_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_port_mod */
/** \ingroup of_port_mod 
 * @{ */

/**
 * Get xid from an object of type of_port_mod.
 * @param obj Pointer to an object of type of_port_mod.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_port_mod_xid_get(
    of_port_mod_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_MOD);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_port_mod.
 * @param obj Pointer to an object of type of_port_mod.
 * @param xid The value to write into the object
 */
void
of_port_mod_xid_set(
    of_port_mod_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_MOD);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get port_no from an object of type of_port_mod.
 * @param obj Pointer to an object of type of_port_mod.
 * @param port_no Pointer to the child object of type
 * of_port_no_t to be filled out.
 *
 */
void
of_port_mod_port_no_get(
    of_port_mod_t *obj,
    of_port_no_t *port_no)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_MOD);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 8;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_get(ver, wbuf, abs_offset, port_no);
    OF_PORT_NO_VALUE_CHECK(*port_no, ver);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set port_no in an object of type of_port_mod.
 * @param obj Pointer to an object of type of_port_mod.
 * @param port_no The value to write into the object
 */
void
of_port_mod_port_no_set(
    of_port_mod_t *obj,
    of_port_no_t port_no)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_MOD);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 8;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_set(ver, wbuf, abs_offset, port_no);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get hw_addr from an object of type of_port_mod.
 * @param obj Pointer to an object of type of_port_mod.
 * @param hw_addr Pointer to the child object of type
 * of_mac_addr_t to be filled out.
 *
 */
void
of_port_mod_hw_addr_get(
    of_port_mod_t *obj,
    of_mac_addr_t *hw_addr)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_MOD);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 10;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_get(wbuf, abs_offset, hw_addr);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set hw_addr in an object of type of_port_mod.
 * @param obj Pointer to an object of type of_port_mod.
 * @param hw_addr The value to write into the object
 */
void
of_port_mod_hw_addr_set(
    of_port_mod_t *obj,
    of_mac_addr_t hw_addr)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_MOD);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 10;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_set(wbuf, abs_offset, hw_addr);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get config from an object of type of_port_mod.
 * @param obj Pointer to an object of type of_port_mod.
 * @param config Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_port_mod_config_get(
    of_port_mod_t *obj,
    uint32_t *config)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_MOD);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 16;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 24;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, config);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set config in an object of type of_port_mod.
 * @param obj Pointer to an object of type of_port_mod.
 * @param config The value to write into the object
 */
void
of_port_mod_config_set(
    of_port_mod_t *obj,
    uint32_t config)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_MOD);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 16;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 24;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, config);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get mask from an object of type of_port_mod.
 * @param obj Pointer to an object of type of_port_mod.
 * @param mask Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_port_mod_mask_get(
    of_port_mod_t *obj,
    uint32_t *mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_MOD);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 20;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 28;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set mask in an object of type of_port_mod.
 * @param obj Pointer to an object of type of_port_mod.
 * @param mask The value to write into the object
 */
void
of_port_mod_mask_set(
    of_port_mod_t *obj,
    uint32_t mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_MOD);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 20;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 28;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get advertise from an object of type of_port_mod.
 * @param obj Pointer to an object of type of_port_mod.
 * @param advertise Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_port_mod_advertise_get(
    of_port_mod_t *obj,
    uint32_t *advertise)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_MOD);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 24;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 32;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, advertise);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set advertise in an object of type of_port_mod.
 * @param obj Pointer to an object of type of_port_mod.
 * @param advertise The value to write into the object
 */
void
of_port_mod_advertise_set(
    of_port_mod_t *obj,
    uint32_t advertise)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_MOD);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 24;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 32;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, advertise);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_port_stats_reply */
/** \ingroup of_port_stats_reply 
 * @{ */

/**
 * Get xid from an object of type of_port_stats_reply.
 * @param obj Pointer to an object of type of_port_stats_reply.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_port_stats_reply_xid_get(
    of_port_stats_reply_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_port_stats_reply.
 * @param obj Pointer to an object of type of_port_stats_reply.
 * @param xid The value to write into the object
 */
void
of_port_stats_reply_xid_set(
    of_port_stats_reply_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get flags from an object of type of_port_stats_reply.
 * @param obj Pointer to an object of type of_port_stats_reply.
 * @param flags Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_port_stats_reply_flags_get(
    of_port_stats_reply_t *obj,
    uint16_t *flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set flags in an object of type of_port_stats_reply.
 * @param obj Pointer to an object of type of_port_stats_reply.
 * @param flags The value to write into the object
 */
void
of_port_stats_reply_flags_set(
    of_port_stats_reply_t *obj,
    uint16_t flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Bind an object of type of_list_port_stats_entry_t to the parent of type of_port_stats_reply for
 * member entries
 * @param obj Pointer to an object of type of_port_stats_reply.
 * @param entries Pointer to the child object of type
 * of_list_port_stats_entry_t to be filled out.
 * \ingroup of_port_stats_reply
 *
 * The parameter entries is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_port_stats_reply_entries_bind(
    of_port_stats_reply_t *obj,
    of_list_port_stats_entry_t *entries)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_PORT_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        cur_len = _END_LEN(obj, offset);
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_port_stats_entry_init(entries, obj->version, 0, 1);
    /* Attach to parent */
    entries->parent = (of_object_t *)obj;
    entries->wire_object.wbuf = obj->wire_object.wbuf;
    entries->wire_object.obj_offset = abs_offset;
    entries->wire_object.owned = 0;
    entries->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of entries into a new variable of type of_list_port_stats_entry_t from
 * a of_port_stats_reply instance.
 *
 * @param obj Pointer to the source of type of_port_stats_reply_t
 * @returns A pointer to a new instance of type of_list_port_stats_entry_t whose contents
 * match that of entries from source
 * @returns NULL if an error occurs
 */
of_list_port_stats_entry_t *
of_port_stats_reply_entries_get(of_port_stats_reply_t *obj) {
    of_list_port_stats_entry_t _entries;
    of_list_port_stats_entry_t *_entries_ptr;

    of_port_stats_reply_entries_bind(obj, &_entries);
    _entries_ptr = (of_list_port_stats_entry_t *)of_object_dup(&_entries);
    return _entries_ptr;
}

/**
 * Set entries in an object of type of_port_stats_reply.
 * @param obj Pointer to an object of type of_port_stats_reply.
 * @param entries Pointer to the child of type of_list_port_stats_entry_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_port_stats_reply_entries_set(
    of_port_stats_reply_t *obj,
    of_list_port_stats_entry_t *entries)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_PORT_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        cur_len = _END_LEN(obj, offset);
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = entries->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == entries->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(entries, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(entries, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (entries->wire_length_set != NULL) {
        entries->wire_length_set((of_object_t *)entries, entries->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_port_stats_request */
/** \ingroup of_port_stats_request 
 * @{ */

/**
 * Get xid from an object of type of_port_stats_request.
 * @param obj Pointer to an object of type of_port_stats_request.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_port_stats_request_xid_get(
    of_port_stats_request_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_port_stats_request.
 * @param obj Pointer to an object of type of_port_stats_request.
 * @param xid The value to write into the object
 */
void
of_port_stats_request_xid_set(
    of_port_stats_request_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get flags from an object of type of_port_stats_request.
 * @param obj Pointer to an object of type of_port_stats_request.
 * @param flags Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_port_stats_request_flags_get(
    of_port_stats_request_t *obj,
    uint16_t *flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set flags in an object of type of_port_stats_request.
 * @param obj Pointer to an object of type of_port_stats_request.
 * @param flags The value to write into the object
 */
void
of_port_stats_request_flags_set(
    of_port_stats_request_t *obj,
    uint16_t flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get port_no from an object of type of_port_stats_request.
 * @param obj Pointer to an object of type of_port_stats_request.
 * @param port_no Pointer to the child object of type
 * of_port_no_t to be filled out.
 *
 */
void
of_port_stats_request_port_no_get(
    of_port_stats_request_t *obj,
    of_port_no_t *port_no)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_get(ver, wbuf, abs_offset, port_no);
    OF_PORT_NO_VALUE_CHECK(*port_no, ver);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set port_no in an object of type of_port_stats_request.
 * @param obj Pointer to an object of type of_port_stats_request.
 * @param port_no The value to write into the object
 */
void
of_port_stats_request_port_no_set(
    of_port_stats_request_t *obj,
    of_port_no_t port_no)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_set(ver, wbuf, abs_offset, port_no);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_port_status */
/** \ingroup of_port_status 
 * @{ */

/**
 * Get xid from an object of type of_port_status.
 * @param obj Pointer to an object of type of_port_status.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_port_status_xid_get(
    of_port_status_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_STATUS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_port_status.
 * @param obj Pointer to an object of type of_port_status.
 * @param xid The value to write into the object
 */
void
of_port_status_xid_set(
    of_port_status_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_STATUS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get reason from an object of type of_port_status.
 * @param obj Pointer to an object of type of_port_status.
 * @param reason Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_port_status_reason_get(
    of_port_status_t *obj,
    uint8_t *reason)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_STATUS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, reason);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set reason in an object of type of_port_status.
 * @param obj Pointer to an object of type of_port_status.
 * @param reason The value to write into the object
 */
void
of_port_status_reason_set(
    of_port_status_t *obj,
    uint8_t reason)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_STATUS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, reason);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Bind an object of type of_port_desc_t to the parent of type of_port_status for
 * member desc
 * @param obj Pointer to an object of type of_port_status.
 * @param desc Pointer to the child object of type
 * of_port_desc_t to be filled out.
 * \ingroup of_port_status
 *
 * The parameter desc is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_port_status_desc_bind(
    of_port_status_t *obj,
    of_port_desc_t *desc)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_PORT_STATUS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 16;
        cur_len = 48;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        cur_len = 64;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_port_desc_init(desc, obj->version, 0, 1);
    /* Attach to parent */
    desc->parent = (of_object_t *)obj;
    desc->wire_object.wbuf = obj->wire_object.wbuf;
    desc->wire_object.obj_offset = abs_offset;
    desc->wire_object.owned = 0;
    desc->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of desc into a new variable of type of_port_desc_t from
 * a of_port_status instance.
 *
 * @param obj Pointer to the source of type of_port_status_t
 * @returns A pointer to a new instance of type of_port_desc_t whose contents
 * match that of desc from source
 * @returns NULL if an error occurs
 */
of_port_desc_t *
of_port_status_desc_get(of_port_status_t *obj) {
    of_port_desc_t _desc;
    of_port_desc_t *_desc_ptr;

    of_port_status_desc_bind(obj, &_desc);
    _desc_ptr = (of_port_desc_t *)of_object_dup(&_desc);
    return _desc_ptr;
}

/**
 * Set desc in an object of type of_port_status.
 * @param obj Pointer to an object of type of_port_status.
 * @param desc Pointer to the child of type of_port_desc_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
void
of_port_status_desc_set(
    of_port_status_t *obj,
    of_port_desc_t *desc)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_PORT_STATUS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 16;
        cur_len = 48;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        cur_len = 64;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = desc->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == desc->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(desc, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return ;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(desc, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (desc->wire_length_set != NULL) {
        desc->wire_length_set((of_object_t *)desc, desc->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_queue_get_config_reply */
/** \ingroup of_queue_get_config_reply 
 * @{ */

/**
 * Get xid from an object of type of_queue_get_config_reply.
 * @param obj Pointer to an object of type of_queue_get_config_reply.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_queue_get_config_reply_xid_get(
    of_queue_get_config_reply_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_QUEUE_GET_CONFIG_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_queue_get_config_reply.
 * @param obj Pointer to an object of type of_queue_get_config_reply.
 * @param xid The value to write into the object
 */
void
of_queue_get_config_reply_xid_set(
    of_queue_get_config_reply_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_QUEUE_GET_CONFIG_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get port from an object of type of_queue_get_config_reply.
 * @param obj Pointer to an object of type of_queue_get_config_reply.
 * @param port Pointer to the child object of type
 * of_port_no_t to be filled out.
 *
 */
void
of_queue_get_config_reply_port_get(
    of_queue_get_config_reply_t *obj,
    of_port_no_t *port)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_QUEUE_GET_CONFIG_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 8;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_get(ver, wbuf, abs_offset, port);
    OF_PORT_NO_VALUE_CHECK(*port, ver);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set port in an object of type of_queue_get_config_reply.
 * @param obj Pointer to an object of type of_queue_get_config_reply.
 * @param port The value to write into the object
 */
void
of_queue_get_config_reply_port_set(
    of_queue_get_config_reply_t *obj,
    of_port_no_t port)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_QUEUE_GET_CONFIG_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 8;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_set(ver, wbuf, abs_offset, port);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Bind an object of type of_list_packet_queue_t to the parent of type of_queue_get_config_reply for
 * member queues
 * @param obj Pointer to an object of type of_queue_get_config_reply.
 * @param queues Pointer to the child object of type
 * of_list_packet_queue_t to be filled out.
 * \ingroup of_queue_get_config_reply
 *
 * The parameter queues is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_queue_get_config_reply_queues_bind(
    of_queue_get_config_reply_t *obj,
    of_list_packet_queue_t *queues)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_QUEUE_GET_CONFIG_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_packet_queue_init(queues, obj->version, 0, 1);
    /* Attach to parent */
    queues->parent = (of_object_t *)obj;
    queues->wire_object.wbuf = obj->wire_object.wbuf;
    queues->wire_object.obj_offset = abs_offset;
    queues->wire_object.owned = 0;
    queues->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of queues into a new variable of type of_list_packet_queue_t from
 * a of_queue_get_config_reply instance.
 *
 * @param obj Pointer to the source of type of_queue_get_config_reply_t
 * @returns A pointer to a new instance of type of_list_packet_queue_t whose contents
 * match that of queues from source
 * @returns NULL if an error occurs
 */
of_list_packet_queue_t *
of_queue_get_config_reply_queues_get(of_queue_get_config_reply_t *obj) {
    of_list_packet_queue_t _queues;
    of_list_packet_queue_t *_queues_ptr;

    of_queue_get_config_reply_queues_bind(obj, &_queues);
    _queues_ptr = (of_list_packet_queue_t *)of_object_dup(&_queues);
    return _queues_ptr;
}

/**
 * Set queues in an object of type of_queue_get_config_reply.
 * @param obj Pointer to an object of type of_queue_get_config_reply.
 * @param queues Pointer to the child of type of_list_packet_queue_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_queue_get_config_reply_queues_set(
    of_queue_get_config_reply_t *obj,
    of_list_packet_queue_t *queues)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_QUEUE_GET_CONFIG_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = queues->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == queues->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(queues, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(queues, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (queues->wire_length_set != NULL) {
        queues->wire_length_set((of_object_t *)queues, queues->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_queue_get_config_request */
/** \ingroup of_queue_get_config_request 
 * @{ */

/**
 * Get xid from an object of type of_queue_get_config_request.
 * @param obj Pointer to an object of type of_queue_get_config_request.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_queue_get_config_request_xid_get(
    of_queue_get_config_request_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_QUEUE_GET_CONFIG_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_queue_get_config_request.
 * @param obj Pointer to an object of type of_queue_get_config_request.
 * @param xid The value to write into the object
 */
void
of_queue_get_config_request_xid_set(
    of_queue_get_config_request_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_QUEUE_GET_CONFIG_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get port from an object of type of_queue_get_config_request.
 * @param obj Pointer to an object of type of_queue_get_config_request.
 * @param port Pointer to the child object of type
 * of_port_no_t to be filled out.
 *
 */
void
of_queue_get_config_request_port_get(
    of_queue_get_config_request_t *obj,
    of_port_no_t *port)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_QUEUE_GET_CONFIG_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 8;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_get(ver, wbuf, abs_offset, port);
    OF_PORT_NO_VALUE_CHECK(*port, ver);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set port in an object of type of_queue_get_config_request.
 * @param obj Pointer to an object of type of_queue_get_config_request.
 * @param port The value to write into the object
 */
void
of_queue_get_config_request_port_set(
    of_queue_get_config_request_t *obj,
    of_port_no_t port)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_QUEUE_GET_CONFIG_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 8;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_set(ver, wbuf, abs_offset, port);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_queue_stats_reply */
/** \ingroup of_queue_stats_reply 
 * @{ */

/**
 * Get xid from an object of type of_queue_stats_reply.
 * @param obj Pointer to an object of type of_queue_stats_reply.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_queue_stats_reply_xid_get(
    of_queue_stats_reply_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_QUEUE_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_queue_stats_reply.
 * @param obj Pointer to an object of type of_queue_stats_reply.
 * @param xid The value to write into the object
 */
void
of_queue_stats_reply_xid_set(
    of_queue_stats_reply_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_QUEUE_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get flags from an object of type of_queue_stats_reply.
 * @param obj Pointer to an object of type of_queue_stats_reply.
 * @param flags Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_queue_stats_reply_flags_get(
    of_queue_stats_reply_t *obj,
    uint16_t *flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_QUEUE_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set flags in an object of type of_queue_stats_reply.
 * @param obj Pointer to an object of type of_queue_stats_reply.
 * @param flags The value to write into the object
 */
void
of_queue_stats_reply_flags_set(
    of_queue_stats_reply_t *obj,
    uint16_t flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_QUEUE_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Bind an object of type of_list_queue_stats_entry_t to the parent of type of_queue_stats_reply for
 * member entries
 * @param obj Pointer to an object of type of_queue_stats_reply.
 * @param entries Pointer to the child object of type
 * of_list_queue_stats_entry_t to be filled out.
 * \ingroup of_queue_stats_reply
 *
 * The parameter entries is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_queue_stats_reply_entries_bind(
    of_queue_stats_reply_t *obj,
    of_list_queue_stats_entry_t *entries)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_QUEUE_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        cur_len = _END_LEN(obj, offset);
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_queue_stats_entry_init(entries, obj->version, 0, 1);
    /* Attach to parent */
    entries->parent = (of_object_t *)obj;
    entries->wire_object.wbuf = obj->wire_object.wbuf;
    entries->wire_object.obj_offset = abs_offset;
    entries->wire_object.owned = 0;
    entries->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of entries into a new variable of type of_list_queue_stats_entry_t from
 * a of_queue_stats_reply instance.
 *
 * @param obj Pointer to the source of type of_queue_stats_reply_t
 * @returns A pointer to a new instance of type of_list_queue_stats_entry_t whose contents
 * match that of entries from source
 * @returns NULL if an error occurs
 */
of_list_queue_stats_entry_t *
of_queue_stats_reply_entries_get(of_queue_stats_reply_t *obj) {
    of_list_queue_stats_entry_t _entries;
    of_list_queue_stats_entry_t *_entries_ptr;

    of_queue_stats_reply_entries_bind(obj, &_entries);
    _entries_ptr = (of_list_queue_stats_entry_t *)of_object_dup(&_entries);
    return _entries_ptr;
}

/**
 * Set entries in an object of type of_queue_stats_reply.
 * @param obj Pointer to an object of type of_queue_stats_reply.
 * @param entries Pointer to the child of type of_list_queue_stats_entry_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_queue_stats_reply_entries_set(
    of_queue_stats_reply_t *obj,
    of_list_queue_stats_entry_t *entries)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_QUEUE_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        cur_len = _END_LEN(obj, offset);
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = entries->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == entries->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(entries, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(entries, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (entries->wire_length_set != NULL) {
        entries->wire_length_set((of_object_t *)entries, entries->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_queue_stats_request */
/** \ingroup of_queue_stats_request 
 * @{ */

/**
 * Get xid from an object of type of_queue_stats_request.
 * @param obj Pointer to an object of type of_queue_stats_request.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_queue_stats_request_xid_get(
    of_queue_stats_request_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_QUEUE_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_queue_stats_request.
 * @param obj Pointer to an object of type of_queue_stats_request.
 * @param xid The value to write into the object
 */
void
of_queue_stats_request_xid_set(
    of_queue_stats_request_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_QUEUE_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get flags from an object of type of_queue_stats_request.
 * @param obj Pointer to an object of type of_queue_stats_request.
 * @param flags Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_queue_stats_request_flags_get(
    of_queue_stats_request_t *obj,
    uint16_t *flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_QUEUE_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set flags in an object of type of_queue_stats_request.
 * @param obj Pointer to an object of type of_queue_stats_request.
 * @param flags The value to write into the object
 */
void
of_queue_stats_request_flags_set(
    of_queue_stats_request_t *obj,
    uint16_t flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_QUEUE_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get port_no from an object of type of_queue_stats_request.
 * @param obj Pointer to an object of type of_queue_stats_request.
 * @param port_no Pointer to the child object of type
 * of_port_no_t to be filled out.
 *
 */
void
of_queue_stats_request_port_no_get(
    of_queue_stats_request_t *obj,
    of_port_no_t *port_no)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_QUEUE_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_get(ver, wbuf, abs_offset, port_no);
    OF_PORT_NO_VALUE_CHECK(*port_no, ver);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set port_no in an object of type of_queue_stats_request.
 * @param obj Pointer to an object of type of_queue_stats_request.
 * @param port_no The value to write into the object
 */
void
of_queue_stats_request_port_no_set(
    of_queue_stats_request_t *obj,
    of_port_no_t port_no)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_QUEUE_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_set(ver, wbuf, abs_offset, port_no);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get queue_id from an object of type of_queue_stats_request.
 * @param obj Pointer to an object of type of_queue_stats_request.
 * @param queue_id Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_queue_stats_request_queue_id_get(
    of_queue_stats_request_t *obj,
    uint32_t *queue_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_QUEUE_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 16;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 20;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, queue_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set queue_id in an object of type of_queue_stats_request.
 * @param obj Pointer to an object of type of_queue_stats_request.
 * @param queue_id The value to write into the object
 */
void
of_queue_stats_request_queue_id_set(
    of_queue_stats_request_t *obj,
    uint32_t queue_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_QUEUE_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 16;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 20;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, queue_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_role_reply */
/** \ingroup of_role_reply 
 * @{ */

/**
 * Get xid from an object of type of_role_reply.
 * @param obj Pointer to an object of type of_role_reply.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_role_reply_xid_get(
    of_role_reply_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ROLE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_role_reply.
 * @param obj Pointer to an object of type of_role_reply.
 * @param xid The value to write into the object
 */
void
of_role_reply_xid_set(
    of_role_reply_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ROLE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get data from an object of type of_role_reply.
 * @param obj Pointer to an object of type of_role_reply.
 * @param data Pointer to the child object of type
 * of_octets_t to be filled out.
 *
 */
void
of_role_reply_data_get(
    of_role_reply_t *obj,
    of_octets_t *data)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_ROLE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);
    ASSERT(cur_len + abs_offset <= WBUF_CURRENT_BYTES(wbuf));
    data->bytes = cur_len;
    data->data = OF_WIRE_BUFFER_INDEX(wbuf, abs_offset);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set data in an object of type of_role_reply.
 * @param obj Pointer to an object of type of_role_reply.
 * @param data The value to write into the object
 */
int WARN_UNUSED_RESULT
of_role_reply_data_set(
    of_role_reply_t *obj,
    of_octets_t *data)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_ROLE_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);
    new_len = data->bytes;
    of_wire_buffer_grow(wbuf, abs_offset + (new_len - cur_len));
    of_wire_buffer_octets_data_set(wbuf, abs_offset, data, cur_len);

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_role_request */
/** \ingroup of_role_request 
 * @{ */

/**
 * Get xid from an object of type of_role_request.
 * @param obj Pointer to an object of type of_role_request.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_role_request_xid_get(
    of_role_request_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ROLE_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_role_request.
 * @param obj Pointer to an object of type of_role_request.
 * @param xid The value to write into the object
 */
void
of_role_request_xid_set(
    of_role_request_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ROLE_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get role from an object of type of_role_request.
 * @param obj Pointer to an object of type of_role_request.
 * @param role Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_role_request_role_get(
    of_role_request_t *obj,
    uint32_t *role)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ROLE_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, role);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set role in an object of type of_role_request.
 * @param obj Pointer to an object of type of_role_request.
 * @param role The value to write into the object
 */
void
of_role_request_role_set(
    of_role_request_t *obj,
    uint32_t role)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ROLE_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, role);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get generation_id from an object of type of_role_request.
 * @param obj Pointer to an object of type of_role_request.
 * @param generation_id Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_role_request_generation_id_get(
    of_role_request_t *obj,
    uint64_t *generation_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ROLE_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, generation_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set generation_id in an object of type of_role_request.
 * @param obj Pointer to an object of type of_role_request.
 * @param generation_id The value to write into the object
 */
void
of_role_request_generation_id_set(
    of_role_request_t *obj,
    uint64_t generation_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ROLE_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, generation_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_set_config */
/** \ingroup of_set_config 
 * @{ */

/**
 * Get xid from an object of type of_set_config.
 * @param obj Pointer to an object of type of_set_config.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_set_config_xid_get(
    of_set_config_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_SET_CONFIG);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_set_config.
 * @param obj Pointer to an object of type of_set_config.
 * @param xid The value to write into the object
 */
void
of_set_config_xid_set(
    of_set_config_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_SET_CONFIG);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get flags from an object of type of_set_config.
 * @param obj Pointer to an object of type of_set_config.
 * @param flags Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_set_config_flags_get(
    of_set_config_t *obj,
    uint16_t *flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_SET_CONFIG);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set flags in an object of type of_set_config.
 * @param obj Pointer to an object of type of_set_config.
 * @param flags The value to write into the object
 */
void
of_set_config_flags_set(
    of_set_config_t *obj,
    uint16_t flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_SET_CONFIG);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get miss_send_len from an object of type of_set_config.
 * @param obj Pointer to an object of type of_set_config.
 * @param miss_send_len Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_set_config_miss_send_len_get(
    of_set_config_t *obj,
    uint16_t *miss_send_len)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_SET_CONFIG);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, miss_send_len);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set miss_send_len in an object of type of_set_config.
 * @param obj Pointer to an object of type of_set_config.
 * @param miss_send_len The value to write into the object
 */
void
of_set_config_miss_send_len_set(
    of_set_config_t *obj,
    uint16_t miss_send_len)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_SET_CONFIG);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, miss_send_len);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_table_features_stats_reply */
/** \ingroup of_table_features_stats_reply 
 * @{ */

/**
 * Get xid from an object of type of_table_features_stats_reply.
 * @param obj Pointer to an object of type of_table_features_stats_reply.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_table_features_stats_reply_xid_get(
    of_table_features_stats_reply_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_FEATURES_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_table_features_stats_reply.
 * @param obj Pointer to an object of type of_table_features_stats_reply.
 * @param xid The value to write into the object
 */
void
of_table_features_stats_reply_xid_set(
    of_table_features_stats_reply_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_FEATURES_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get flags from an object of type of_table_features_stats_reply.
 * @param obj Pointer to an object of type of_table_features_stats_reply.
 * @param flags Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_table_features_stats_reply_flags_get(
    of_table_features_stats_reply_t *obj,
    uint16_t *flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_FEATURES_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set flags in an object of type of_table_features_stats_reply.
 * @param obj Pointer to an object of type of_table_features_stats_reply.
 * @param flags The value to write into the object
 */
void
of_table_features_stats_reply_flags_set(
    of_table_features_stats_reply_t *obj,
    uint16_t flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_FEATURES_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Bind an object of type of_list_table_features_t to the parent of type of_table_features_stats_reply for
 * member entries
 * @param obj Pointer to an object of type of_table_features_stats_reply.
 * @param entries Pointer to the child object of type
 * of_list_table_features_t to be filled out.
 * \ingroup of_table_features_stats_reply
 *
 * The parameter entries is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_table_features_stats_reply_entries_bind(
    of_table_features_stats_reply_t *obj,
    of_list_table_features_t *entries)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_TABLE_FEATURES_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 16;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_table_features_init(entries, obj->version, 0, 1);
    /* Attach to parent */
    entries->parent = (of_object_t *)obj;
    entries->wire_object.wbuf = obj->wire_object.wbuf;
    entries->wire_object.obj_offset = abs_offset;
    entries->wire_object.owned = 0;
    entries->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of entries into a new variable of type of_list_table_features_t from
 * a of_table_features_stats_reply instance.
 *
 * @param obj Pointer to the source of type of_table_features_stats_reply_t
 * @returns A pointer to a new instance of type of_list_table_features_t whose contents
 * match that of entries from source
 * @returns NULL if an error occurs
 */
of_list_table_features_t *
of_table_features_stats_reply_entries_get(of_table_features_stats_reply_t *obj) {
    of_list_table_features_t _entries;
    of_list_table_features_t *_entries_ptr;

    of_table_features_stats_reply_entries_bind(obj, &_entries);
    _entries_ptr = (of_list_table_features_t *)of_object_dup(&_entries);
    return _entries_ptr;
}

/**
 * Set entries in an object of type of_table_features_stats_reply.
 * @param obj Pointer to an object of type of_table_features_stats_reply.
 * @param entries Pointer to the child of type of_list_table_features_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_table_features_stats_reply_entries_set(
    of_table_features_stats_reply_t *obj,
    of_list_table_features_t *entries)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_TABLE_FEATURES_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 16;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = entries->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == entries->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(entries, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(entries, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (entries->wire_length_set != NULL) {
        entries->wire_length_set((of_object_t *)entries, entries->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_table_features_stats_request */
/** \ingroup of_table_features_stats_request 
 * @{ */

/**
 * Get xid from an object of type of_table_features_stats_request.
 * @param obj Pointer to an object of type of_table_features_stats_request.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_table_features_stats_request_xid_get(
    of_table_features_stats_request_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_FEATURES_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_table_features_stats_request.
 * @param obj Pointer to an object of type of_table_features_stats_request.
 * @param xid The value to write into the object
 */
void
of_table_features_stats_request_xid_set(
    of_table_features_stats_request_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_FEATURES_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get flags from an object of type of_table_features_stats_request.
 * @param obj Pointer to an object of type of_table_features_stats_request.
 * @param flags Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_table_features_stats_request_flags_get(
    of_table_features_stats_request_t *obj,
    uint16_t *flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_FEATURES_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set flags in an object of type of_table_features_stats_request.
 * @param obj Pointer to an object of type of_table_features_stats_request.
 * @param flags The value to write into the object
 */
void
of_table_features_stats_request_flags_set(
    of_table_features_stats_request_t *obj,
    uint16_t flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_FEATURES_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Bind an object of type of_list_table_features_t to the parent of type of_table_features_stats_request for
 * member entries
 * @param obj Pointer to an object of type of_table_features_stats_request.
 * @param entries Pointer to the child object of type
 * of_list_table_features_t to be filled out.
 * \ingroup of_table_features_stats_request
 *
 * The parameter entries is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_table_features_stats_request_entries_bind(
    of_table_features_stats_request_t *obj,
    of_list_table_features_t *entries)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_TABLE_FEATURES_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 16;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_table_features_init(entries, obj->version, 0, 1);
    /* Attach to parent */
    entries->parent = (of_object_t *)obj;
    entries->wire_object.wbuf = obj->wire_object.wbuf;
    entries->wire_object.obj_offset = abs_offset;
    entries->wire_object.owned = 0;
    entries->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of entries into a new variable of type of_list_table_features_t from
 * a of_table_features_stats_request instance.
 *
 * @param obj Pointer to the source of type of_table_features_stats_request_t
 * @returns A pointer to a new instance of type of_list_table_features_t whose contents
 * match that of entries from source
 * @returns NULL if an error occurs
 */
of_list_table_features_t *
of_table_features_stats_request_entries_get(of_table_features_stats_request_t *obj) {
    of_list_table_features_t _entries;
    of_list_table_features_t *_entries_ptr;

    of_table_features_stats_request_entries_bind(obj, &_entries);
    _entries_ptr = (of_list_table_features_t *)of_object_dup(&_entries);
    return _entries_ptr;
}

/**
 * Set entries in an object of type of_table_features_stats_request.
 * @param obj Pointer to an object of type of_table_features_stats_request.
 * @param entries Pointer to the child of type of_list_table_features_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_table_features_stats_request_entries_set(
    of_table_features_stats_request_t *obj,
    of_list_table_features_t *entries)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_TABLE_FEATURES_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 16;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = entries->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == entries->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(entries, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(entries, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (entries->wire_length_set != NULL) {
        entries->wire_length_set((of_object_t *)entries, entries->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_table_mod */
/** \ingroup of_table_mod 
 * @{ */

/**
 * Get xid from an object of type of_table_mod.
 * @param obj Pointer to an object of type of_table_mod.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_table_mod_xid_get(
    of_table_mod_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_MOD);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_table_mod.
 * @param obj Pointer to an object of type of_table_mod.
 * @param xid The value to write into the object
 */
void
of_table_mod_xid_set(
    of_table_mod_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_MOD);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get table_id from an object of type of_table_mod.
 * @param obj Pointer to an object of type of_table_mod.
 * @param table_id Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_table_mod_table_id_get(
    of_table_mod_t *obj,
    uint8_t *table_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_MOD);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, table_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set table_id in an object of type of_table_mod.
 * @param obj Pointer to an object of type of_table_mod.
 * @param table_id The value to write into the object
 */
void
of_table_mod_table_id_set(
    of_table_mod_t *obj,
    uint8_t table_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_MOD);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, table_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get config from an object of type of_table_mod.
 * @param obj Pointer to an object of type of_table_mod.
 * @param config Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_table_mod_config_get(
    of_table_mod_t *obj,
    uint32_t *config)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_MOD);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, config);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set config in an object of type of_table_mod.
 * @param obj Pointer to an object of type of_table_mod.
 * @param config The value to write into the object
 */
void
of_table_mod_config_set(
    of_table_mod_t *obj,
    uint32_t config)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_MOD);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, config);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_table_stats_reply */
/** \ingroup of_table_stats_reply 
 * @{ */

/**
 * Get xid from an object of type of_table_stats_reply.
 * @param obj Pointer to an object of type of_table_stats_reply.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_table_stats_reply_xid_get(
    of_table_stats_reply_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_table_stats_reply.
 * @param obj Pointer to an object of type of_table_stats_reply.
 * @param xid The value to write into the object
 */
void
of_table_stats_reply_xid_set(
    of_table_stats_reply_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get flags from an object of type of_table_stats_reply.
 * @param obj Pointer to an object of type of_table_stats_reply.
 * @param flags Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_table_stats_reply_flags_get(
    of_table_stats_reply_t *obj,
    uint16_t *flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set flags in an object of type of_table_stats_reply.
 * @param obj Pointer to an object of type of_table_stats_reply.
 * @param flags The value to write into the object
 */
void
of_table_stats_reply_flags_set(
    of_table_stats_reply_t *obj,
    uint16_t flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Bind an object of type of_list_table_stats_entry_t to the parent of type of_table_stats_reply for
 * member entries
 * @param obj Pointer to an object of type of_table_stats_reply.
 * @param entries Pointer to the child object of type
 * of_list_table_stats_entry_t to be filled out.
 * \ingroup of_table_stats_reply
 *
 * The parameter entries is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_table_stats_reply_entries_bind(
    of_table_stats_reply_t *obj,
    of_list_table_stats_entry_t *entries)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_TABLE_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        cur_len = _END_LEN(obj, offset);
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_table_stats_entry_init(entries, obj->version, 0, 1);
    /* Attach to parent */
    entries->parent = (of_object_t *)obj;
    entries->wire_object.wbuf = obj->wire_object.wbuf;
    entries->wire_object.obj_offset = abs_offset;
    entries->wire_object.owned = 0;
    entries->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of entries into a new variable of type of_list_table_stats_entry_t from
 * a of_table_stats_reply instance.
 *
 * @param obj Pointer to the source of type of_table_stats_reply_t
 * @returns A pointer to a new instance of type of_list_table_stats_entry_t whose contents
 * match that of entries from source
 * @returns NULL if an error occurs
 */
of_list_table_stats_entry_t *
of_table_stats_reply_entries_get(of_table_stats_reply_t *obj) {
    of_list_table_stats_entry_t _entries;
    of_list_table_stats_entry_t *_entries_ptr;

    of_table_stats_reply_entries_bind(obj, &_entries);
    _entries_ptr = (of_list_table_stats_entry_t *)of_object_dup(&_entries);
    return _entries_ptr;
}

/**
 * Set entries in an object of type of_table_stats_reply.
 * @param obj Pointer to an object of type of_table_stats_reply.
 * @param entries Pointer to the child of type of_list_table_stats_entry_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_table_stats_reply_entries_set(
    of_table_stats_reply_t *obj,
    of_list_table_stats_entry_t *entries)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_TABLE_STATS_REPLY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        cur_len = _END_LEN(obj, offset);
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = entries->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == entries->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(entries, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(entries, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (entries->wire_length_set != NULL) {
        entries->wire_length_set((of_object_t *)entries, entries->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_table_stats_request */
/** \ingroup of_table_stats_request 
 * @{ */

/**
 * Get xid from an object of type of_table_stats_request.
 * @param obj Pointer to an object of type of_table_stats_request.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_table_stats_request_xid_get(
    of_table_stats_request_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_table_stats_request.
 * @param obj Pointer to an object of type of_table_stats_request.
 * @param xid The value to write into the object
 */
void
of_table_stats_request_xid_set(
    of_table_stats_request_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get flags from an object of type of_table_stats_request.
 * @param obj Pointer to an object of type of_table_stats_request.
 * @param flags Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_table_stats_request_flags_get(
    of_table_stats_request_t *obj,
    uint16_t *flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set flags in an object of type of_table_stats_request.
 * @param obj Pointer to an object of type of_table_stats_request.
 * @param flags The value to write into the object
 */
void
of_table_stats_request_flags_set(
    of_table_stats_request_t *obj,
    uint16_t flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_STATS_REQUEST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_action_bsn_mirror */
/** \ingroup of_action_bsn_mirror 
 * @{ */

/**
 * Get experimenter from an object of type of_action_bsn_mirror.
 * @param obj Pointer to an object of type of_action_bsn_mirror.
 * @param experimenter Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_action_bsn_mirror_experimenter_get(
    of_action_bsn_mirror_t *obj,
    uint32_t *experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_BSN_MIRROR);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set experimenter in an object of type of_action_bsn_mirror.
 * @param obj Pointer to an object of type of_action_bsn_mirror.
 * @param experimenter The value to write into the object
 */
void
of_action_bsn_mirror_experimenter_set(
    of_action_bsn_mirror_t *obj,
    uint32_t experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_BSN_MIRROR);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get subtype from an object of type of_action_bsn_mirror.
 * @param obj Pointer to an object of type of_action_bsn_mirror.
 * @param subtype Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_action_bsn_mirror_subtype_get(
    of_action_bsn_mirror_t *obj,
    uint32_t *subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_BSN_MIRROR);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set subtype in an object of type of_action_bsn_mirror.
 * @param obj Pointer to an object of type of_action_bsn_mirror.
 * @param subtype The value to write into the object
 */
void
of_action_bsn_mirror_subtype_set(
    of_action_bsn_mirror_t *obj,
    uint32_t subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_BSN_MIRROR);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get dest_port from an object of type of_action_bsn_mirror.
 * @param obj Pointer to an object of type of_action_bsn_mirror.
 * @param dest_port Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_action_bsn_mirror_dest_port_get(
    of_action_bsn_mirror_t *obj,
    uint32_t *dest_port)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_BSN_MIRROR);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, dest_port);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set dest_port in an object of type of_action_bsn_mirror.
 * @param obj Pointer to an object of type of_action_bsn_mirror.
 * @param dest_port The value to write into the object
 */
void
of_action_bsn_mirror_dest_port_set(
    of_action_bsn_mirror_t *obj,
    uint32_t dest_port)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_BSN_MIRROR);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, dest_port);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get vlan_tag from an object of type of_action_bsn_mirror.
 * @param obj Pointer to an object of type of_action_bsn_mirror.
 * @param vlan_tag Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_action_bsn_mirror_vlan_tag_get(
    of_action_bsn_mirror_t *obj,
    uint32_t *vlan_tag)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_BSN_MIRROR);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, vlan_tag);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set vlan_tag in an object of type of_action_bsn_mirror.
 * @param obj Pointer to an object of type of_action_bsn_mirror.
 * @param vlan_tag The value to write into the object
 */
void
of_action_bsn_mirror_vlan_tag_set(
    of_action_bsn_mirror_t *obj,
    uint32_t vlan_tag)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_BSN_MIRROR);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, vlan_tag);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get copy_stage from an object of type of_action_bsn_mirror.
 * @param obj Pointer to an object of type of_action_bsn_mirror.
 * @param copy_stage Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_action_bsn_mirror_copy_stage_get(
    of_action_bsn_mirror_t *obj,
    uint8_t *copy_stage)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_BSN_MIRROR);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 20;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, copy_stage);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set copy_stage in an object of type of_action_bsn_mirror.
 * @param obj Pointer to an object of type of_action_bsn_mirror.
 * @param copy_stage The value to write into the object
 */
void
of_action_bsn_mirror_copy_stage_set(
    of_action_bsn_mirror_t *obj,
    uint8_t copy_stage)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_BSN_MIRROR);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 20;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, copy_stage);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_action_bsn_set_tunnel_dst */
/** \ingroup of_action_bsn_set_tunnel_dst 
 * @{ */

/**
 * Get experimenter from an object of type of_action_bsn_set_tunnel_dst.
 * @param obj Pointer to an object of type of_action_bsn_set_tunnel_dst.
 * @param experimenter Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_action_bsn_set_tunnel_dst_experimenter_get(
    of_action_bsn_set_tunnel_dst_t *obj,
    uint32_t *experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_BSN_SET_TUNNEL_DST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set experimenter in an object of type of_action_bsn_set_tunnel_dst.
 * @param obj Pointer to an object of type of_action_bsn_set_tunnel_dst.
 * @param experimenter The value to write into the object
 */
void
of_action_bsn_set_tunnel_dst_experimenter_set(
    of_action_bsn_set_tunnel_dst_t *obj,
    uint32_t experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_BSN_SET_TUNNEL_DST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get subtype from an object of type of_action_bsn_set_tunnel_dst.
 * @param obj Pointer to an object of type of_action_bsn_set_tunnel_dst.
 * @param subtype Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_action_bsn_set_tunnel_dst_subtype_get(
    of_action_bsn_set_tunnel_dst_t *obj,
    uint32_t *subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_BSN_SET_TUNNEL_DST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set subtype in an object of type of_action_bsn_set_tunnel_dst.
 * @param obj Pointer to an object of type of_action_bsn_set_tunnel_dst.
 * @param subtype The value to write into the object
 */
void
of_action_bsn_set_tunnel_dst_subtype_set(
    of_action_bsn_set_tunnel_dst_t *obj,
    uint32_t subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_BSN_SET_TUNNEL_DST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get dst from an object of type of_action_bsn_set_tunnel_dst.
 * @param obj Pointer to an object of type of_action_bsn_set_tunnel_dst.
 * @param dst Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_action_bsn_set_tunnel_dst_dst_get(
    of_action_bsn_set_tunnel_dst_t *obj,
    uint32_t *dst)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_BSN_SET_TUNNEL_DST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, dst);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set dst in an object of type of_action_bsn_set_tunnel_dst.
 * @param obj Pointer to an object of type of_action_bsn_set_tunnel_dst.
 * @param dst The value to write into the object
 */
void
of_action_bsn_set_tunnel_dst_dst_set(
    of_action_bsn_set_tunnel_dst_t *obj,
    uint32_t dst)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_BSN_SET_TUNNEL_DST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, dst);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_action_copy_ttl_in */
/** \ingroup of_action_copy_ttl_in 
 * @{ */

/** @} */

/* Unified accessor functions for of_action_copy_ttl_out */
/** \ingroup of_action_copy_ttl_out 
 * @{ */

/** @} */

/* Unified accessor functions for of_action_dec_mpls_ttl */
/** \ingroup of_action_dec_mpls_ttl 
 * @{ */

/** @} */

/* Unified accessor functions for of_action_dec_nw_ttl */
/** \ingroup of_action_dec_nw_ttl 
 * @{ */

/** @} */

/* Unified accessor functions for of_action_enqueue */
/** \ingroup of_action_enqueue 
 * @{ */

/**
 * Get port from an object of type of_action_enqueue.
 * @param obj Pointer to an object of type of_action_enqueue.
 * @param port Pointer to the child object of type
 * of_port_no_t to be filled out.
 *
 */
void
of_action_enqueue_port_get(
    of_action_enqueue_t *obj,
    of_port_no_t *port)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_ENQUEUE);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_get(ver, wbuf, abs_offset, port);
    OF_PORT_NO_VALUE_CHECK(*port, ver);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set port in an object of type of_action_enqueue.
 * @param obj Pointer to an object of type of_action_enqueue.
 * @param port The value to write into the object
 */
void
of_action_enqueue_port_set(
    of_action_enqueue_t *obj,
    of_port_no_t port)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_ENQUEUE);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_set(ver, wbuf, abs_offset, port);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get queue_id from an object of type of_action_enqueue.
 * @param obj Pointer to an object of type of_action_enqueue.
 * @param queue_id Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_action_enqueue_queue_id_get(
    of_action_enqueue_t *obj,
    uint32_t *queue_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_ENQUEUE);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, queue_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set queue_id in an object of type of_action_enqueue.
 * @param obj Pointer to an object of type of_action_enqueue.
 * @param queue_id The value to write into the object
 */
void
of_action_enqueue_queue_id_set(
    of_action_enqueue_t *obj,
    uint32_t queue_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_ENQUEUE);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, queue_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_action_experimenter */
/** \ingroup of_action_experimenter 
 * @{ */

/**
 * Get experimenter from an object of type of_action_experimenter.
 * @param obj Pointer to an object of type of_action_experimenter.
 * @param experimenter Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_action_experimenter_experimenter_get(
    of_action_experimenter_t *obj,
    uint32_t *experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_EXPERIMENTER);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set experimenter in an object of type of_action_experimenter.
 * @param obj Pointer to an object of type of_action_experimenter.
 * @param experimenter The value to write into the object
 */
void
of_action_experimenter_experimenter_set(
    of_action_experimenter_t *obj,
    uint32_t experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_EXPERIMENTER);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get data from an object of type of_action_experimenter.
 * @param obj Pointer to an object of type of_action_experimenter.
 * @param data Pointer to the child object of type
 * of_octets_t to be filled out.
 *
 */
void
of_action_experimenter_data_get(
    of_action_experimenter_t *obj,
    of_octets_t *data)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_ACTION_EXPERIMENTER);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);
    ASSERT(cur_len + abs_offset <= WBUF_CURRENT_BYTES(wbuf));
    data->bytes = cur_len;
    data->data = OF_WIRE_BUFFER_INDEX(wbuf, abs_offset);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set data in an object of type of_action_experimenter.
 * @param obj Pointer to an object of type of_action_experimenter.
 * @param data The value to write into the object
 */
int WARN_UNUSED_RESULT
of_action_experimenter_data_set(
    of_action_experimenter_t *obj,
    of_octets_t *data)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_ACTION_EXPERIMENTER);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);
    new_len = data->bytes;
    of_wire_buffer_grow(wbuf, abs_offset + (new_len - cur_len));
    of_wire_buffer_octets_data_set(wbuf, abs_offset, data, cur_len);

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_action_group */
/** \ingroup of_action_group 
 * @{ */

/**
 * Get group_id from an object of type of_action_group.
 * @param obj Pointer to an object of type of_action_group.
 * @param group_id Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_action_group_group_id_get(
    of_action_group_t *obj,
    uint32_t *group_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_GROUP);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, group_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set group_id in an object of type of_action_group.
 * @param obj Pointer to an object of type of_action_group.
 * @param group_id The value to write into the object
 */
void
of_action_group_group_id_set(
    of_action_group_t *obj,
    uint32_t group_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_GROUP);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, group_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_action_header */
/** \ingroup of_action_header 
 * @{ */

/** @} */

/* Unified accessor functions for of_action_id_bsn_mirror */
/** \ingroup of_action_id_bsn_mirror 
 * @{ */

/**
 * Get experimenter from an object of type of_action_id_bsn_mirror.
 * @param obj Pointer to an object of type of_action_id_bsn_mirror.
 * @param experimenter Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_action_id_bsn_mirror_experimenter_get(
    of_action_id_bsn_mirror_t *obj,
    uint32_t *experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_ID_BSN_MIRROR);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set experimenter in an object of type of_action_id_bsn_mirror.
 * @param obj Pointer to an object of type of_action_id_bsn_mirror.
 * @param experimenter The value to write into the object
 */
void
of_action_id_bsn_mirror_experimenter_set(
    of_action_id_bsn_mirror_t *obj,
    uint32_t experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_ID_BSN_MIRROR);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get subtype from an object of type of_action_id_bsn_mirror.
 * @param obj Pointer to an object of type of_action_id_bsn_mirror.
 * @param subtype Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_action_id_bsn_mirror_subtype_get(
    of_action_id_bsn_mirror_t *obj,
    uint32_t *subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_ID_BSN_MIRROR);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set subtype in an object of type of_action_id_bsn_mirror.
 * @param obj Pointer to an object of type of_action_id_bsn_mirror.
 * @param subtype The value to write into the object
 */
void
of_action_id_bsn_mirror_subtype_set(
    of_action_id_bsn_mirror_t *obj,
    uint32_t subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_ID_BSN_MIRROR);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_action_id_bsn_set_tunnel_dst */
/** \ingroup of_action_id_bsn_set_tunnel_dst 
 * @{ */

/**
 * Get experimenter from an object of type of_action_id_bsn_set_tunnel_dst.
 * @param obj Pointer to an object of type of_action_id_bsn_set_tunnel_dst.
 * @param experimenter Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_action_id_bsn_set_tunnel_dst_experimenter_get(
    of_action_id_bsn_set_tunnel_dst_t *obj,
    uint32_t *experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_ID_BSN_SET_TUNNEL_DST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set experimenter in an object of type of_action_id_bsn_set_tunnel_dst.
 * @param obj Pointer to an object of type of_action_id_bsn_set_tunnel_dst.
 * @param experimenter The value to write into the object
 */
void
of_action_id_bsn_set_tunnel_dst_experimenter_set(
    of_action_id_bsn_set_tunnel_dst_t *obj,
    uint32_t experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_ID_BSN_SET_TUNNEL_DST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get subtype from an object of type of_action_id_bsn_set_tunnel_dst.
 * @param obj Pointer to an object of type of_action_id_bsn_set_tunnel_dst.
 * @param subtype Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_action_id_bsn_set_tunnel_dst_subtype_get(
    of_action_id_bsn_set_tunnel_dst_t *obj,
    uint32_t *subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_ID_BSN_SET_TUNNEL_DST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set subtype in an object of type of_action_id_bsn_set_tunnel_dst.
 * @param obj Pointer to an object of type of_action_id_bsn_set_tunnel_dst.
 * @param subtype The value to write into the object
 */
void
of_action_id_bsn_set_tunnel_dst_subtype_set(
    of_action_id_bsn_set_tunnel_dst_t *obj,
    uint32_t subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_ID_BSN_SET_TUNNEL_DST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_action_id_copy_ttl_in */
/** \ingroup of_action_id_copy_ttl_in 
 * @{ */

/** @} */

/* Unified accessor functions for of_action_id_copy_ttl_out */
/** \ingroup of_action_id_copy_ttl_out 
 * @{ */

/** @} */

/* Unified accessor functions for of_action_id_dec_mpls_ttl */
/** \ingroup of_action_id_dec_mpls_ttl 
 * @{ */

/** @} */

/* Unified accessor functions for of_action_id_dec_nw_ttl */
/** \ingroup of_action_id_dec_nw_ttl 
 * @{ */

/** @} */

/* Unified accessor functions for of_action_id_experimenter */
/** \ingroup of_action_id_experimenter 
 * @{ */

/** @} */

/* Unified accessor functions for of_action_id_group */
/** \ingroup of_action_id_group 
 * @{ */

/** @} */

/* Unified accessor functions for of_action_id_header */
/** \ingroup of_action_id_header 
 * @{ */

/** @} */

/* Unified accessor functions for of_action_id_nicira_dec_ttl */
/** \ingroup of_action_id_nicira_dec_ttl 
 * @{ */

/**
 * Get experimenter from an object of type of_action_id_nicira_dec_ttl.
 * @param obj Pointer to an object of type of_action_id_nicira_dec_ttl.
 * @param experimenter Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_action_id_nicira_dec_ttl_experimenter_get(
    of_action_id_nicira_dec_ttl_t *obj,
    uint32_t *experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_ID_NICIRA_DEC_TTL);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set experimenter in an object of type of_action_id_nicira_dec_ttl.
 * @param obj Pointer to an object of type of_action_id_nicira_dec_ttl.
 * @param experimenter The value to write into the object
 */
void
of_action_id_nicira_dec_ttl_experimenter_set(
    of_action_id_nicira_dec_ttl_t *obj,
    uint32_t experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_ID_NICIRA_DEC_TTL);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get subtype from an object of type of_action_id_nicira_dec_ttl.
 * @param obj Pointer to an object of type of_action_id_nicira_dec_ttl.
 * @param subtype Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_action_id_nicira_dec_ttl_subtype_get(
    of_action_id_nicira_dec_ttl_t *obj,
    uint16_t *subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_ID_NICIRA_DEC_TTL);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set subtype in an object of type of_action_id_nicira_dec_ttl.
 * @param obj Pointer to an object of type of_action_id_nicira_dec_ttl.
 * @param subtype The value to write into the object
 */
void
of_action_id_nicira_dec_ttl_subtype_set(
    of_action_id_nicira_dec_ttl_t *obj,
    uint16_t subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_ID_NICIRA_DEC_TTL);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_action_id_output */
/** \ingroup of_action_id_output 
 * @{ */

/** @} */

/* Unified accessor functions for of_action_id_pop_mpls */
/** \ingroup of_action_id_pop_mpls 
 * @{ */

/** @} */

/* Unified accessor functions for of_action_id_pop_pbb */
/** \ingroup of_action_id_pop_pbb 
 * @{ */

/** @} */

/* Unified accessor functions for of_action_id_pop_vlan */
/** \ingroup of_action_id_pop_vlan 
 * @{ */

/** @} */

/* Unified accessor functions for of_action_id_push_mpls */
/** \ingroup of_action_id_push_mpls 
 * @{ */

/** @} */

/* Unified accessor functions for of_action_id_push_pbb */
/** \ingroup of_action_id_push_pbb 
 * @{ */

/** @} */

/* Unified accessor functions for of_action_id_push_vlan */
/** \ingroup of_action_id_push_vlan 
 * @{ */

/** @} */

/* Unified accessor functions for of_action_id_set_field */
/** \ingroup of_action_id_set_field 
 * @{ */

/** @} */

/* Unified accessor functions for of_action_id_set_mpls_ttl */
/** \ingroup of_action_id_set_mpls_ttl 
 * @{ */

/** @} */

/* Unified accessor functions for of_action_id_set_nw_ttl */
/** \ingroup of_action_id_set_nw_ttl 
 * @{ */

/** @} */

/* Unified accessor functions for of_action_id_set_queue */
/** \ingroup of_action_id_set_queue 
 * @{ */

/** @} */

/* Unified accessor functions for of_action_nicira_dec_ttl */
/** \ingroup of_action_nicira_dec_ttl 
 * @{ */

/**
 * Get experimenter from an object of type of_action_nicira_dec_ttl.
 * @param obj Pointer to an object of type of_action_nicira_dec_ttl.
 * @param experimenter Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_action_nicira_dec_ttl_experimenter_get(
    of_action_nicira_dec_ttl_t *obj,
    uint32_t *experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_NICIRA_DEC_TTL);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set experimenter in an object of type of_action_nicira_dec_ttl.
 * @param obj Pointer to an object of type of_action_nicira_dec_ttl.
 * @param experimenter The value to write into the object
 */
void
of_action_nicira_dec_ttl_experimenter_set(
    of_action_nicira_dec_ttl_t *obj,
    uint32_t experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_NICIRA_DEC_TTL);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get subtype from an object of type of_action_nicira_dec_ttl.
 * @param obj Pointer to an object of type of_action_nicira_dec_ttl.
 * @param subtype Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_action_nicira_dec_ttl_subtype_get(
    of_action_nicira_dec_ttl_t *obj,
    uint16_t *subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_NICIRA_DEC_TTL);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set subtype in an object of type of_action_nicira_dec_ttl.
 * @param obj Pointer to an object of type of_action_nicira_dec_ttl.
 * @param subtype The value to write into the object
 */
void
of_action_nicira_dec_ttl_subtype_set(
    of_action_nicira_dec_ttl_t *obj,
    uint16_t subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_NICIRA_DEC_TTL);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_action_output */
/** \ingroup of_action_output 
 * @{ */

/**
 * Get port from an object of type of_action_output.
 * @param obj Pointer to an object of type of_action_output.
 * @param port Pointer to the child object of type
 * of_port_no_t to be filled out.
 *
 */
void
of_action_output_port_get(
    of_action_output_t *obj,
    of_port_no_t *port)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_OUTPUT);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 4;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_get(ver, wbuf, abs_offset, port);
    OF_PORT_NO_VALUE_CHECK(*port, ver);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set port in an object of type of_action_output.
 * @param obj Pointer to an object of type of_action_output.
 * @param port The value to write into the object
 */
void
of_action_output_port_set(
    of_action_output_t *obj,
    of_port_no_t port)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_OUTPUT);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 4;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_set(ver, wbuf, abs_offset, port);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get max_len from an object of type of_action_output.
 * @param obj Pointer to an object of type of_action_output.
 * @param max_len Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_action_output_max_len_get(
    of_action_output_t *obj,
    uint16_t *max_len)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_OUTPUT);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 6;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, max_len);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set max_len in an object of type of_action_output.
 * @param obj Pointer to an object of type of_action_output.
 * @param max_len The value to write into the object
 */
void
of_action_output_max_len_set(
    of_action_output_t *obj,
    uint16_t max_len)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_OUTPUT);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 6;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, max_len);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_action_pop_mpls */
/** \ingroup of_action_pop_mpls 
 * @{ */

/**
 * Get ethertype from an object of type of_action_pop_mpls.
 * @param obj Pointer to an object of type of_action_pop_mpls.
 * @param ethertype Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_action_pop_mpls_ethertype_get(
    of_action_pop_mpls_t *obj,
    uint16_t *ethertype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_POP_MPLS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, ethertype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set ethertype in an object of type of_action_pop_mpls.
 * @param obj Pointer to an object of type of_action_pop_mpls.
 * @param ethertype The value to write into the object
 */
void
of_action_pop_mpls_ethertype_set(
    of_action_pop_mpls_t *obj,
    uint16_t ethertype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_POP_MPLS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, ethertype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_action_pop_pbb */
/** \ingroup of_action_pop_pbb 
 * @{ */

/** @} */

/* Unified accessor functions for of_action_pop_vlan */
/** \ingroup of_action_pop_vlan 
 * @{ */

/** @} */

/* Unified accessor functions for of_action_push_mpls */
/** \ingroup of_action_push_mpls 
 * @{ */

/**
 * Get ethertype from an object of type of_action_push_mpls.
 * @param obj Pointer to an object of type of_action_push_mpls.
 * @param ethertype Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_action_push_mpls_ethertype_get(
    of_action_push_mpls_t *obj,
    uint16_t *ethertype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_PUSH_MPLS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, ethertype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set ethertype in an object of type of_action_push_mpls.
 * @param obj Pointer to an object of type of_action_push_mpls.
 * @param ethertype The value to write into the object
 */
void
of_action_push_mpls_ethertype_set(
    of_action_push_mpls_t *obj,
    uint16_t ethertype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_PUSH_MPLS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, ethertype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_action_push_pbb */
/** \ingroup of_action_push_pbb 
 * @{ */

/**
 * Get ethertype from an object of type of_action_push_pbb.
 * @param obj Pointer to an object of type of_action_push_pbb.
 * @param ethertype Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_action_push_pbb_ethertype_get(
    of_action_push_pbb_t *obj,
    uint16_t *ethertype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_PUSH_PBB);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, ethertype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set ethertype in an object of type of_action_push_pbb.
 * @param obj Pointer to an object of type of_action_push_pbb.
 * @param ethertype The value to write into the object
 */
void
of_action_push_pbb_ethertype_set(
    of_action_push_pbb_t *obj,
    uint16_t ethertype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_PUSH_PBB);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, ethertype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_action_push_vlan */
/** \ingroup of_action_push_vlan 
 * @{ */

/**
 * Get ethertype from an object of type of_action_push_vlan.
 * @param obj Pointer to an object of type of_action_push_vlan.
 * @param ethertype Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_action_push_vlan_ethertype_get(
    of_action_push_vlan_t *obj,
    uint16_t *ethertype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_PUSH_VLAN);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, ethertype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set ethertype in an object of type of_action_push_vlan.
 * @param obj Pointer to an object of type of_action_push_vlan.
 * @param ethertype The value to write into the object
 */
void
of_action_push_vlan_ethertype_set(
    of_action_push_vlan_t *obj,
    uint16_t ethertype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_PUSH_VLAN);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, ethertype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_action_set_dl_dst */
/** \ingroup of_action_set_dl_dst 
 * @{ */

/**
 * Get dl_addr from an object of type of_action_set_dl_dst.
 * @param obj Pointer to an object of type of_action_set_dl_dst.
 * @param dl_addr Pointer to the child object of type
 * of_mac_addr_t to be filled out.
 *
 */
void
of_action_set_dl_dst_dl_addr_get(
    of_action_set_dl_dst_t *obj,
    of_mac_addr_t *dl_addr)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_SET_DL_DST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_get(wbuf, abs_offset, dl_addr);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set dl_addr in an object of type of_action_set_dl_dst.
 * @param obj Pointer to an object of type of_action_set_dl_dst.
 * @param dl_addr The value to write into the object
 */
void
of_action_set_dl_dst_dl_addr_set(
    of_action_set_dl_dst_t *obj,
    of_mac_addr_t dl_addr)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_SET_DL_DST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_set(wbuf, abs_offset, dl_addr);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_action_set_dl_src */
/** \ingroup of_action_set_dl_src 
 * @{ */

/**
 * Get dl_addr from an object of type of_action_set_dl_src.
 * @param obj Pointer to an object of type of_action_set_dl_src.
 * @param dl_addr Pointer to the child object of type
 * of_mac_addr_t to be filled out.
 *
 */
void
of_action_set_dl_src_dl_addr_get(
    of_action_set_dl_src_t *obj,
    of_mac_addr_t *dl_addr)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_SET_DL_SRC);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_get(wbuf, abs_offset, dl_addr);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set dl_addr in an object of type of_action_set_dl_src.
 * @param obj Pointer to an object of type of_action_set_dl_src.
 * @param dl_addr The value to write into the object
 */
void
of_action_set_dl_src_dl_addr_set(
    of_action_set_dl_src_t *obj,
    of_mac_addr_t dl_addr)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_SET_DL_SRC);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_set(wbuf, abs_offset, dl_addr);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_action_set_field */
/** \ingroup of_action_set_field 
 * @{ */

/**
 * Get field from an object of type of_action_set_field.
 * @param obj Pointer to an object of type of_action_set_field.
 * @param field Pointer to the child object of type
 * of_octets_t to be filled out.
 *
 */
void
of_action_set_field_field_get(
    of_action_set_field_t *obj,
    of_octets_t *field)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_ACTION_SET_FIELD);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);
    ASSERT(cur_len + abs_offset <= WBUF_CURRENT_BYTES(wbuf));
    field->bytes = cur_len;
    field->data = OF_WIRE_BUFFER_INDEX(wbuf, abs_offset);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set field in an object of type of_action_set_field.
 * @param obj Pointer to an object of type of_action_set_field.
 * @param field The value to write into the object
 */
int WARN_UNUSED_RESULT
of_action_set_field_field_set(
    of_action_set_field_t *obj,
    of_octets_t *field)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_ACTION_SET_FIELD);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);
    new_len = field->bytes;
    of_wire_buffer_grow(wbuf, abs_offset + (new_len - cur_len));
    of_wire_buffer_octets_data_set(wbuf, abs_offset, field, cur_len);

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_action_set_mpls_label */
/** \ingroup of_action_set_mpls_label 
 * @{ */

/**
 * Get mpls_label from an object of type of_action_set_mpls_label.
 * @param obj Pointer to an object of type of_action_set_mpls_label.
 * @param mpls_label Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_action_set_mpls_label_mpls_label_get(
    of_action_set_mpls_label_t *obj,
    uint32_t *mpls_label)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_SET_MPLS_LABEL);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, mpls_label);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set mpls_label in an object of type of_action_set_mpls_label.
 * @param obj Pointer to an object of type of_action_set_mpls_label.
 * @param mpls_label The value to write into the object
 */
void
of_action_set_mpls_label_mpls_label_set(
    of_action_set_mpls_label_t *obj,
    uint32_t mpls_label)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_SET_MPLS_LABEL);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, mpls_label);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_action_set_mpls_tc */
/** \ingroup of_action_set_mpls_tc 
 * @{ */

/**
 * Get mpls_tc from an object of type of_action_set_mpls_tc.
 * @param obj Pointer to an object of type of_action_set_mpls_tc.
 * @param mpls_tc Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_action_set_mpls_tc_mpls_tc_get(
    of_action_set_mpls_tc_t *obj,
    uint8_t *mpls_tc)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_SET_MPLS_TC);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, mpls_tc);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set mpls_tc in an object of type of_action_set_mpls_tc.
 * @param obj Pointer to an object of type of_action_set_mpls_tc.
 * @param mpls_tc The value to write into the object
 */
void
of_action_set_mpls_tc_mpls_tc_set(
    of_action_set_mpls_tc_t *obj,
    uint8_t mpls_tc)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_SET_MPLS_TC);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, mpls_tc);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_action_set_mpls_ttl */
/** \ingroup of_action_set_mpls_ttl 
 * @{ */

/**
 * Get mpls_ttl from an object of type of_action_set_mpls_ttl.
 * @param obj Pointer to an object of type of_action_set_mpls_ttl.
 * @param mpls_ttl Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_action_set_mpls_ttl_mpls_ttl_get(
    of_action_set_mpls_ttl_t *obj,
    uint8_t *mpls_ttl)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_SET_MPLS_TTL);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, mpls_ttl);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set mpls_ttl in an object of type of_action_set_mpls_ttl.
 * @param obj Pointer to an object of type of_action_set_mpls_ttl.
 * @param mpls_ttl The value to write into the object
 */
void
of_action_set_mpls_ttl_mpls_ttl_set(
    of_action_set_mpls_ttl_t *obj,
    uint8_t mpls_ttl)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_SET_MPLS_TTL);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, mpls_ttl);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_action_set_nw_dst */
/** \ingroup of_action_set_nw_dst 
 * @{ */

/**
 * Get nw_addr from an object of type of_action_set_nw_dst.
 * @param obj Pointer to an object of type of_action_set_nw_dst.
 * @param nw_addr Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_action_set_nw_dst_nw_addr_get(
    of_action_set_nw_dst_t *obj,
    uint32_t *nw_addr)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_SET_NW_DST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, nw_addr);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set nw_addr in an object of type of_action_set_nw_dst.
 * @param obj Pointer to an object of type of_action_set_nw_dst.
 * @param nw_addr The value to write into the object
 */
void
of_action_set_nw_dst_nw_addr_set(
    of_action_set_nw_dst_t *obj,
    uint32_t nw_addr)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_SET_NW_DST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, nw_addr);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_action_set_nw_ecn */
/** \ingroup of_action_set_nw_ecn 
 * @{ */

/**
 * Get nw_ecn from an object of type of_action_set_nw_ecn.
 * @param obj Pointer to an object of type of_action_set_nw_ecn.
 * @param nw_ecn Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_action_set_nw_ecn_nw_ecn_get(
    of_action_set_nw_ecn_t *obj,
    uint8_t *nw_ecn)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_SET_NW_ECN);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, nw_ecn);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set nw_ecn in an object of type of_action_set_nw_ecn.
 * @param obj Pointer to an object of type of_action_set_nw_ecn.
 * @param nw_ecn The value to write into the object
 */
void
of_action_set_nw_ecn_nw_ecn_set(
    of_action_set_nw_ecn_t *obj,
    uint8_t nw_ecn)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_SET_NW_ECN);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, nw_ecn);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_action_set_nw_src */
/** \ingroup of_action_set_nw_src 
 * @{ */

/**
 * Get nw_addr from an object of type of_action_set_nw_src.
 * @param obj Pointer to an object of type of_action_set_nw_src.
 * @param nw_addr Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_action_set_nw_src_nw_addr_get(
    of_action_set_nw_src_t *obj,
    uint32_t *nw_addr)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_SET_NW_SRC);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, nw_addr);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set nw_addr in an object of type of_action_set_nw_src.
 * @param obj Pointer to an object of type of_action_set_nw_src.
 * @param nw_addr The value to write into the object
 */
void
of_action_set_nw_src_nw_addr_set(
    of_action_set_nw_src_t *obj,
    uint32_t nw_addr)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_SET_NW_SRC);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, nw_addr);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_action_set_nw_tos */
/** \ingroup of_action_set_nw_tos 
 * @{ */

/**
 * Get nw_tos from an object of type of_action_set_nw_tos.
 * @param obj Pointer to an object of type of_action_set_nw_tos.
 * @param nw_tos Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_action_set_nw_tos_nw_tos_get(
    of_action_set_nw_tos_t *obj,
    uint8_t *nw_tos)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_SET_NW_TOS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, nw_tos);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set nw_tos in an object of type of_action_set_nw_tos.
 * @param obj Pointer to an object of type of_action_set_nw_tos.
 * @param nw_tos The value to write into the object
 */
void
of_action_set_nw_tos_nw_tos_set(
    of_action_set_nw_tos_t *obj,
    uint8_t nw_tos)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_SET_NW_TOS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, nw_tos);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_action_set_nw_ttl */
/** \ingroup of_action_set_nw_ttl 
 * @{ */

/**
 * Get nw_ttl from an object of type of_action_set_nw_ttl.
 * @param obj Pointer to an object of type of_action_set_nw_ttl.
 * @param nw_ttl Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_action_set_nw_ttl_nw_ttl_get(
    of_action_set_nw_ttl_t *obj,
    uint8_t *nw_ttl)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_SET_NW_TTL);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, nw_ttl);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set nw_ttl in an object of type of_action_set_nw_ttl.
 * @param obj Pointer to an object of type of_action_set_nw_ttl.
 * @param nw_ttl The value to write into the object
 */
void
of_action_set_nw_ttl_nw_ttl_set(
    of_action_set_nw_ttl_t *obj,
    uint8_t nw_ttl)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_SET_NW_TTL);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, nw_ttl);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_action_set_queue */
/** \ingroup of_action_set_queue 
 * @{ */

/**
 * Get queue_id from an object of type of_action_set_queue.
 * @param obj Pointer to an object of type of_action_set_queue.
 * @param queue_id Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_action_set_queue_queue_id_get(
    of_action_set_queue_t *obj,
    uint32_t *queue_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_SET_QUEUE);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, queue_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set queue_id in an object of type of_action_set_queue.
 * @param obj Pointer to an object of type of_action_set_queue.
 * @param queue_id The value to write into the object
 */
void
of_action_set_queue_queue_id_set(
    of_action_set_queue_t *obj,
    uint32_t queue_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_SET_QUEUE);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, queue_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_action_set_tp_dst */
/** \ingroup of_action_set_tp_dst 
 * @{ */

/**
 * Get tp_port from an object of type of_action_set_tp_dst.
 * @param obj Pointer to an object of type of_action_set_tp_dst.
 * @param tp_port Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_action_set_tp_dst_tp_port_get(
    of_action_set_tp_dst_t *obj,
    uint16_t *tp_port)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_SET_TP_DST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, tp_port);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set tp_port in an object of type of_action_set_tp_dst.
 * @param obj Pointer to an object of type of_action_set_tp_dst.
 * @param tp_port The value to write into the object
 */
void
of_action_set_tp_dst_tp_port_set(
    of_action_set_tp_dst_t *obj,
    uint16_t tp_port)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_SET_TP_DST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, tp_port);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_action_set_tp_src */
/** \ingroup of_action_set_tp_src 
 * @{ */

/**
 * Get tp_port from an object of type of_action_set_tp_src.
 * @param obj Pointer to an object of type of_action_set_tp_src.
 * @param tp_port Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_action_set_tp_src_tp_port_get(
    of_action_set_tp_src_t *obj,
    uint16_t *tp_port)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_SET_TP_SRC);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, tp_port);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set tp_port in an object of type of_action_set_tp_src.
 * @param obj Pointer to an object of type of_action_set_tp_src.
 * @param tp_port The value to write into the object
 */
void
of_action_set_tp_src_tp_port_set(
    of_action_set_tp_src_t *obj,
    uint16_t tp_port)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_SET_TP_SRC);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, tp_port);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_action_set_vlan_pcp */
/** \ingroup of_action_set_vlan_pcp 
 * @{ */

/**
 * Get vlan_pcp from an object of type of_action_set_vlan_pcp.
 * @param obj Pointer to an object of type of_action_set_vlan_pcp.
 * @param vlan_pcp Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_action_set_vlan_pcp_vlan_pcp_get(
    of_action_set_vlan_pcp_t *obj,
    uint8_t *vlan_pcp)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_SET_VLAN_PCP);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, vlan_pcp);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set vlan_pcp in an object of type of_action_set_vlan_pcp.
 * @param obj Pointer to an object of type of_action_set_vlan_pcp.
 * @param vlan_pcp The value to write into the object
 */
void
of_action_set_vlan_pcp_vlan_pcp_set(
    of_action_set_vlan_pcp_t *obj,
    uint8_t vlan_pcp)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_SET_VLAN_PCP);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, vlan_pcp);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_action_set_vlan_vid */
/** \ingroup of_action_set_vlan_vid 
 * @{ */

/**
 * Get vlan_vid from an object of type of_action_set_vlan_vid.
 * @param obj Pointer to an object of type of_action_set_vlan_vid.
 * @param vlan_vid Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_action_set_vlan_vid_vlan_vid_get(
    of_action_set_vlan_vid_t *obj,
    uint16_t *vlan_vid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_SET_VLAN_VID);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, vlan_vid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set vlan_vid in an object of type of_action_set_vlan_vid.
 * @param obj Pointer to an object of type of_action_set_vlan_vid.
 * @param vlan_vid The value to write into the object
 */
void
of_action_set_vlan_vid_vlan_vid_set(
    of_action_set_vlan_vid_t *obj,
    uint16_t vlan_vid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_ACTION_SET_VLAN_VID);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, vlan_vid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_action_strip_vlan */
/** \ingroup of_action_strip_vlan 
 * @{ */

/** @} */

/* Unified accessor functions for of_bsn_interface */
/** \ingroup of_bsn_interface 
 * @{ */

/**
 * Get hw_addr from an object of type of_bsn_interface.
 * @param obj Pointer to an object of type of_bsn_interface.
 * @param hw_addr Pointer to the child object of type
 * of_mac_addr_t to be filled out.
 *
 */
void
of_bsn_interface_hw_addr_get(
    of_bsn_interface_t *obj,
    of_mac_addr_t *hw_addr)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_INTERFACE);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 0;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_get(wbuf, abs_offset, hw_addr);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set hw_addr in an object of type of_bsn_interface.
 * @param obj Pointer to an object of type of_bsn_interface.
 * @param hw_addr The value to write into the object
 */
void
of_bsn_interface_hw_addr_set(
    of_bsn_interface_t *obj,
    of_mac_addr_t hw_addr)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_INTERFACE);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 0;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_set(wbuf, abs_offset, hw_addr);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get name from an object of type of_bsn_interface.
 * @param obj Pointer to an object of type of_bsn_interface.
 * @param name Pointer to the child object of type
 * of_port_name_t to be filled out.
 *
 */
void
of_bsn_interface_name_get(
    of_bsn_interface_t *obj,
    of_port_name_t *name)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_INTERFACE);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_name_get(wbuf, abs_offset, name);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set name in an object of type of_bsn_interface.
 * @param obj Pointer to an object of type of_bsn_interface.
 * @param name The value to write into the object
 */
void
of_bsn_interface_name_set(
    of_bsn_interface_t *obj,
    of_port_name_t name)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_INTERFACE);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_name_set(wbuf, abs_offset, name);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get ipv4_addr from an object of type of_bsn_interface.
 * @param obj Pointer to an object of type of_bsn_interface.
 * @param ipv4_addr Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_interface_ipv4_addr_get(
    of_bsn_interface_t *obj,
    uint32_t *ipv4_addr)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_INTERFACE);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 24;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, ipv4_addr);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set ipv4_addr in an object of type of_bsn_interface.
 * @param obj Pointer to an object of type of_bsn_interface.
 * @param ipv4_addr The value to write into the object
 */
void
of_bsn_interface_ipv4_addr_set(
    of_bsn_interface_t *obj,
    uint32_t ipv4_addr)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_INTERFACE);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 24;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, ipv4_addr);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get ipv4_netmask from an object of type of_bsn_interface.
 * @param obj Pointer to an object of type of_bsn_interface.
 * @param ipv4_netmask Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_interface_ipv4_netmask_get(
    of_bsn_interface_t *obj,
    uint32_t *ipv4_netmask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_INTERFACE);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 28;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, ipv4_netmask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set ipv4_netmask in an object of type of_bsn_interface.
 * @param obj Pointer to an object of type of_bsn_interface.
 * @param ipv4_netmask The value to write into the object
 */
void
of_bsn_interface_ipv4_netmask_set(
    of_bsn_interface_t *obj,
    uint32_t ipv4_netmask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_INTERFACE);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 28;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, ipv4_netmask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_bsn_vport_header */
/** \ingroup of_bsn_vport_header 
 * @{ */

/** @} */

/* Unified accessor functions for of_bsn_vport_q_in_q */
/** \ingroup of_bsn_vport_q_in_q 
 * @{ */

/**
 * Get port_no from an object of type of_bsn_vport_q_in_q.
 * @param obj Pointer to an object of type of_bsn_vport_q_in_q.
 * @param port_no Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bsn_vport_q_in_q_port_no_get(
    of_bsn_vport_q_in_q_t *obj,
    uint32_t *port_no)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_VPORT_Q_IN_Q);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, port_no);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set port_no in an object of type of_bsn_vport_q_in_q.
 * @param obj Pointer to an object of type of_bsn_vport_q_in_q.
 * @param port_no The value to write into the object
 */
void
of_bsn_vport_q_in_q_port_no_set(
    of_bsn_vport_q_in_q_t *obj,
    uint32_t port_no)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_VPORT_Q_IN_Q);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, port_no);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get ingress_tpid from an object of type of_bsn_vport_q_in_q.
 * @param obj Pointer to an object of type of_bsn_vport_q_in_q.
 * @param ingress_tpid Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_bsn_vport_q_in_q_ingress_tpid_get(
    of_bsn_vport_q_in_q_t *obj,
    uint16_t *ingress_tpid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_VPORT_Q_IN_Q);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, ingress_tpid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set ingress_tpid in an object of type of_bsn_vport_q_in_q.
 * @param obj Pointer to an object of type of_bsn_vport_q_in_q.
 * @param ingress_tpid The value to write into the object
 */
void
of_bsn_vport_q_in_q_ingress_tpid_set(
    of_bsn_vport_q_in_q_t *obj,
    uint16_t ingress_tpid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_VPORT_Q_IN_Q);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, ingress_tpid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get ingress_vlan_id from an object of type of_bsn_vport_q_in_q.
 * @param obj Pointer to an object of type of_bsn_vport_q_in_q.
 * @param ingress_vlan_id Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_bsn_vport_q_in_q_ingress_vlan_id_get(
    of_bsn_vport_q_in_q_t *obj,
    uint16_t *ingress_vlan_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_VPORT_Q_IN_Q);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, ingress_vlan_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set ingress_vlan_id in an object of type of_bsn_vport_q_in_q.
 * @param obj Pointer to an object of type of_bsn_vport_q_in_q.
 * @param ingress_vlan_id The value to write into the object
 */
void
of_bsn_vport_q_in_q_ingress_vlan_id_set(
    of_bsn_vport_q_in_q_t *obj,
    uint16_t ingress_vlan_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_VPORT_Q_IN_Q);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, ingress_vlan_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get egress_tpid from an object of type of_bsn_vport_q_in_q.
 * @param obj Pointer to an object of type of_bsn_vport_q_in_q.
 * @param egress_tpid Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_bsn_vport_q_in_q_egress_tpid_get(
    of_bsn_vport_q_in_q_t *obj,
    uint16_t *egress_tpid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_VPORT_Q_IN_Q);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, egress_tpid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set egress_tpid in an object of type of_bsn_vport_q_in_q.
 * @param obj Pointer to an object of type of_bsn_vport_q_in_q.
 * @param egress_tpid The value to write into the object
 */
void
of_bsn_vport_q_in_q_egress_tpid_set(
    of_bsn_vport_q_in_q_t *obj,
    uint16_t egress_tpid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_VPORT_Q_IN_Q);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, egress_tpid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get egress_vlan_id from an object of type of_bsn_vport_q_in_q.
 * @param obj Pointer to an object of type of_bsn_vport_q_in_q.
 * @param egress_vlan_id Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_bsn_vport_q_in_q_egress_vlan_id_get(
    of_bsn_vport_q_in_q_t *obj,
    uint16_t *egress_vlan_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_VPORT_Q_IN_Q);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 14;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, egress_vlan_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set egress_vlan_id in an object of type of_bsn_vport_q_in_q.
 * @param obj Pointer to an object of type of_bsn_vport_q_in_q.
 * @param egress_vlan_id The value to write into the object
 */
void
of_bsn_vport_q_in_q_egress_vlan_id_set(
    of_bsn_vport_q_in_q_t *obj,
    uint16_t egress_vlan_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BSN_VPORT_Q_IN_Q);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 14;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, egress_vlan_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_bucket */
/** \ingroup of_bucket 
 * @{ */

/**
 * Get weight from an object of type of_bucket.
 * @param obj Pointer to an object of type of_bucket.
 * @param weight Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_bucket_weight_get(
    of_bucket_t *obj,
    uint16_t *weight)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BUCKET);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 2;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, weight);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set weight in an object of type of_bucket.
 * @param obj Pointer to an object of type of_bucket.
 * @param weight The value to write into the object
 */
void
of_bucket_weight_set(
    of_bucket_t *obj,
    uint16_t weight)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BUCKET);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 2;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, weight);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get watch_port from an object of type of_bucket.
 * @param obj Pointer to an object of type of_bucket.
 * @param watch_port Pointer to the child object of type
 * of_port_no_t to be filled out.
 *
 */
void
of_bucket_watch_port_get(
    of_bucket_t *obj,
    of_port_no_t *watch_port)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BUCKET);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_get(ver, wbuf, abs_offset, watch_port);
    OF_PORT_NO_VALUE_CHECK(*watch_port, ver);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set watch_port in an object of type of_bucket.
 * @param obj Pointer to an object of type of_bucket.
 * @param watch_port The value to write into the object
 */
void
of_bucket_watch_port_set(
    of_bucket_t *obj,
    of_port_no_t watch_port)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BUCKET);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_set(ver, wbuf, abs_offset, watch_port);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get watch_group from an object of type of_bucket.
 * @param obj Pointer to an object of type of_bucket.
 * @param watch_group Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_bucket_watch_group_get(
    of_bucket_t *obj,
    uint32_t *watch_group)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BUCKET);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, watch_group);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set watch_group in an object of type of_bucket.
 * @param obj Pointer to an object of type of_bucket.
 * @param watch_group The value to write into the object
 */
void
of_bucket_watch_group_set(
    of_bucket_t *obj,
    uint32_t watch_group)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BUCKET);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, watch_group);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Bind an object of type of_list_action_t to the parent of type of_bucket for
 * member actions
 * @param obj Pointer to an object of type of_bucket.
 * @param actions Pointer to the child object of type
 * of_list_action_t to be filled out.
 * \ingroup of_bucket
 *
 * The parameter actions is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_bucket_actions_bind(
    of_bucket_t *obj,
    of_list_action_t *actions)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_BUCKET);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_action_init(actions, obj->version, 0, 1);
    /* Attach to parent */
    actions->parent = (of_object_t *)obj;
    actions->wire_object.wbuf = obj->wire_object.wbuf;
    actions->wire_object.obj_offset = abs_offset;
    actions->wire_object.owned = 0;
    actions->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of actions into a new variable of type of_list_action_t from
 * a of_bucket instance.
 *
 * @param obj Pointer to the source of type of_bucket_t
 * @returns A pointer to a new instance of type of_list_action_t whose contents
 * match that of actions from source
 * @returns NULL if an error occurs
 */
of_list_action_t *
of_bucket_actions_get(of_bucket_t *obj) {
    of_list_action_t _actions;
    of_list_action_t *_actions_ptr;

    of_bucket_actions_bind(obj, &_actions);
    _actions_ptr = (of_list_action_t *)of_object_dup(&_actions);
    return _actions_ptr;
}

/**
 * Set actions in an object of type of_bucket.
 * @param obj Pointer to an object of type of_bucket.
 * @param actions Pointer to the child of type of_list_action_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_bucket_actions_set(
    of_bucket_t *obj,
    of_list_action_t *actions)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_BUCKET);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = actions->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == actions->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(actions, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(actions, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (actions->wire_length_set != NULL) {
        actions->wire_length_set((of_object_t *)actions, actions->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_bucket_counter */
/** \ingroup of_bucket_counter 
 * @{ */

/**
 * Get packet_count from an object of type of_bucket_counter.
 * @param obj Pointer to an object of type of_bucket_counter.
 * @param packet_count Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_bucket_counter_packet_count_get(
    of_bucket_counter_t *obj,
    uint64_t *packet_count)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BUCKET_COUNTER);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 0;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, packet_count);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set packet_count in an object of type of_bucket_counter.
 * @param obj Pointer to an object of type of_bucket_counter.
 * @param packet_count The value to write into the object
 */
void
of_bucket_counter_packet_count_set(
    of_bucket_counter_t *obj,
    uint64_t packet_count)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BUCKET_COUNTER);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 0;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, packet_count);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get byte_count from an object of type of_bucket_counter.
 * @param obj Pointer to an object of type of_bucket_counter.
 * @param byte_count Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_bucket_counter_byte_count_get(
    of_bucket_counter_t *obj,
    uint64_t *byte_count)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BUCKET_COUNTER);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, byte_count);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set byte_count in an object of type of_bucket_counter.
 * @param obj Pointer to an object of type of_bucket_counter.
 * @param byte_count The value to write into the object
 */
void
of_bucket_counter_byte_count_set(
    of_bucket_counter_t *obj,
    uint64_t byte_count)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_BUCKET_COUNTER);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, byte_count);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_experimenter_multipart_header */
/** \ingroup of_experimenter_multipart_header 
 * @{ */

/**
 * Get experimenter from an object of type of_experimenter_multipart_header.
 * @param obj Pointer to an object of type of_experimenter_multipart_header.
 * @param experimenter Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_experimenter_multipart_header_experimenter_get(
    of_experimenter_multipart_header_t *obj,
    uint32_t *experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_EXPERIMENTER_MULTIPART_HEADER);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 0;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set experimenter in an object of type of_experimenter_multipart_header.
 * @param obj Pointer to an object of type of_experimenter_multipart_header.
 * @param experimenter The value to write into the object
 */
void
of_experimenter_multipart_header_experimenter_set(
    of_experimenter_multipart_header_t *obj,
    uint32_t experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_EXPERIMENTER_MULTIPART_HEADER);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 0;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get subtype from an object of type of_experimenter_multipart_header.
 * @param obj Pointer to an object of type of_experimenter_multipart_header.
 * @param subtype Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_experimenter_multipart_header_subtype_get(
    of_experimenter_multipart_header_t *obj,
    uint32_t *subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_EXPERIMENTER_MULTIPART_HEADER);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set subtype in an object of type of_experimenter_multipart_header.
 * @param obj Pointer to an object of type of_experimenter_multipart_header.
 * @param subtype The value to write into the object
 */
void
of_experimenter_multipart_header_subtype_set(
    of_experimenter_multipart_header_t *obj,
    uint32_t subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_EXPERIMENTER_MULTIPART_HEADER);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_flow_stats_entry */
/** \ingroup of_flow_stats_entry 
 * @{ */

/**
 * Get table_id from an object of type of_flow_stats_entry.
 * @param obj Pointer to an object of type of_flow_stats_entry.
 * @param table_id Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_flow_stats_entry_table_id_get(
    of_flow_stats_entry_t *obj,
    uint8_t *table_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 2;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, table_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set table_id in an object of type of_flow_stats_entry.
 * @param obj Pointer to an object of type of_flow_stats_entry.
 * @param table_id The value to write into the object
 */
void
of_flow_stats_entry_table_id_set(
    of_flow_stats_entry_t *obj,
    uint8_t table_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 2;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, table_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get duration_sec from an object of type of_flow_stats_entry.
 * @param obj Pointer to an object of type of_flow_stats_entry.
 * @param duration_sec Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_flow_stats_entry_duration_sec_get(
    of_flow_stats_entry_t *obj,
    uint32_t *duration_sec)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 44;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, duration_sec);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set duration_sec in an object of type of_flow_stats_entry.
 * @param obj Pointer to an object of type of_flow_stats_entry.
 * @param duration_sec The value to write into the object
 */
void
of_flow_stats_entry_duration_sec_set(
    of_flow_stats_entry_t *obj,
    uint32_t duration_sec)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 44;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, duration_sec);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get duration_nsec from an object of type of_flow_stats_entry.
 * @param obj Pointer to an object of type of_flow_stats_entry.
 * @param duration_nsec Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_flow_stats_entry_duration_nsec_get(
    of_flow_stats_entry_t *obj,
    uint32_t *duration_nsec)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 48;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, duration_nsec);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set duration_nsec in an object of type of_flow_stats_entry.
 * @param obj Pointer to an object of type of_flow_stats_entry.
 * @param duration_nsec The value to write into the object
 */
void
of_flow_stats_entry_duration_nsec_set(
    of_flow_stats_entry_t *obj,
    uint32_t duration_nsec)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 48;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, duration_nsec);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get priority from an object of type of_flow_stats_entry.
 * @param obj Pointer to an object of type of_flow_stats_entry.
 * @param priority Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_flow_stats_entry_priority_get(
    of_flow_stats_entry_t *obj,
    uint16_t *priority)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 52;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, priority);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set priority in an object of type of_flow_stats_entry.
 * @param obj Pointer to an object of type of_flow_stats_entry.
 * @param priority The value to write into the object
 */
void
of_flow_stats_entry_priority_set(
    of_flow_stats_entry_t *obj,
    uint16_t priority)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 52;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, priority);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get idle_timeout from an object of type of_flow_stats_entry.
 * @param obj Pointer to an object of type of_flow_stats_entry.
 * @param idle_timeout Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_flow_stats_entry_idle_timeout_get(
    of_flow_stats_entry_t *obj,
    uint16_t *idle_timeout)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 54;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 14;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, idle_timeout);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set idle_timeout in an object of type of_flow_stats_entry.
 * @param obj Pointer to an object of type of_flow_stats_entry.
 * @param idle_timeout The value to write into the object
 */
void
of_flow_stats_entry_idle_timeout_set(
    of_flow_stats_entry_t *obj,
    uint16_t idle_timeout)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 54;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 14;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, idle_timeout);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get hard_timeout from an object of type of_flow_stats_entry.
 * @param obj Pointer to an object of type of_flow_stats_entry.
 * @param hard_timeout Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_flow_stats_entry_hard_timeout_get(
    of_flow_stats_entry_t *obj,
    uint16_t *hard_timeout)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 56;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, hard_timeout);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set hard_timeout in an object of type of_flow_stats_entry.
 * @param obj Pointer to an object of type of_flow_stats_entry.
 * @param hard_timeout The value to write into the object
 */
void
of_flow_stats_entry_hard_timeout_set(
    of_flow_stats_entry_t *obj,
    uint16_t hard_timeout)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 56;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, hard_timeout);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get cookie from an object of type of_flow_stats_entry.
 * @param obj Pointer to an object of type of_flow_stats_entry.
 * @param cookie Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_flow_stats_entry_cookie_get(
    of_flow_stats_entry_t *obj,
    uint64_t *cookie)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 64;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 24;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, cookie);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set cookie in an object of type of_flow_stats_entry.
 * @param obj Pointer to an object of type of_flow_stats_entry.
 * @param cookie The value to write into the object
 */
void
of_flow_stats_entry_cookie_set(
    of_flow_stats_entry_t *obj,
    uint64_t cookie)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 64;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 24;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, cookie);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get packet_count from an object of type of_flow_stats_entry.
 * @param obj Pointer to an object of type of_flow_stats_entry.
 * @param packet_count Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_flow_stats_entry_packet_count_get(
    of_flow_stats_entry_t *obj,
    uint64_t *packet_count)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 72;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 32;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, packet_count);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set packet_count in an object of type of_flow_stats_entry.
 * @param obj Pointer to an object of type of_flow_stats_entry.
 * @param packet_count The value to write into the object
 */
void
of_flow_stats_entry_packet_count_set(
    of_flow_stats_entry_t *obj,
    uint64_t packet_count)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 72;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 32;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, packet_count);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get byte_count from an object of type of_flow_stats_entry.
 * @param obj Pointer to an object of type of_flow_stats_entry.
 * @param byte_count Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_flow_stats_entry_byte_count_get(
    of_flow_stats_entry_t *obj,
    uint64_t *byte_count)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 80;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 40;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, byte_count);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set byte_count in an object of type of_flow_stats_entry.
 * @param obj Pointer to an object of type of_flow_stats_entry.
 * @param byte_count The value to write into the object
 */
void
of_flow_stats_entry_byte_count_set(
    of_flow_stats_entry_t *obj,
    uint64_t byte_count)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_FLOW_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 80;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 40;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, byte_count);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get match from an object of type of_flow_stats_entry.
 * @param obj Pointer to an object of type of_flow_stats_entry.
 * @param match Pointer to the child object of type
 * of_match_t to be filled out.
 *
 */
int WARN_UNUSED_RESULT
of_flow_stats_entry_match_get(
    of_flow_stats_entry_t *obj,
    of_match_t *match)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    of_octets_t match_octets; /* Serialized string for match */

    ASSERT(obj->object_id == OF_FLOW_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 4;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    case OF_VERSION_1_1:
        offset = 48;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 48;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    ASSERT(cur_len + abs_offset <= WBUF_CURRENT_BYTES(wbuf));
    match_octets.bytes = cur_len;
    match_octets.data = OF_OBJECT_BUFFER_INDEX(obj, offset);
    OF_TRY(of_match_deserialize(ver, match, &match_octets));

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/**
 * Set match in an object of type of_flow_stats_entry.
 * @param obj Pointer to an object of type of_flow_stats_entry.
 * @param match Pointer to the child of type of_match_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_flow_stats_entry_match_set(
    of_flow_stats_entry_t *obj,
    of_match_t *match)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */
    of_octets_t match_octets; /* Serialized string for match */

    ASSERT(obj->object_id == OF_FLOW_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 4;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    case OF_VERSION_1_1:
        offset = 48;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 48;
        cur_len = _WIRE_MATCH_PADDED_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Match object */
    OF_TRY(of_match_serialize(ver, match, &match_octets));
    new_len = match_octets.bytes;
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        match_octets.data, new_len);
    /* Free match serialized octets */
    FREE(match_octets.data);

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/**
 * Bind an object of type of_list_instruction_t to the parent of type of_flow_stats_entry for
 * member instructions
 * @param obj Pointer to an object of type of_flow_stats_entry.
 * @param instructions Pointer to the child object of type
 * of_list_instruction_t to be filled out.
 * \ingroup of_flow_stats_entry
 *
 * The parameter instructions is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_flow_stats_entry_instructions_bind(
    of_flow_stats_entry_t *obj,
    of_list_instruction_t *instructions)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_FLOW_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 136;
        cur_len = _END_LEN(obj, offset);
        break;
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = _FLOW_STATS_ENTRY_INSTRUCTIONS_OFFSET(obj);
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_instruction_init(instructions, obj->version, 0, 1);
    /* Attach to parent */
    instructions->parent = (of_object_t *)obj;
    instructions->wire_object.wbuf = obj->wire_object.wbuf;
    instructions->wire_object.obj_offset = abs_offset;
    instructions->wire_object.owned = 0;
    instructions->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of instructions into a new variable of type of_list_instruction_t from
 * a of_flow_stats_entry instance.
 *
 * @param obj Pointer to the source of type of_flow_stats_entry_t
 * @returns A pointer to a new instance of type of_list_instruction_t whose contents
 * match that of instructions from source
 * @returns NULL if an error occurs
 */
of_list_instruction_t *
of_flow_stats_entry_instructions_get(of_flow_stats_entry_t *obj) {
    of_list_instruction_t _instructions;
    of_list_instruction_t *_instructions_ptr;

    of_flow_stats_entry_instructions_bind(obj, &_instructions);
    _instructions_ptr = (of_list_instruction_t *)of_object_dup(&_instructions);
    return _instructions_ptr;
}

/**
 * Set instructions in an object of type of_flow_stats_entry.
 * @param obj Pointer to an object of type of_flow_stats_entry.
 * @param instructions Pointer to the child of type of_list_instruction_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_flow_stats_entry_instructions_set(
    of_flow_stats_entry_t *obj,
    of_list_instruction_t *instructions)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_FLOW_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 136;
        cur_len = _END_LEN(obj, offset);
        break;
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = _FLOW_STATS_ENTRY_INSTRUCTIONS_OFFSET(obj);
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = instructions->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == instructions->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(instructions, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(instructions, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (instructions->wire_length_set != NULL) {
        instructions->wire_length_set((of_object_t *)instructions, instructions->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/**
 * Bind an object of type of_list_action_t to the parent of type of_flow_stats_entry for
 * member actions
 * @param obj Pointer to an object of type of_flow_stats_entry.
 * @param actions Pointer to the child object of type
 * of_list_action_t to be filled out.
 * \ingroup of_flow_stats_entry
 *
 * The parameter actions is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_flow_stats_entry_actions_bind(
    of_flow_stats_entry_t *obj,
    of_list_action_t *actions)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_FLOW_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 88;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_action_init(actions, obj->version, 0, 1);
    /* Attach to parent */
    actions->parent = (of_object_t *)obj;
    actions->wire_object.wbuf = obj->wire_object.wbuf;
    actions->wire_object.obj_offset = abs_offset;
    actions->wire_object.owned = 0;
    actions->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of actions into a new variable of type of_list_action_t from
 * a of_flow_stats_entry instance.
 *
 * @param obj Pointer to the source of type of_flow_stats_entry_t
 * @returns A pointer to a new instance of type of_list_action_t whose contents
 * match that of actions from source
 * @returns NULL if an error occurs
 */
of_list_action_t *
of_flow_stats_entry_actions_get(of_flow_stats_entry_t *obj) {
    of_list_action_t _actions;
    of_list_action_t *_actions_ptr;

    of_flow_stats_entry_actions_bind(obj, &_actions);
    _actions_ptr = (of_list_action_t *)of_object_dup(&_actions);
    return _actions_ptr;
}

/**
 * Set actions in an object of type of_flow_stats_entry.
 * @param obj Pointer to an object of type of_flow_stats_entry.
 * @param actions Pointer to the child of type of_list_action_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_flow_stats_entry_actions_set(
    of_flow_stats_entry_t *obj,
    of_list_action_t *actions)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_FLOW_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 88;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = actions->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == actions->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(actions, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(actions, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (actions->wire_length_set != NULL) {
        actions->wire_length_set((of_object_t *)actions, actions->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_group_desc_stats_entry */
/** \ingroup of_group_desc_stats_entry 
 * @{ */

/**
 * Get group_id from an object of type of_group_desc_stats_entry.
 * @param obj Pointer to an object of type of_group_desc_stats_entry.
 * @param group_id Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_group_desc_stats_entry_group_id_get(
    of_group_desc_stats_entry_t *obj,
    uint32_t *group_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_DESC_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, group_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set group_id in an object of type of_group_desc_stats_entry.
 * @param obj Pointer to an object of type of_group_desc_stats_entry.
 * @param group_id The value to write into the object
 */
void
of_group_desc_stats_entry_group_id_set(
    of_group_desc_stats_entry_t *obj,
    uint32_t group_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_DESC_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, group_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Bind an object of type of_list_bucket_t to the parent of type of_group_desc_stats_entry for
 * member buckets
 * @param obj Pointer to an object of type of_group_desc_stats_entry.
 * @param buckets Pointer to the child object of type
 * of_list_bucket_t to be filled out.
 * \ingroup of_group_desc_stats_entry
 *
 * The parameter buckets is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_group_desc_stats_entry_buckets_bind(
    of_group_desc_stats_entry_t *obj,
    of_list_bucket_t *buckets)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_GROUP_DESC_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_bucket_init(buckets, obj->version, 0, 1);
    /* Attach to parent */
    buckets->parent = (of_object_t *)obj;
    buckets->wire_object.wbuf = obj->wire_object.wbuf;
    buckets->wire_object.obj_offset = abs_offset;
    buckets->wire_object.owned = 0;
    buckets->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of buckets into a new variable of type of_list_bucket_t from
 * a of_group_desc_stats_entry instance.
 *
 * @param obj Pointer to the source of type of_group_desc_stats_entry_t
 * @returns A pointer to a new instance of type of_list_bucket_t whose contents
 * match that of buckets from source
 * @returns NULL if an error occurs
 */
of_list_bucket_t *
of_group_desc_stats_entry_buckets_get(of_group_desc_stats_entry_t *obj) {
    of_list_bucket_t _buckets;
    of_list_bucket_t *_buckets_ptr;

    of_group_desc_stats_entry_buckets_bind(obj, &_buckets);
    _buckets_ptr = (of_list_bucket_t *)of_object_dup(&_buckets);
    return _buckets_ptr;
}

/**
 * Set buckets in an object of type of_group_desc_stats_entry.
 * @param obj Pointer to an object of type of_group_desc_stats_entry.
 * @param buckets Pointer to the child of type of_list_bucket_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_group_desc_stats_entry_buckets_set(
    of_group_desc_stats_entry_t *obj,
    of_list_bucket_t *buckets)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_GROUP_DESC_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = buckets->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == buckets->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(buckets, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(buckets, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (buckets->wire_length_set != NULL) {
        buckets->wire_length_set((of_object_t *)buckets, buckets->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_group_stats_entry */
/** \ingroup of_group_stats_entry 
 * @{ */

/**
 * Get group_id from an object of type of_group_stats_entry.
 * @param obj Pointer to an object of type of_group_stats_entry.
 * @param group_id Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_group_stats_entry_group_id_get(
    of_group_stats_entry_t *obj,
    uint32_t *group_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, group_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set group_id in an object of type of_group_stats_entry.
 * @param obj Pointer to an object of type of_group_stats_entry.
 * @param group_id The value to write into the object
 */
void
of_group_stats_entry_group_id_set(
    of_group_stats_entry_t *obj,
    uint32_t group_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, group_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get ref_count from an object of type of_group_stats_entry.
 * @param obj Pointer to an object of type of_group_stats_entry.
 * @param ref_count Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_group_stats_entry_ref_count_get(
    of_group_stats_entry_t *obj,
    uint32_t *ref_count)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, ref_count);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set ref_count in an object of type of_group_stats_entry.
 * @param obj Pointer to an object of type of_group_stats_entry.
 * @param ref_count The value to write into the object
 */
void
of_group_stats_entry_ref_count_set(
    of_group_stats_entry_t *obj,
    uint32_t ref_count)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, ref_count);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get packet_count from an object of type of_group_stats_entry.
 * @param obj Pointer to an object of type of_group_stats_entry.
 * @param packet_count Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_group_stats_entry_packet_count_get(
    of_group_stats_entry_t *obj,
    uint64_t *packet_count)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, packet_count);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set packet_count in an object of type of_group_stats_entry.
 * @param obj Pointer to an object of type of_group_stats_entry.
 * @param packet_count The value to write into the object
 */
void
of_group_stats_entry_packet_count_set(
    of_group_stats_entry_t *obj,
    uint64_t packet_count)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, packet_count);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get byte_count from an object of type of_group_stats_entry.
 * @param obj Pointer to an object of type of_group_stats_entry.
 * @param byte_count Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_group_stats_entry_byte_count_get(
    of_group_stats_entry_t *obj,
    uint64_t *byte_count)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 24;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, byte_count);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set byte_count in an object of type of_group_stats_entry.
 * @param obj Pointer to an object of type of_group_stats_entry.
 * @param byte_count The value to write into the object
 */
void
of_group_stats_entry_byte_count_set(
    of_group_stats_entry_t *obj,
    uint64_t byte_count)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 24;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, byte_count);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get duration_sec from an object of type of_group_stats_entry.
 * @param obj Pointer to an object of type of_group_stats_entry.
 * @param duration_sec Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_group_stats_entry_duration_sec_get(
    of_group_stats_entry_t *obj,
    uint32_t *duration_sec)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 32;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, duration_sec);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set duration_sec in an object of type of_group_stats_entry.
 * @param obj Pointer to an object of type of_group_stats_entry.
 * @param duration_sec The value to write into the object
 */
void
of_group_stats_entry_duration_sec_set(
    of_group_stats_entry_t *obj,
    uint32_t duration_sec)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 32;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, duration_sec);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get duration_nsec from an object of type of_group_stats_entry.
 * @param obj Pointer to an object of type of_group_stats_entry.
 * @param duration_nsec Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_group_stats_entry_duration_nsec_get(
    of_group_stats_entry_t *obj,
    uint32_t *duration_nsec)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 36;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, duration_nsec);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set duration_nsec in an object of type of_group_stats_entry.
 * @param obj Pointer to an object of type of_group_stats_entry.
 * @param duration_nsec The value to write into the object
 */
void
of_group_stats_entry_duration_nsec_set(
    of_group_stats_entry_t *obj,
    uint32_t duration_nsec)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_GROUP_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 36;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, duration_nsec);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Bind an object of type of_list_bucket_counter_t to the parent of type of_group_stats_entry for
 * member bucket_stats
 * @param obj Pointer to an object of type of_group_stats_entry.
 * @param bucket_stats Pointer to the child object of type
 * of_list_bucket_counter_t to be filled out.
 * \ingroup of_group_stats_entry
 *
 * The parameter bucket_stats is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_group_stats_entry_bucket_stats_bind(
    of_group_stats_entry_t *obj,
    of_list_bucket_counter_t *bucket_stats)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_GROUP_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
        offset = 32;
        cur_len = _END_LEN(obj, offset);
        break;
    case OF_VERSION_1_3:
        offset = 40;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_bucket_counter_init(bucket_stats, obj->version, 0, 1);
    /* Attach to parent */
    bucket_stats->parent = (of_object_t *)obj;
    bucket_stats->wire_object.wbuf = obj->wire_object.wbuf;
    bucket_stats->wire_object.obj_offset = abs_offset;
    bucket_stats->wire_object.owned = 0;
    bucket_stats->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of bucket_stats into a new variable of type of_list_bucket_counter_t from
 * a of_group_stats_entry instance.
 *
 * @param obj Pointer to the source of type of_group_stats_entry_t
 * @returns A pointer to a new instance of type of_list_bucket_counter_t whose contents
 * match that of bucket_stats from source
 * @returns NULL if an error occurs
 */
of_list_bucket_counter_t *
of_group_stats_entry_bucket_stats_get(of_group_stats_entry_t *obj) {
    of_list_bucket_counter_t _bucket_stats;
    of_list_bucket_counter_t *_bucket_stats_ptr;

    of_group_stats_entry_bucket_stats_bind(obj, &_bucket_stats);
    _bucket_stats_ptr = (of_list_bucket_counter_t *)of_object_dup(&_bucket_stats);
    return _bucket_stats_ptr;
}

/**
 * Set bucket_stats in an object of type of_group_stats_entry.
 * @param obj Pointer to an object of type of_group_stats_entry.
 * @param bucket_stats Pointer to the child of type of_list_bucket_counter_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_group_stats_entry_bucket_stats_set(
    of_group_stats_entry_t *obj,
    of_list_bucket_counter_t *bucket_stats)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_GROUP_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
        offset = 32;
        cur_len = _END_LEN(obj, offset);
        break;
    case OF_VERSION_1_3:
        offset = 40;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = bucket_stats->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == bucket_stats->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(bucket_stats, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(bucket_stats, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (bucket_stats->wire_length_set != NULL) {
        bucket_stats->wire_length_set((of_object_t *)bucket_stats, bucket_stats->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_header */
/** \ingroup of_header 
 * @{ */

/**
 * Get xid from an object of type of_header.
 * @param obj Pointer to an object of type of_header.
 * @param xid Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_header_xid_get(
    of_header_t *obj,
    uint32_t *xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_HEADER);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set xid in an object of type of_header.
 * @param obj Pointer to an object of type of_header.
 * @param xid The value to write into the object
 */
void
of_header_xid_set(
    of_header_t *obj,
    uint32_t xid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_HEADER);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, xid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_hello_elem_header */
/** \ingroup of_hello_elem_header 
 * @{ */

/** @} */

/* Unified accessor functions for of_hello_elem_versionbitmap */
/** \ingroup of_hello_elem_versionbitmap 
 * @{ */

/**
 * Bind an object of type of_list_uint32_t to the parent of type of_hello_elem_versionbitmap for
 * member bitmaps
 * @param obj Pointer to an object of type of_hello_elem_versionbitmap.
 * @param bitmaps Pointer to the child object of type
 * of_list_uint32_t to be filled out.
 * \ingroup of_hello_elem_versionbitmap
 *
 * The parameter bitmaps is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_hello_elem_versionbitmap_bitmaps_bind(
    of_hello_elem_versionbitmap_t *obj,
    of_list_uint32_t *bitmaps)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_HELLO_ELEM_VERSIONBITMAP);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_uint32_init(bitmaps, obj->version, 0, 1);
    /* Attach to parent */
    bitmaps->parent = (of_object_t *)obj;
    bitmaps->wire_object.wbuf = obj->wire_object.wbuf;
    bitmaps->wire_object.obj_offset = abs_offset;
    bitmaps->wire_object.owned = 0;
    bitmaps->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of bitmaps into a new variable of type of_list_uint32_t from
 * a of_hello_elem_versionbitmap instance.
 *
 * @param obj Pointer to the source of type of_hello_elem_versionbitmap_t
 * @returns A pointer to a new instance of type of_list_uint32_t whose contents
 * match that of bitmaps from source
 * @returns NULL if an error occurs
 */
of_list_uint32_t *
of_hello_elem_versionbitmap_bitmaps_get(of_hello_elem_versionbitmap_t *obj) {
    of_list_uint32_t _bitmaps;
    of_list_uint32_t *_bitmaps_ptr;

    of_hello_elem_versionbitmap_bitmaps_bind(obj, &_bitmaps);
    _bitmaps_ptr = (of_list_uint32_t *)of_object_dup(&_bitmaps);
    return _bitmaps_ptr;
}

/**
 * Set bitmaps in an object of type of_hello_elem_versionbitmap.
 * @param obj Pointer to an object of type of_hello_elem_versionbitmap.
 * @param bitmaps Pointer to the child of type of_list_uint32_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_hello_elem_versionbitmap_bitmaps_set(
    of_hello_elem_versionbitmap_t *obj,
    of_list_uint32_t *bitmaps)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_HELLO_ELEM_VERSIONBITMAP);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = bitmaps->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == bitmaps->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(bitmaps, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(bitmaps, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (bitmaps->wire_length_set != NULL) {
        bitmaps->wire_length_set((of_object_t *)bitmaps, bitmaps->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_instruction_apply_actions */
/** \ingroup of_instruction_apply_actions 
 * @{ */

/**
 * Bind an object of type of_list_action_t to the parent of type of_instruction_apply_actions for
 * member actions
 * @param obj Pointer to an object of type of_instruction_apply_actions.
 * @param actions Pointer to the child object of type
 * of_list_action_t to be filled out.
 * \ingroup of_instruction_apply_actions
 *
 * The parameter actions is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_instruction_apply_actions_actions_bind(
    of_instruction_apply_actions_t *obj,
    of_list_action_t *actions)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_INSTRUCTION_APPLY_ACTIONS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_action_init(actions, obj->version, 0, 1);
    /* Attach to parent */
    actions->parent = (of_object_t *)obj;
    actions->wire_object.wbuf = obj->wire_object.wbuf;
    actions->wire_object.obj_offset = abs_offset;
    actions->wire_object.owned = 0;
    actions->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of actions into a new variable of type of_list_action_t from
 * a of_instruction_apply_actions instance.
 *
 * @param obj Pointer to the source of type of_instruction_apply_actions_t
 * @returns A pointer to a new instance of type of_list_action_t whose contents
 * match that of actions from source
 * @returns NULL if an error occurs
 */
of_list_action_t *
of_instruction_apply_actions_actions_get(of_instruction_apply_actions_t *obj) {
    of_list_action_t _actions;
    of_list_action_t *_actions_ptr;

    of_instruction_apply_actions_actions_bind(obj, &_actions);
    _actions_ptr = (of_list_action_t *)of_object_dup(&_actions);
    return _actions_ptr;
}

/**
 * Set actions in an object of type of_instruction_apply_actions.
 * @param obj Pointer to an object of type of_instruction_apply_actions.
 * @param actions Pointer to the child of type of_list_action_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_instruction_apply_actions_actions_set(
    of_instruction_apply_actions_t *obj,
    of_list_action_t *actions)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_INSTRUCTION_APPLY_ACTIONS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = actions->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == actions->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(actions, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(actions, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (actions->wire_length_set != NULL) {
        actions->wire_length_set((of_object_t *)actions, actions->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_instruction_clear_actions */
/** \ingroup of_instruction_clear_actions 
 * @{ */

/** @} */

/* Unified accessor functions for of_instruction_experimenter */
/** \ingroup of_instruction_experimenter 
 * @{ */

/**
 * Get experimenter from an object of type of_instruction_experimenter.
 * @param obj Pointer to an object of type of_instruction_experimenter.
 * @param experimenter Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_instruction_experimenter_experimenter_get(
    of_instruction_experimenter_t *obj,
    uint32_t *experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_INSTRUCTION_EXPERIMENTER);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set experimenter in an object of type of_instruction_experimenter.
 * @param obj Pointer to an object of type of_instruction_experimenter.
 * @param experimenter The value to write into the object
 */
void
of_instruction_experimenter_experimenter_set(
    of_instruction_experimenter_t *obj,
    uint32_t experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_INSTRUCTION_EXPERIMENTER);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get data from an object of type of_instruction_experimenter.
 * @param obj Pointer to an object of type of_instruction_experimenter.
 * @param data Pointer to the child object of type
 * of_octets_t to be filled out.
 *
 */
void
of_instruction_experimenter_data_get(
    of_instruction_experimenter_t *obj,
    of_octets_t *data)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_INSTRUCTION_EXPERIMENTER);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);
    ASSERT(cur_len + abs_offset <= WBUF_CURRENT_BYTES(wbuf));
    data->bytes = cur_len;
    data->data = OF_WIRE_BUFFER_INDEX(wbuf, abs_offset);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set data in an object of type of_instruction_experimenter.
 * @param obj Pointer to an object of type of_instruction_experimenter.
 * @param data The value to write into the object
 */
int WARN_UNUSED_RESULT
of_instruction_experimenter_data_set(
    of_instruction_experimenter_t *obj,
    of_octets_t *data)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_INSTRUCTION_EXPERIMENTER);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);
    new_len = data->bytes;
    of_wire_buffer_grow(wbuf, abs_offset + (new_len - cur_len));
    of_wire_buffer_octets_data_set(wbuf, abs_offset, data, cur_len);

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_instruction_goto_table */
/** \ingroup of_instruction_goto_table 
 * @{ */

/**
 * Get table_id from an object of type of_instruction_goto_table.
 * @param obj Pointer to an object of type of_instruction_goto_table.
 * @param table_id Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_instruction_goto_table_table_id_get(
    of_instruction_goto_table_t *obj,
    uint8_t *table_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_INSTRUCTION_GOTO_TABLE);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, table_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set table_id in an object of type of_instruction_goto_table.
 * @param obj Pointer to an object of type of_instruction_goto_table.
 * @param table_id The value to write into the object
 */
void
of_instruction_goto_table_table_id_set(
    of_instruction_goto_table_t *obj,
    uint8_t table_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_INSTRUCTION_GOTO_TABLE);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, table_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_instruction_header */
/** \ingroup of_instruction_header 
 * @{ */

/** @} */

/* Unified accessor functions for of_instruction_meter */
/** \ingroup of_instruction_meter 
 * @{ */

/**
 * Get meter_id from an object of type of_instruction_meter.
 * @param obj Pointer to an object of type of_instruction_meter.
 * @param meter_id Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_instruction_meter_meter_id_get(
    of_instruction_meter_t *obj,
    uint32_t *meter_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_INSTRUCTION_METER);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, meter_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set meter_id in an object of type of_instruction_meter.
 * @param obj Pointer to an object of type of_instruction_meter.
 * @param meter_id The value to write into the object
 */
void
of_instruction_meter_meter_id_set(
    of_instruction_meter_t *obj,
    uint32_t meter_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_INSTRUCTION_METER);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, meter_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_instruction_write_actions */
/** \ingroup of_instruction_write_actions 
 * @{ */

/**
 * Bind an object of type of_list_action_t to the parent of type of_instruction_write_actions for
 * member actions
 * @param obj Pointer to an object of type of_instruction_write_actions.
 * @param actions Pointer to the child object of type
 * of_list_action_t to be filled out.
 * \ingroup of_instruction_write_actions
 *
 * The parameter actions is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_instruction_write_actions_actions_bind(
    of_instruction_write_actions_t *obj,
    of_list_action_t *actions)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_INSTRUCTION_WRITE_ACTIONS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_action_init(actions, obj->version, 0, 1);
    /* Attach to parent */
    actions->parent = (of_object_t *)obj;
    actions->wire_object.wbuf = obj->wire_object.wbuf;
    actions->wire_object.obj_offset = abs_offset;
    actions->wire_object.owned = 0;
    actions->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of actions into a new variable of type of_list_action_t from
 * a of_instruction_write_actions instance.
 *
 * @param obj Pointer to the source of type of_instruction_write_actions_t
 * @returns A pointer to a new instance of type of_list_action_t whose contents
 * match that of actions from source
 * @returns NULL if an error occurs
 */
of_list_action_t *
of_instruction_write_actions_actions_get(of_instruction_write_actions_t *obj) {
    of_list_action_t _actions;
    of_list_action_t *_actions_ptr;

    of_instruction_write_actions_actions_bind(obj, &_actions);
    _actions_ptr = (of_list_action_t *)of_object_dup(&_actions);
    return _actions_ptr;
}

/**
 * Set actions in an object of type of_instruction_write_actions.
 * @param obj Pointer to an object of type of_instruction_write_actions.
 * @param actions Pointer to the child of type of_list_action_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_instruction_write_actions_actions_set(
    of_instruction_write_actions_t *obj,
    of_list_action_t *actions)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_INSTRUCTION_WRITE_ACTIONS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = actions->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == actions->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(actions, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(actions, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (actions->wire_length_set != NULL) {
        actions->wire_length_set((of_object_t *)actions, actions->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_instruction_write_metadata */
/** \ingroup of_instruction_write_metadata 
 * @{ */

/**
 * Get metadata from an object of type of_instruction_write_metadata.
 * @param obj Pointer to an object of type of_instruction_write_metadata.
 * @param metadata Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_instruction_write_metadata_metadata_get(
    of_instruction_write_metadata_t *obj,
    uint64_t *metadata)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_INSTRUCTION_WRITE_METADATA);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, metadata);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set metadata in an object of type of_instruction_write_metadata.
 * @param obj Pointer to an object of type of_instruction_write_metadata.
 * @param metadata The value to write into the object
 */
void
of_instruction_write_metadata_metadata_set(
    of_instruction_write_metadata_t *obj,
    uint64_t metadata)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_INSTRUCTION_WRITE_METADATA);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, metadata);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get metadata_mask from an object of type of_instruction_write_metadata.
 * @param obj Pointer to an object of type of_instruction_write_metadata.
 * @param metadata_mask Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_instruction_write_metadata_metadata_mask_get(
    of_instruction_write_metadata_t *obj,
    uint64_t *metadata_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_INSTRUCTION_WRITE_METADATA);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, metadata_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set metadata_mask in an object of type of_instruction_write_metadata.
 * @param obj Pointer to an object of type of_instruction_write_metadata.
 * @param metadata_mask The value to write into the object
 */
void
of_instruction_write_metadata_metadata_mask_set(
    of_instruction_write_metadata_t *obj,
    uint64_t metadata_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_INSTRUCTION_WRITE_METADATA);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, metadata_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_match_v1 */
/** \ingroup of_match_v1 
 * @{ */

/**
 * Get wildcards from an object of type of_match_v1.
 * @param obj Pointer to an object of type of_match_v1.
 * @param wildcards Pointer to the child object of type
 * of_wc_bmap_t to be filled out.
 *
 */
void
of_match_v1_wildcards_get(
    of_match_v1_t *obj,
    of_wc_bmap_t *wildcards)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V1);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 0;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_wc_bmap_get(ver, wbuf, abs_offset, wildcards);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set wildcards in an object of type of_match_v1.
 * @param obj Pointer to an object of type of_match_v1.
 * @param wildcards The value to write into the object
 */
void
of_match_v1_wildcards_set(
    of_match_v1_t *obj,
    of_wc_bmap_t wildcards)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V1);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 0;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_wc_bmap_set(ver, wbuf, abs_offset, wildcards);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get in_port from an object of type of_match_v1.
 * @param obj Pointer to an object of type of_match_v1.
 * @param in_port Pointer to the child object of type
 * of_port_no_t to be filled out.
 *
 */
void
of_match_v1_in_port_get(
    of_match_v1_t *obj,
    of_port_no_t *in_port)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V1);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_get(ver, wbuf, abs_offset, in_port);
    OF_PORT_NO_VALUE_CHECK(*in_port, ver);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set in_port in an object of type of_match_v1.
 * @param obj Pointer to an object of type of_match_v1.
 * @param in_port The value to write into the object
 */
void
of_match_v1_in_port_set(
    of_match_v1_t *obj,
    of_port_no_t in_port)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V1);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_set(ver, wbuf, abs_offset, in_port);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get eth_src from an object of type of_match_v1.
 * @param obj Pointer to an object of type of_match_v1.
 * @param eth_src Pointer to the child object of type
 * of_mac_addr_t to be filled out.
 *
 */
void
of_match_v1_eth_src_get(
    of_match_v1_t *obj,
    of_mac_addr_t *eth_src)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V1);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 6;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_get(wbuf, abs_offset, eth_src);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set eth_src in an object of type of_match_v1.
 * @param obj Pointer to an object of type of_match_v1.
 * @param eth_src The value to write into the object
 */
void
of_match_v1_eth_src_set(
    of_match_v1_t *obj,
    of_mac_addr_t eth_src)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V1);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 6;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_set(wbuf, abs_offset, eth_src);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get eth_dst from an object of type of_match_v1.
 * @param obj Pointer to an object of type of_match_v1.
 * @param eth_dst Pointer to the child object of type
 * of_mac_addr_t to be filled out.
 *
 */
void
of_match_v1_eth_dst_get(
    of_match_v1_t *obj,
    of_mac_addr_t *eth_dst)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V1);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_get(wbuf, abs_offset, eth_dst);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set eth_dst in an object of type of_match_v1.
 * @param obj Pointer to an object of type of_match_v1.
 * @param eth_dst The value to write into the object
 */
void
of_match_v1_eth_dst_set(
    of_match_v1_t *obj,
    of_mac_addr_t eth_dst)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V1);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_set(wbuf, abs_offset, eth_dst);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get vlan_vid from an object of type of_match_v1.
 * @param obj Pointer to an object of type of_match_v1.
 * @param vlan_vid Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_match_v1_vlan_vid_get(
    of_match_v1_t *obj,
    uint16_t *vlan_vid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V1);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 18;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, vlan_vid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set vlan_vid in an object of type of_match_v1.
 * @param obj Pointer to an object of type of_match_v1.
 * @param vlan_vid The value to write into the object
 */
void
of_match_v1_vlan_vid_set(
    of_match_v1_t *obj,
    uint16_t vlan_vid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V1);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 18;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, vlan_vid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get vlan_pcp from an object of type of_match_v1.
 * @param obj Pointer to an object of type of_match_v1.
 * @param vlan_pcp Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_match_v1_vlan_pcp_get(
    of_match_v1_t *obj,
    uint8_t *vlan_pcp)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V1);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 20;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, vlan_pcp);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set vlan_pcp in an object of type of_match_v1.
 * @param obj Pointer to an object of type of_match_v1.
 * @param vlan_pcp The value to write into the object
 */
void
of_match_v1_vlan_pcp_set(
    of_match_v1_t *obj,
    uint8_t vlan_pcp)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V1);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 20;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, vlan_pcp);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get eth_type from an object of type of_match_v1.
 * @param obj Pointer to an object of type of_match_v1.
 * @param eth_type Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_match_v1_eth_type_get(
    of_match_v1_t *obj,
    uint16_t *eth_type)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V1);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 22;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, eth_type);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set eth_type in an object of type of_match_v1.
 * @param obj Pointer to an object of type of_match_v1.
 * @param eth_type The value to write into the object
 */
void
of_match_v1_eth_type_set(
    of_match_v1_t *obj,
    uint16_t eth_type)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V1);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 22;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, eth_type);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get ip_dscp from an object of type of_match_v1.
 * @param obj Pointer to an object of type of_match_v1.
 * @param ip_dscp Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_match_v1_ip_dscp_get(
    of_match_v1_t *obj,
    uint8_t *ip_dscp)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V1);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 24;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, ip_dscp);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set ip_dscp in an object of type of_match_v1.
 * @param obj Pointer to an object of type of_match_v1.
 * @param ip_dscp The value to write into the object
 */
void
of_match_v1_ip_dscp_set(
    of_match_v1_t *obj,
    uint8_t ip_dscp)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V1);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 24;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, ip_dscp);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get ip_proto from an object of type of_match_v1.
 * @param obj Pointer to an object of type of_match_v1.
 * @param ip_proto Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_match_v1_ip_proto_get(
    of_match_v1_t *obj,
    uint8_t *ip_proto)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V1);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 25;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, ip_proto);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set ip_proto in an object of type of_match_v1.
 * @param obj Pointer to an object of type of_match_v1.
 * @param ip_proto The value to write into the object
 */
void
of_match_v1_ip_proto_set(
    of_match_v1_t *obj,
    uint8_t ip_proto)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V1);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 25;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, ip_proto);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get ipv4_src from an object of type of_match_v1.
 * @param obj Pointer to an object of type of_match_v1.
 * @param ipv4_src Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_match_v1_ipv4_src_get(
    of_match_v1_t *obj,
    uint32_t *ipv4_src)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V1);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 28;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, ipv4_src);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set ipv4_src in an object of type of_match_v1.
 * @param obj Pointer to an object of type of_match_v1.
 * @param ipv4_src The value to write into the object
 */
void
of_match_v1_ipv4_src_set(
    of_match_v1_t *obj,
    uint32_t ipv4_src)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V1);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 28;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, ipv4_src);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get ipv4_dst from an object of type of_match_v1.
 * @param obj Pointer to an object of type of_match_v1.
 * @param ipv4_dst Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_match_v1_ipv4_dst_get(
    of_match_v1_t *obj,
    uint32_t *ipv4_dst)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V1);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 32;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, ipv4_dst);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set ipv4_dst in an object of type of_match_v1.
 * @param obj Pointer to an object of type of_match_v1.
 * @param ipv4_dst The value to write into the object
 */
void
of_match_v1_ipv4_dst_set(
    of_match_v1_t *obj,
    uint32_t ipv4_dst)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V1);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 32;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, ipv4_dst);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get tcp_src from an object of type of_match_v1.
 * @param obj Pointer to an object of type of_match_v1.
 * @param tcp_src Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_match_v1_tcp_src_get(
    of_match_v1_t *obj,
    uint16_t *tcp_src)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V1);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 36;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, tcp_src);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set tcp_src in an object of type of_match_v1.
 * @param obj Pointer to an object of type of_match_v1.
 * @param tcp_src The value to write into the object
 */
void
of_match_v1_tcp_src_set(
    of_match_v1_t *obj,
    uint16_t tcp_src)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V1);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 36;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, tcp_src);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get tcp_dst from an object of type of_match_v1.
 * @param obj Pointer to an object of type of_match_v1.
 * @param tcp_dst Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_match_v1_tcp_dst_get(
    of_match_v1_t *obj,
    uint16_t *tcp_dst)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V1);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 38;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, tcp_dst);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set tcp_dst in an object of type of_match_v1.
 * @param obj Pointer to an object of type of_match_v1.
 * @param tcp_dst The value to write into the object
 */
void
of_match_v1_tcp_dst_set(
    of_match_v1_t *obj,
    uint16_t tcp_dst)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V1);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 38;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, tcp_dst);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_match_v2 */
/** \ingroup of_match_v2 
 * @{ */

/**
 * Get in_port from an object of type of_match_v2.
 * @param obj Pointer to an object of type of_match_v2.
 * @param in_port Pointer to the child object of type
 * of_port_no_t to be filled out.
 *
 */
void
of_match_v2_in_port_get(
    of_match_v2_t *obj,
    of_port_no_t *in_port)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V2);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_get(ver, wbuf, abs_offset, in_port);
    OF_PORT_NO_VALUE_CHECK(*in_port, ver);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set in_port in an object of type of_match_v2.
 * @param obj Pointer to an object of type of_match_v2.
 * @param in_port The value to write into the object
 */
void
of_match_v2_in_port_set(
    of_match_v2_t *obj,
    of_port_no_t in_port)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V2);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_set(ver, wbuf, abs_offset, in_port);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get wildcards from an object of type of_match_v2.
 * @param obj Pointer to an object of type of_match_v2.
 * @param wildcards Pointer to the child object of type
 * of_wc_bmap_t to be filled out.
 *
 */
void
of_match_v2_wildcards_get(
    of_match_v2_t *obj,
    of_wc_bmap_t *wildcards)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V2);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_wc_bmap_get(ver, wbuf, abs_offset, wildcards);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set wildcards in an object of type of_match_v2.
 * @param obj Pointer to an object of type of_match_v2.
 * @param wildcards The value to write into the object
 */
void
of_match_v2_wildcards_set(
    of_match_v2_t *obj,
    of_wc_bmap_t wildcards)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V2);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_wc_bmap_set(ver, wbuf, abs_offset, wildcards);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get eth_src from an object of type of_match_v2.
 * @param obj Pointer to an object of type of_match_v2.
 * @param eth_src Pointer to the child object of type
 * of_mac_addr_t to be filled out.
 *
 */
void
of_match_v2_eth_src_get(
    of_match_v2_t *obj,
    of_mac_addr_t *eth_src)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V2);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_get(wbuf, abs_offset, eth_src);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set eth_src in an object of type of_match_v2.
 * @param obj Pointer to an object of type of_match_v2.
 * @param eth_src The value to write into the object
 */
void
of_match_v2_eth_src_set(
    of_match_v2_t *obj,
    of_mac_addr_t eth_src)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V2);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_set(wbuf, abs_offset, eth_src);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get eth_src_mask from an object of type of_match_v2.
 * @param obj Pointer to an object of type of_match_v2.
 * @param eth_src_mask Pointer to the child object of type
 * of_mac_addr_t to be filled out.
 *
 */
void
of_match_v2_eth_src_mask_get(
    of_match_v2_t *obj,
    of_mac_addr_t *eth_src_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V2);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 18;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_get(wbuf, abs_offset, eth_src_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set eth_src_mask in an object of type of_match_v2.
 * @param obj Pointer to an object of type of_match_v2.
 * @param eth_src_mask The value to write into the object
 */
void
of_match_v2_eth_src_mask_set(
    of_match_v2_t *obj,
    of_mac_addr_t eth_src_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V2);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 18;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_set(wbuf, abs_offset, eth_src_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get eth_dst from an object of type of_match_v2.
 * @param obj Pointer to an object of type of_match_v2.
 * @param eth_dst Pointer to the child object of type
 * of_mac_addr_t to be filled out.
 *
 */
void
of_match_v2_eth_dst_get(
    of_match_v2_t *obj,
    of_mac_addr_t *eth_dst)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V2);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 24;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_get(wbuf, abs_offset, eth_dst);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set eth_dst in an object of type of_match_v2.
 * @param obj Pointer to an object of type of_match_v2.
 * @param eth_dst The value to write into the object
 */
void
of_match_v2_eth_dst_set(
    of_match_v2_t *obj,
    of_mac_addr_t eth_dst)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V2);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 24;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_set(wbuf, abs_offset, eth_dst);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get eth_dst_mask from an object of type of_match_v2.
 * @param obj Pointer to an object of type of_match_v2.
 * @param eth_dst_mask Pointer to the child object of type
 * of_mac_addr_t to be filled out.
 *
 */
void
of_match_v2_eth_dst_mask_get(
    of_match_v2_t *obj,
    of_mac_addr_t *eth_dst_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V2);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 30;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_get(wbuf, abs_offset, eth_dst_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set eth_dst_mask in an object of type of_match_v2.
 * @param obj Pointer to an object of type of_match_v2.
 * @param eth_dst_mask The value to write into the object
 */
void
of_match_v2_eth_dst_mask_set(
    of_match_v2_t *obj,
    of_mac_addr_t eth_dst_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V2);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 30;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_set(wbuf, abs_offset, eth_dst_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get vlan_vid from an object of type of_match_v2.
 * @param obj Pointer to an object of type of_match_v2.
 * @param vlan_vid Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_match_v2_vlan_vid_get(
    of_match_v2_t *obj,
    uint16_t *vlan_vid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V2);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 36;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, vlan_vid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set vlan_vid in an object of type of_match_v2.
 * @param obj Pointer to an object of type of_match_v2.
 * @param vlan_vid The value to write into the object
 */
void
of_match_v2_vlan_vid_set(
    of_match_v2_t *obj,
    uint16_t vlan_vid)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V2);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 36;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, vlan_vid);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get vlan_pcp from an object of type of_match_v2.
 * @param obj Pointer to an object of type of_match_v2.
 * @param vlan_pcp Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_match_v2_vlan_pcp_get(
    of_match_v2_t *obj,
    uint8_t *vlan_pcp)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V2);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 38;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, vlan_pcp);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set vlan_pcp in an object of type of_match_v2.
 * @param obj Pointer to an object of type of_match_v2.
 * @param vlan_pcp The value to write into the object
 */
void
of_match_v2_vlan_pcp_set(
    of_match_v2_t *obj,
    uint8_t vlan_pcp)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V2);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 38;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, vlan_pcp);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get eth_type from an object of type of_match_v2.
 * @param obj Pointer to an object of type of_match_v2.
 * @param eth_type Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_match_v2_eth_type_get(
    of_match_v2_t *obj,
    uint16_t *eth_type)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V2);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 40;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, eth_type);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set eth_type in an object of type of_match_v2.
 * @param obj Pointer to an object of type of_match_v2.
 * @param eth_type The value to write into the object
 */
void
of_match_v2_eth_type_set(
    of_match_v2_t *obj,
    uint16_t eth_type)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V2);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 40;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, eth_type);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get ip_dscp from an object of type of_match_v2.
 * @param obj Pointer to an object of type of_match_v2.
 * @param ip_dscp Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_match_v2_ip_dscp_get(
    of_match_v2_t *obj,
    uint8_t *ip_dscp)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V2);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 42;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, ip_dscp);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set ip_dscp in an object of type of_match_v2.
 * @param obj Pointer to an object of type of_match_v2.
 * @param ip_dscp The value to write into the object
 */
void
of_match_v2_ip_dscp_set(
    of_match_v2_t *obj,
    uint8_t ip_dscp)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V2);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 42;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, ip_dscp);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get ip_proto from an object of type of_match_v2.
 * @param obj Pointer to an object of type of_match_v2.
 * @param ip_proto Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_match_v2_ip_proto_get(
    of_match_v2_t *obj,
    uint8_t *ip_proto)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V2);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 43;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, ip_proto);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set ip_proto in an object of type of_match_v2.
 * @param obj Pointer to an object of type of_match_v2.
 * @param ip_proto The value to write into the object
 */
void
of_match_v2_ip_proto_set(
    of_match_v2_t *obj,
    uint8_t ip_proto)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V2);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 43;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, ip_proto);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get ipv4_src from an object of type of_match_v2.
 * @param obj Pointer to an object of type of_match_v2.
 * @param ipv4_src Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_match_v2_ipv4_src_get(
    of_match_v2_t *obj,
    uint32_t *ipv4_src)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V2);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 44;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, ipv4_src);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set ipv4_src in an object of type of_match_v2.
 * @param obj Pointer to an object of type of_match_v2.
 * @param ipv4_src The value to write into the object
 */
void
of_match_v2_ipv4_src_set(
    of_match_v2_t *obj,
    uint32_t ipv4_src)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V2);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 44;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, ipv4_src);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get ipv4_src_mask from an object of type of_match_v2.
 * @param obj Pointer to an object of type of_match_v2.
 * @param ipv4_src_mask Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_match_v2_ipv4_src_mask_get(
    of_match_v2_t *obj,
    uint32_t *ipv4_src_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V2);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 48;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, ipv4_src_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set ipv4_src_mask in an object of type of_match_v2.
 * @param obj Pointer to an object of type of_match_v2.
 * @param ipv4_src_mask The value to write into the object
 */
void
of_match_v2_ipv4_src_mask_set(
    of_match_v2_t *obj,
    uint32_t ipv4_src_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V2);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 48;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, ipv4_src_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get ipv4_dst from an object of type of_match_v2.
 * @param obj Pointer to an object of type of_match_v2.
 * @param ipv4_dst Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_match_v2_ipv4_dst_get(
    of_match_v2_t *obj,
    uint32_t *ipv4_dst)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V2);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 52;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, ipv4_dst);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set ipv4_dst in an object of type of_match_v2.
 * @param obj Pointer to an object of type of_match_v2.
 * @param ipv4_dst The value to write into the object
 */
void
of_match_v2_ipv4_dst_set(
    of_match_v2_t *obj,
    uint32_t ipv4_dst)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V2);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 52;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, ipv4_dst);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get ipv4_dst_mask from an object of type of_match_v2.
 * @param obj Pointer to an object of type of_match_v2.
 * @param ipv4_dst_mask Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_match_v2_ipv4_dst_mask_get(
    of_match_v2_t *obj,
    uint32_t *ipv4_dst_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V2);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 56;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, ipv4_dst_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set ipv4_dst_mask in an object of type of_match_v2.
 * @param obj Pointer to an object of type of_match_v2.
 * @param ipv4_dst_mask The value to write into the object
 */
void
of_match_v2_ipv4_dst_mask_set(
    of_match_v2_t *obj,
    uint32_t ipv4_dst_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V2);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 56;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, ipv4_dst_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get tcp_src from an object of type of_match_v2.
 * @param obj Pointer to an object of type of_match_v2.
 * @param tcp_src Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_match_v2_tcp_src_get(
    of_match_v2_t *obj,
    uint16_t *tcp_src)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V2);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 60;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, tcp_src);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set tcp_src in an object of type of_match_v2.
 * @param obj Pointer to an object of type of_match_v2.
 * @param tcp_src The value to write into the object
 */
void
of_match_v2_tcp_src_set(
    of_match_v2_t *obj,
    uint16_t tcp_src)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V2);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 60;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, tcp_src);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get tcp_dst from an object of type of_match_v2.
 * @param obj Pointer to an object of type of_match_v2.
 * @param tcp_dst Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_match_v2_tcp_dst_get(
    of_match_v2_t *obj,
    uint16_t *tcp_dst)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V2);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 62;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, tcp_dst);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set tcp_dst in an object of type of_match_v2.
 * @param obj Pointer to an object of type of_match_v2.
 * @param tcp_dst The value to write into the object
 */
void
of_match_v2_tcp_dst_set(
    of_match_v2_t *obj,
    uint16_t tcp_dst)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V2);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 62;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, tcp_dst);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get mpls_label from an object of type of_match_v2.
 * @param obj Pointer to an object of type of_match_v2.
 * @param mpls_label Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_match_v2_mpls_label_get(
    of_match_v2_t *obj,
    uint32_t *mpls_label)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V2);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 64;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, mpls_label);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set mpls_label in an object of type of_match_v2.
 * @param obj Pointer to an object of type of_match_v2.
 * @param mpls_label The value to write into the object
 */
void
of_match_v2_mpls_label_set(
    of_match_v2_t *obj,
    uint32_t mpls_label)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V2);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 64;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, mpls_label);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get mpls_tc from an object of type of_match_v2.
 * @param obj Pointer to an object of type of_match_v2.
 * @param mpls_tc Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_match_v2_mpls_tc_get(
    of_match_v2_t *obj,
    uint8_t *mpls_tc)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V2);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 68;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, mpls_tc);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set mpls_tc in an object of type of_match_v2.
 * @param obj Pointer to an object of type of_match_v2.
 * @param mpls_tc The value to write into the object
 */
void
of_match_v2_mpls_tc_set(
    of_match_v2_t *obj,
    uint8_t mpls_tc)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V2);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 68;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, mpls_tc);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get metadata from an object of type of_match_v2.
 * @param obj Pointer to an object of type of_match_v2.
 * @param metadata Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_match_v2_metadata_get(
    of_match_v2_t *obj,
    uint64_t *metadata)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V2);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 72;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, metadata);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set metadata in an object of type of_match_v2.
 * @param obj Pointer to an object of type of_match_v2.
 * @param metadata The value to write into the object
 */
void
of_match_v2_metadata_set(
    of_match_v2_t *obj,
    uint64_t metadata)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V2);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 72;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, metadata);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get metadata_mask from an object of type of_match_v2.
 * @param obj Pointer to an object of type of_match_v2.
 * @param metadata_mask Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_match_v2_metadata_mask_get(
    of_match_v2_t *obj,
    uint64_t *metadata_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V2);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 80;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, metadata_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set metadata_mask in an object of type of_match_v2.
 * @param obj Pointer to an object of type of_match_v2.
 * @param metadata_mask The value to write into the object
 */
void
of_match_v2_metadata_mask_set(
    of_match_v2_t *obj,
    uint64_t metadata_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_MATCH_V2);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 80;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, metadata_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_match_v3 */
/** \ingroup of_match_v3 
 * @{ */

/**
 * Bind an object of type of_list_oxm_t to the parent of type of_match_v3 for
 * member oxm_list
 * @param obj Pointer to an object of type of_match_v3.
 * @param oxm_list Pointer to the child object of type
 * of_list_oxm_t to be filled out.
 * \ingroup of_match_v3
 *
 * The parameter oxm_list is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_match_v3_oxm_list_bind(
    of_match_v3_t *obj,
    of_list_oxm_t *oxm_list)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_MATCH_V3);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        cur_len = wire_match_len(obj, 0) - 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_oxm_init(oxm_list, obj->version, 0, 1);
    /* Attach to parent */
    oxm_list->parent = (of_object_t *)obj;
    oxm_list->wire_object.wbuf = obj->wire_object.wbuf;
    oxm_list->wire_object.obj_offset = abs_offset;
    oxm_list->wire_object.owned = 0;
    oxm_list->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of oxm_list into a new variable of type of_list_oxm_t from
 * a of_match_v3 instance.
 *
 * @param obj Pointer to the source of type of_match_v3_t
 * @returns A pointer to a new instance of type of_list_oxm_t whose contents
 * match that of oxm_list from source
 * @returns NULL if an error occurs
 */
of_list_oxm_t *
of_match_v3_oxm_list_get(of_match_v3_t *obj) {
    of_list_oxm_t _oxm_list;
    of_list_oxm_t *_oxm_list_ptr;

    of_match_v3_oxm_list_bind(obj, &_oxm_list);
    _oxm_list_ptr = (of_list_oxm_t *)of_object_dup(&_oxm_list);
    return _oxm_list_ptr;
}

/**
 * Set oxm_list in an object of type of_match_v3.
 * @param obj Pointer to an object of type of_match_v3.
 * @param oxm_list Pointer to the child of type of_list_oxm_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_match_v3_oxm_list_set(
    of_match_v3_t *obj,
    of_list_oxm_t *oxm_list)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_MATCH_V3);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        cur_len = wire_match_len(obj, 0) - 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = oxm_list->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == oxm_list->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(oxm_list, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(oxm_list, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (oxm_list->wire_length_set != NULL) {
        oxm_list->wire_length_set((of_object_t *)oxm_list, oxm_list->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_meter_band_drop */
/** \ingroup of_meter_band_drop 
 * @{ */

/**
 * Get rate from an object of type of_meter_band_drop.
 * @param obj Pointer to an object of type of_meter_band_drop.
 * @param rate Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_meter_band_drop_rate_get(
    of_meter_band_drop_t *obj,
    uint32_t *rate)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_BAND_DROP);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, rate);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set rate in an object of type of_meter_band_drop.
 * @param obj Pointer to an object of type of_meter_band_drop.
 * @param rate The value to write into the object
 */
void
of_meter_band_drop_rate_set(
    of_meter_band_drop_t *obj,
    uint32_t rate)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_BAND_DROP);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, rate);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get burst_size from an object of type of_meter_band_drop.
 * @param obj Pointer to an object of type of_meter_band_drop.
 * @param burst_size Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_meter_band_drop_burst_size_get(
    of_meter_band_drop_t *obj,
    uint32_t *burst_size)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_BAND_DROP);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, burst_size);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set burst_size in an object of type of_meter_band_drop.
 * @param obj Pointer to an object of type of_meter_band_drop.
 * @param burst_size The value to write into the object
 */
void
of_meter_band_drop_burst_size_set(
    of_meter_band_drop_t *obj,
    uint32_t burst_size)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_BAND_DROP);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, burst_size);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_meter_band_dscp_remark */
/** \ingroup of_meter_band_dscp_remark 
 * @{ */

/**
 * Get rate from an object of type of_meter_band_dscp_remark.
 * @param obj Pointer to an object of type of_meter_band_dscp_remark.
 * @param rate Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_meter_band_dscp_remark_rate_get(
    of_meter_band_dscp_remark_t *obj,
    uint32_t *rate)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_BAND_DSCP_REMARK);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, rate);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set rate in an object of type of_meter_band_dscp_remark.
 * @param obj Pointer to an object of type of_meter_band_dscp_remark.
 * @param rate The value to write into the object
 */
void
of_meter_band_dscp_remark_rate_set(
    of_meter_band_dscp_remark_t *obj,
    uint32_t rate)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_BAND_DSCP_REMARK);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, rate);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get burst_size from an object of type of_meter_band_dscp_remark.
 * @param obj Pointer to an object of type of_meter_band_dscp_remark.
 * @param burst_size Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_meter_band_dscp_remark_burst_size_get(
    of_meter_band_dscp_remark_t *obj,
    uint32_t *burst_size)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_BAND_DSCP_REMARK);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, burst_size);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set burst_size in an object of type of_meter_band_dscp_remark.
 * @param obj Pointer to an object of type of_meter_band_dscp_remark.
 * @param burst_size The value to write into the object
 */
void
of_meter_band_dscp_remark_burst_size_set(
    of_meter_band_dscp_remark_t *obj,
    uint32_t burst_size)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_BAND_DSCP_REMARK);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, burst_size);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get prec_level from an object of type of_meter_band_dscp_remark.
 * @param obj Pointer to an object of type of_meter_band_dscp_remark.
 * @param prec_level Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_meter_band_dscp_remark_prec_level_get(
    of_meter_band_dscp_remark_t *obj,
    uint8_t *prec_level)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_BAND_DSCP_REMARK);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, prec_level);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set prec_level in an object of type of_meter_band_dscp_remark.
 * @param obj Pointer to an object of type of_meter_band_dscp_remark.
 * @param prec_level The value to write into the object
 */
void
of_meter_band_dscp_remark_prec_level_set(
    of_meter_band_dscp_remark_t *obj,
    uint8_t prec_level)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_BAND_DSCP_REMARK);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, prec_level);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_meter_band_experimenter */
/** \ingroup of_meter_band_experimenter 
 * @{ */

/**
 * Get rate from an object of type of_meter_band_experimenter.
 * @param obj Pointer to an object of type of_meter_band_experimenter.
 * @param rate Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_meter_band_experimenter_rate_get(
    of_meter_band_experimenter_t *obj,
    uint32_t *rate)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_BAND_EXPERIMENTER);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, rate);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set rate in an object of type of_meter_band_experimenter.
 * @param obj Pointer to an object of type of_meter_band_experimenter.
 * @param rate The value to write into the object
 */
void
of_meter_band_experimenter_rate_set(
    of_meter_band_experimenter_t *obj,
    uint32_t rate)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_BAND_EXPERIMENTER);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, rate);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get burst_size from an object of type of_meter_band_experimenter.
 * @param obj Pointer to an object of type of_meter_band_experimenter.
 * @param burst_size Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_meter_band_experimenter_burst_size_get(
    of_meter_band_experimenter_t *obj,
    uint32_t *burst_size)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_BAND_EXPERIMENTER);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, burst_size);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set burst_size in an object of type of_meter_band_experimenter.
 * @param obj Pointer to an object of type of_meter_band_experimenter.
 * @param burst_size The value to write into the object
 */
void
of_meter_band_experimenter_burst_size_set(
    of_meter_band_experimenter_t *obj,
    uint32_t burst_size)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_BAND_EXPERIMENTER);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, burst_size);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get experimenter from an object of type of_meter_band_experimenter.
 * @param obj Pointer to an object of type of_meter_band_experimenter.
 * @param experimenter Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_meter_band_experimenter_experimenter_get(
    of_meter_band_experimenter_t *obj,
    uint32_t *experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_BAND_EXPERIMENTER);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set experimenter in an object of type of_meter_band_experimenter.
 * @param obj Pointer to an object of type of_meter_band_experimenter.
 * @param experimenter The value to write into the object
 */
void
of_meter_band_experimenter_experimenter_set(
    of_meter_band_experimenter_t *obj,
    uint32_t experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_BAND_EXPERIMENTER);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_meter_band_header */
/** \ingroup of_meter_band_header 
 * @{ */

/** @} */

/* Unified accessor functions for of_meter_band_stats */
/** \ingroup of_meter_band_stats 
 * @{ */

/**
 * Get packet_band_count from an object of type of_meter_band_stats.
 * @param obj Pointer to an object of type of_meter_band_stats.
 * @param packet_band_count Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_meter_band_stats_packet_band_count_get(
    of_meter_band_stats_t *obj,
    uint64_t *packet_band_count)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_BAND_STATS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 0;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, packet_band_count);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set packet_band_count in an object of type of_meter_band_stats.
 * @param obj Pointer to an object of type of_meter_band_stats.
 * @param packet_band_count The value to write into the object
 */
void
of_meter_band_stats_packet_band_count_set(
    of_meter_band_stats_t *obj,
    uint64_t packet_band_count)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_BAND_STATS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 0;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, packet_band_count);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get byte_band_count from an object of type of_meter_band_stats.
 * @param obj Pointer to an object of type of_meter_band_stats.
 * @param byte_band_count Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_meter_band_stats_byte_band_count_get(
    of_meter_band_stats_t *obj,
    uint64_t *byte_band_count)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_BAND_STATS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, byte_band_count);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set byte_band_count in an object of type of_meter_band_stats.
 * @param obj Pointer to an object of type of_meter_band_stats.
 * @param byte_band_count The value to write into the object
 */
void
of_meter_band_stats_byte_band_count_set(
    of_meter_band_stats_t *obj,
    uint64_t byte_band_count)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_BAND_STATS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, byte_band_count);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_meter_config */
/** \ingroup of_meter_config 
 * @{ */

/**
 * Get flags from an object of type of_meter_config.
 * @param obj Pointer to an object of type of_meter_config.
 * @param flags Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_meter_config_flags_get(
    of_meter_config_t *obj,
    uint16_t *flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_CONFIG);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 2;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set flags in an object of type of_meter_config.
 * @param obj Pointer to an object of type of_meter_config.
 * @param flags The value to write into the object
 */
void
of_meter_config_flags_set(
    of_meter_config_t *obj,
    uint16_t flags)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_CONFIG);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 2;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, flags);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get meter_id from an object of type of_meter_config.
 * @param obj Pointer to an object of type of_meter_config.
 * @param meter_id Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_meter_config_meter_id_get(
    of_meter_config_t *obj,
    uint32_t *meter_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_CONFIG);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, meter_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set meter_id in an object of type of_meter_config.
 * @param obj Pointer to an object of type of_meter_config.
 * @param meter_id The value to write into the object
 */
void
of_meter_config_meter_id_set(
    of_meter_config_t *obj,
    uint32_t meter_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_CONFIG);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, meter_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Bind an object of type of_list_meter_band_t to the parent of type of_meter_config for
 * member entries
 * @param obj Pointer to an object of type of_meter_config.
 * @param entries Pointer to the child object of type
 * of_list_meter_band_t to be filled out.
 * \ingroup of_meter_config
 *
 * The parameter entries is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_meter_config_entries_bind(
    of_meter_config_t *obj,
    of_list_meter_band_t *entries)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_METER_CONFIG);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 8;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_meter_band_init(entries, obj->version, 0, 1);
    /* Attach to parent */
    entries->parent = (of_object_t *)obj;
    entries->wire_object.wbuf = obj->wire_object.wbuf;
    entries->wire_object.obj_offset = abs_offset;
    entries->wire_object.owned = 0;
    entries->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of entries into a new variable of type of_list_meter_band_t from
 * a of_meter_config instance.
 *
 * @param obj Pointer to the source of type of_meter_config_t
 * @returns A pointer to a new instance of type of_list_meter_band_t whose contents
 * match that of entries from source
 * @returns NULL if an error occurs
 */
of_list_meter_band_t *
of_meter_config_entries_get(of_meter_config_t *obj) {
    of_list_meter_band_t _entries;
    of_list_meter_band_t *_entries_ptr;

    of_meter_config_entries_bind(obj, &_entries);
    _entries_ptr = (of_list_meter_band_t *)of_object_dup(&_entries);
    return _entries_ptr;
}

/**
 * Set entries in an object of type of_meter_config.
 * @param obj Pointer to an object of type of_meter_config.
 * @param entries Pointer to the child of type of_list_meter_band_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_meter_config_entries_set(
    of_meter_config_t *obj,
    of_list_meter_band_t *entries)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_METER_CONFIG);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 8;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = entries->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == entries->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(entries, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(entries, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (entries->wire_length_set != NULL) {
        entries->wire_length_set((of_object_t *)entries, entries->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_meter_features */
/** \ingroup of_meter_features 
 * @{ */

/**
 * Get max_meter from an object of type of_meter_features.
 * @param obj Pointer to an object of type of_meter_features.
 * @param max_meter Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_meter_features_max_meter_get(
    of_meter_features_t *obj,
    uint32_t *max_meter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_FEATURES);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 0;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, max_meter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set max_meter in an object of type of_meter_features.
 * @param obj Pointer to an object of type of_meter_features.
 * @param max_meter The value to write into the object
 */
void
of_meter_features_max_meter_set(
    of_meter_features_t *obj,
    uint32_t max_meter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_FEATURES);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 0;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, max_meter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get band_types from an object of type of_meter_features.
 * @param obj Pointer to an object of type of_meter_features.
 * @param band_types Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_meter_features_band_types_get(
    of_meter_features_t *obj,
    uint32_t *band_types)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_FEATURES);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, band_types);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set band_types in an object of type of_meter_features.
 * @param obj Pointer to an object of type of_meter_features.
 * @param band_types The value to write into the object
 */
void
of_meter_features_band_types_set(
    of_meter_features_t *obj,
    uint32_t band_types)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_FEATURES);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, band_types);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get capabilities from an object of type of_meter_features.
 * @param obj Pointer to an object of type of_meter_features.
 * @param capabilities Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_meter_features_capabilities_get(
    of_meter_features_t *obj,
    uint32_t *capabilities)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_FEATURES);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, capabilities);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set capabilities in an object of type of_meter_features.
 * @param obj Pointer to an object of type of_meter_features.
 * @param capabilities The value to write into the object
 */
void
of_meter_features_capabilities_set(
    of_meter_features_t *obj,
    uint32_t capabilities)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_FEATURES);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, capabilities);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get max_bands from an object of type of_meter_features.
 * @param obj Pointer to an object of type of_meter_features.
 * @param max_bands Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_meter_features_max_bands_get(
    of_meter_features_t *obj,
    uint8_t *max_bands)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_FEATURES);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, max_bands);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set max_bands in an object of type of_meter_features.
 * @param obj Pointer to an object of type of_meter_features.
 * @param max_bands The value to write into the object
 */
void
of_meter_features_max_bands_set(
    of_meter_features_t *obj,
    uint8_t max_bands)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_FEATURES);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, max_bands);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get max_color from an object of type of_meter_features.
 * @param obj Pointer to an object of type of_meter_features.
 * @param max_color Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_meter_features_max_color_get(
    of_meter_features_t *obj,
    uint8_t *max_color)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_FEATURES);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 13;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, max_color);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set max_color in an object of type of_meter_features.
 * @param obj Pointer to an object of type of_meter_features.
 * @param max_color The value to write into the object
 */
void
of_meter_features_max_color_set(
    of_meter_features_t *obj,
    uint8_t max_color)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_FEATURES);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 13;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, max_color);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_meter_stats */
/** \ingroup of_meter_stats 
 * @{ */

/**
 * Get meter_id from an object of type of_meter_stats.
 * @param obj Pointer to an object of type of_meter_stats.
 * @param meter_id Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_meter_stats_meter_id_get(
    of_meter_stats_t *obj,
    uint32_t *meter_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_STATS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 0;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, meter_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set meter_id in an object of type of_meter_stats.
 * @param obj Pointer to an object of type of_meter_stats.
 * @param meter_id The value to write into the object
 */
void
of_meter_stats_meter_id_set(
    of_meter_stats_t *obj,
    uint32_t meter_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_STATS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 0;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, meter_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get flow_count from an object of type of_meter_stats.
 * @param obj Pointer to an object of type of_meter_stats.
 * @param flow_count Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_meter_stats_flow_count_get(
    of_meter_stats_t *obj,
    uint32_t *flow_count)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_STATS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, flow_count);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set flow_count in an object of type of_meter_stats.
 * @param obj Pointer to an object of type of_meter_stats.
 * @param flow_count The value to write into the object
 */
void
of_meter_stats_flow_count_set(
    of_meter_stats_t *obj,
    uint32_t flow_count)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_STATS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, flow_count);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get packet_in_count from an object of type of_meter_stats.
 * @param obj Pointer to an object of type of_meter_stats.
 * @param packet_in_count Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_meter_stats_packet_in_count_get(
    of_meter_stats_t *obj,
    uint64_t *packet_in_count)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_STATS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, packet_in_count);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set packet_in_count in an object of type of_meter_stats.
 * @param obj Pointer to an object of type of_meter_stats.
 * @param packet_in_count The value to write into the object
 */
void
of_meter_stats_packet_in_count_set(
    of_meter_stats_t *obj,
    uint64_t packet_in_count)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_STATS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, packet_in_count);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get byte_in_count from an object of type of_meter_stats.
 * @param obj Pointer to an object of type of_meter_stats.
 * @param byte_in_count Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_meter_stats_byte_in_count_get(
    of_meter_stats_t *obj,
    uint64_t *byte_in_count)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_STATS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 24;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, byte_in_count);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set byte_in_count in an object of type of_meter_stats.
 * @param obj Pointer to an object of type of_meter_stats.
 * @param byte_in_count The value to write into the object
 */
void
of_meter_stats_byte_in_count_set(
    of_meter_stats_t *obj,
    uint64_t byte_in_count)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_STATS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 24;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, byte_in_count);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get duration_sec from an object of type of_meter_stats.
 * @param obj Pointer to an object of type of_meter_stats.
 * @param duration_sec Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_meter_stats_duration_sec_get(
    of_meter_stats_t *obj,
    uint32_t *duration_sec)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_STATS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 32;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, duration_sec);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set duration_sec in an object of type of_meter_stats.
 * @param obj Pointer to an object of type of_meter_stats.
 * @param duration_sec The value to write into the object
 */
void
of_meter_stats_duration_sec_set(
    of_meter_stats_t *obj,
    uint32_t duration_sec)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_STATS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 32;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, duration_sec);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get duration_nsec from an object of type of_meter_stats.
 * @param obj Pointer to an object of type of_meter_stats.
 * @param duration_nsec Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_meter_stats_duration_nsec_get(
    of_meter_stats_t *obj,
    uint32_t *duration_nsec)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_STATS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 36;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, duration_nsec);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set duration_nsec in an object of type of_meter_stats.
 * @param obj Pointer to an object of type of_meter_stats.
 * @param duration_nsec The value to write into the object
 */
void
of_meter_stats_duration_nsec_set(
    of_meter_stats_t *obj,
    uint32_t duration_nsec)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_METER_STATS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 36;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, duration_nsec);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Bind an object of type of_list_meter_band_stats_t to the parent of type of_meter_stats for
 * member band_stats
 * @param obj Pointer to an object of type of_meter_stats.
 * @param band_stats Pointer to the child object of type
 * of_list_meter_band_stats_t to be filled out.
 * \ingroup of_meter_stats
 *
 * The parameter band_stats is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_meter_stats_band_stats_bind(
    of_meter_stats_t *obj,
    of_list_meter_band_stats_t *band_stats)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_METER_STATS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 40;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_meter_band_stats_init(band_stats, obj->version, 0, 1);
    /* Attach to parent */
    band_stats->parent = (of_object_t *)obj;
    band_stats->wire_object.wbuf = obj->wire_object.wbuf;
    band_stats->wire_object.obj_offset = abs_offset;
    band_stats->wire_object.owned = 0;
    band_stats->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of band_stats into a new variable of type of_list_meter_band_stats_t from
 * a of_meter_stats instance.
 *
 * @param obj Pointer to the source of type of_meter_stats_t
 * @returns A pointer to a new instance of type of_list_meter_band_stats_t whose contents
 * match that of band_stats from source
 * @returns NULL if an error occurs
 */
of_list_meter_band_stats_t *
of_meter_stats_band_stats_get(of_meter_stats_t *obj) {
    of_list_meter_band_stats_t _band_stats;
    of_list_meter_band_stats_t *_band_stats_ptr;

    of_meter_stats_band_stats_bind(obj, &_band_stats);
    _band_stats_ptr = (of_list_meter_band_stats_t *)of_object_dup(&_band_stats);
    return _band_stats_ptr;
}

/**
 * Set band_stats in an object of type of_meter_stats.
 * @param obj Pointer to an object of type of_meter_stats.
 * @param band_stats Pointer to the child of type of_list_meter_band_stats_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_meter_stats_band_stats_set(
    of_meter_stats_t *obj,
    of_list_meter_band_stats_t *band_stats)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_METER_STATS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 40;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = band_stats->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == band_stats->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(band_stats, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(band_stats, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (band_stats->wire_length_set != NULL) {
        band_stats->wire_length_set((of_object_t *)band_stats, band_stats->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_oxm_arp_op */
/** \ingroup of_oxm_arp_op 
 * @{ */

/**
 * Get value from an object of type of_oxm_arp_op.
 * @param obj Pointer to an object of type of_oxm_arp_op.
 * @param value Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_oxm_arp_op_value_get(
    of_oxm_arp_op_t *obj,
    uint16_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ARP_OP);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_arp_op.
 * @param obj Pointer to an object of type of_oxm_arp_op.
 * @param value The value to write into the object
 */
void
of_oxm_arp_op_value_set(
    of_oxm_arp_op_t *obj,
    uint16_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ARP_OP);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_arp_op_masked */
/** \ingroup of_oxm_arp_op_masked 
 * @{ */

/**
 * Get value from an object of type of_oxm_arp_op_masked.
 * @param obj Pointer to an object of type of_oxm_arp_op_masked.
 * @param value Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_oxm_arp_op_masked_value_get(
    of_oxm_arp_op_masked_t *obj,
    uint16_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ARP_OP_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_arp_op_masked.
 * @param obj Pointer to an object of type of_oxm_arp_op_masked.
 * @param value The value to write into the object
 */
void
of_oxm_arp_op_masked_value_set(
    of_oxm_arp_op_masked_t *obj,
    uint16_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ARP_OP_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get value_mask from an object of type of_oxm_arp_op_masked.
 * @param obj Pointer to an object of type of_oxm_arp_op_masked.
 * @param value_mask Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_oxm_arp_op_masked_value_mask_get(
    of_oxm_arp_op_masked_t *obj,
    uint16_t *value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ARP_OP_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 6;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value_mask in an object of type of_oxm_arp_op_masked.
 * @param obj Pointer to an object of type of_oxm_arp_op_masked.
 * @param value_mask The value to write into the object
 */
void
of_oxm_arp_op_masked_value_mask_set(
    of_oxm_arp_op_masked_t *obj,
    uint16_t value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ARP_OP_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 6;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_arp_sha */
/** \ingroup of_oxm_arp_sha 
 * @{ */

/**
 * Get value from an object of type of_oxm_arp_sha.
 * @param obj Pointer to an object of type of_oxm_arp_sha.
 * @param value Pointer to the child object of type
 * of_mac_addr_t to be filled out.
 *
 */
void
of_oxm_arp_sha_value_get(
    of_oxm_arp_sha_t *obj,
    of_mac_addr_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ARP_SHA);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_arp_sha.
 * @param obj Pointer to an object of type of_oxm_arp_sha.
 * @param value The value to write into the object
 */
void
of_oxm_arp_sha_value_set(
    of_oxm_arp_sha_t *obj,
    of_mac_addr_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ARP_SHA);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_arp_sha_masked */
/** \ingroup of_oxm_arp_sha_masked 
 * @{ */

/**
 * Get value from an object of type of_oxm_arp_sha_masked.
 * @param obj Pointer to an object of type of_oxm_arp_sha_masked.
 * @param value Pointer to the child object of type
 * of_mac_addr_t to be filled out.
 *
 */
void
of_oxm_arp_sha_masked_value_get(
    of_oxm_arp_sha_masked_t *obj,
    of_mac_addr_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ARP_SHA_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_arp_sha_masked.
 * @param obj Pointer to an object of type of_oxm_arp_sha_masked.
 * @param value The value to write into the object
 */
void
of_oxm_arp_sha_masked_value_set(
    of_oxm_arp_sha_masked_t *obj,
    of_mac_addr_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ARP_SHA_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get value_mask from an object of type of_oxm_arp_sha_masked.
 * @param obj Pointer to an object of type of_oxm_arp_sha_masked.
 * @param value_mask Pointer to the child object of type
 * of_mac_addr_t to be filled out.
 *
 */
void
of_oxm_arp_sha_masked_value_mask_get(
    of_oxm_arp_sha_masked_t *obj,
    of_mac_addr_t *value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ARP_SHA_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_get(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value_mask in an object of type of_oxm_arp_sha_masked.
 * @param obj Pointer to an object of type of_oxm_arp_sha_masked.
 * @param value_mask The value to write into the object
 */
void
of_oxm_arp_sha_masked_value_mask_set(
    of_oxm_arp_sha_masked_t *obj,
    of_mac_addr_t value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ARP_SHA_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_set(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_arp_spa */
/** \ingroup of_oxm_arp_spa 
 * @{ */

/**
 * Get value from an object of type of_oxm_arp_spa.
 * @param obj Pointer to an object of type of_oxm_arp_spa.
 * @param value Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_oxm_arp_spa_value_get(
    of_oxm_arp_spa_t *obj,
    uint32_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ARP_SPA);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_arp_spa.
 * @param obj Pointer to an object of type of_oxm_arp_spa.
 * @param value The value to write into the object
 */
void
of_oxm_arp_spa_value_set(
    of_oxm_arp_spa_t *obj,
    uint32_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ARP_SPA);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_arp_spa_masked */
/** \ingroup of_oxm_arp_spa_masked 
 * @{ */

/**
 * Get value from an object of type of_oxm_arp_spa_masked.
 * @param obj Pointer to an object of type of_oxm_arp_spa_masked.
 * @param value Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_oxm_arp_spa_masked_value_get(
    of_oxm_arp_spa_masked_t *obj,
    uint32_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ARP_SPA_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_arp_spa_masked.
 * @param obj Pointer to an object of type of_oxm_arp_spa_masked.
 * @param value The value to write into the object
 */
void
of_oxm_arp_spa_masked_value_set(
    of_oxm_arp_spa_masked_t *obj,
    uint32_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ARP_SPA_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get value_mask from an object of type of_oxm_arp_spa_masked.
 * @param obj Pointer to an object of type of_oxm_arp_spa_masked.
 * @param value_mask Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_oxm_arp_spa_masked_value_mask_get(
    of_oxm_arp_spa_masked_t *obj,
    uint32_t *value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ARP_SPA_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value_mask in an object of type of_oxm_arp_spa_masked.
 * @param obj Pointer to an object of type of_oxm_arp_spa_masked.
 * @param value_mask The value to write into the object
 */
void
of_oxm_arp_spa_masked_value_mask_set(
    of_oxm_arp_spa_masked_t *obj,
    uint32_t value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ARP_SPA_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_arp_tha */
/** \ingroup of_oxm_arp_tha 
 * @{ */

/**
 * Get value from an object of type of_oxm_arp_tha.
 * @param obj Pointer to an object of type of_oxm_arp_tha.
 * @param value Pointer to the child object of type
 * of_mac_addr_t to be filled out.
 *
 */
void
of_oxm_arp_tha_value_get(
    of_oxm_arp_tha_t *obj,
    of_mac_addr_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ARP_THA);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_arp_tha.
 * @param obj Pointer to an object of type of_oxm_arp_tha.
 * @param value The value to write into the object
 */
void
of_oxm_arp_tha_value_set(
    of_oxm_arp_tha_t *obj,
    of_mac_addr_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ARP_THA);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_arp_tha_masked */
/** \ingroup of_oxm_arp_tha_masked 
 * @{ */

/**
 * Get value from an object of type of_oxm_arp_tha_masked.
 * @param obj Pointer to an object of type of_oxm_arp_tha_masked.
 * @param value Pointer to the child object of type
 * of_mac_addr_t to be filled out.
 *
 */
void
of_oxm_arp_tha_masked_value_get(
    of_oxm_arp_tha_masked_t *obj,
    of_mac_addr_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ARP_THA_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_arp_tha_masked.
 * @param obj Pointer to an object of type of_oxm_arp_tha_masked.
 * @param value The value to write into the object
 */
void
of_oxm_arp_tha_masked_value_set(
    of_oxm_arp_tha_masked_t *obj,
    of_mac_addr_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ARP_THA_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get value_mask from an object of type of_oxm_arp_tha_masked.
 * @param obj Pointer to an object of type of_oxm_arp_tha_masked.
 * @param value_mask Pointer to the child object of type
 * of_mac_addr_t to be filled out.
 *
 */
void
of_oxm_arp_tha_masked_value_mask_get(
    of_oxm_arp_tha_masked_t *obj,
    of_mac_addr_t *value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ARP_THA_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_get(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value_mask in an object of type of_oxm_arp_tha_masked.
 * @param obj Pointer to an object of type of_oxm_arp_tha_masked.
 * @param value_mask The value to write into the object
 */
void
of_oxm_arp_tha_masked_value_mask_set(
    of_oxm_arp_tha_masked_t *obj,
    of_mac_addr_t value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ARP_THA_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_set(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_arp_tpa */
/** \ingroup of_oxm_arp_tpa 
 * @{ */

/**
 * Get value from an object of type of_oxm_arp_tpa.
 * @param obj Pointer to an object of type of_oxm_arp_tpa.
 * @param value Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_oxm_arp_tpa_value_get(
    of_oxm_arp_tpa_t *obj,
    uint32_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ARP_TPA);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_arp_tpa.
 * @param obj Pointer to an object of type of_oxm_arp_tpa.
 * @param value The value to write into the object
 */
void
of_oxm_arp_tpa_value_set(
    of_oxm_arp_tpa_t *obj,
    uint32_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ARP_TPA);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_arp_tpa_masked */
/** \ingroup of_oxm_arp_tpa_masked 
 * @{ */

/**
 * Get value from an object of type of_oxm_arp_tpa_masked.
 * @param obj Pointer to an object of type of_oxm_arp_tpa_masked.
 * @param value Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_oxm_arp_tpa_masked_value_get(
    of_oxm_arp_tpa_masked_t *obj,
    uint32_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ARP_TPA_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_arp_tpa_masked.
 * @param obj Pointer to an object of type of_oxm_arp_tpa_masked.
 * @param value The value to write into the object
 */
void
of_oxm_arp_tpa_masked_value_set(
    of_oxm_arp_tpa_masked_t *obj,
    uint32_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ARP_TPA_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get value_mask from an object of type of_oxm_arp_tpa_masked.
 * @param obj Pointer to an object of type of_oxm_arp_tpa_masked.
 * @param value_mask Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_oxm_arp_tpa_masked_value_mask_get(
    of_oxm_arp_tpa_masked_t *obj,
    uint32_t *value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ARP_TPA_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value_mask in an object of type of_oxm_arp_tpa_masked.
 * @param obj Pointer to an object of type of_oxm_arp_tpa_masked.
 * @param value_mask The value to write into the object
 */
void
of_oxm_arp_tpa_masked_value_mask_set(
    of_oxm_arp_tpa_masked_t *obj,
    uint32_t value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ARP_TPA_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_eth_dst */
/** \ingroup of_oxm_eth_dst 
 * @{ */

/**
 * Get value from an object of type of_oxm_eth_dst.
 * @param obj Pointer to an object of type of_oxm_eth_dst.
 * @param value Pointer to the child object of type
 * of_mac_addr_t to be filled out.
 *
 */
void
of_oxm_eth_dst_value_get(
    of_oxm_eth_dst_t *obj,
    of_mac_addr_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ETH_DST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_eth_dst.
 * @param obj Pointer to an object of type of_oxm_eth_dst.
 * @param value The value to write into the object
 */
void
of_oxm_eth_dst_value_set(
    of_oxm_eth_dst_t *obj,
    of_mac_addr_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ETH_DST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_eth_dst_masked */
/** \ingroup of_oxm_eth_dst_masked 
 * @{ */

/**
 * Get value from an object of type of_oxm_eth_dst_masked.
 * @param obj Pointer to an object of type of_oxm_eth_dst_masked.
 * @param value Pointer to the child object of type
 * of_mac_addr_t to be filled out.
 *
 */
void
of_oxm_eth_dst_masked_value_get(
    of_oxm_eth_dst_masked_t *obj,
    of_mac_addr_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ETH_DST_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_eth_dst_masked.
 * @param obj Pointer to an object of type of_oxm_eth_dst_masked.
 * @param value The value to write into the object
 */
void
of_oxm_eth_dst_masked_value_set(
    of_oxm_eth_dst_masked_t *obj,
    of_mac_addr_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ETH_DST_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get value_mask from an object of type of_oxm_eth_dst_masked.
 * @param obj Pointer to an object of type of_oxm_eth_dst_masked.
 * @param value_mask Pointer to the child object of type
 * of_mac_addr_t to be filled out.
 *
 */
void
of_oxm_eth_dst_masked_value_mask_get(
    of_oxm_eth_dst_masked_t *obj,
    of_mac_addr_t *value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ETH_DST_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_get(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value_mask in an object of type of_oxm_eth_dst_masked.
 * @param obj Pointer to an object of type of_oxm_eth_dst_masked.
 * @param value_mask The value to write into the object
 */
void
of_oxm_eth_dst_masked_value_mask_set(
    of_oxm_eth_dst_masked_t *obj,
    of_mac_addr_t value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ETH_DST_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_set(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_eth_src */
/** \ingroup of_oxm_eth_src 
 * @{ */

/**
 * Get value from an object of type of_oxm_eth_src.
 * @param obj Pointer to an object of type of_oxm_eth_src.
 * @param value Pointer to the child object of type
 * of_mac_addr_t to be filled out.
 *
 */
void
of_oxm_eth_src_value_get(
    of_oxm_eth_src_t *obj,
    of_mac_addr_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ETH_SRC);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_eth_src.
 * @param obj Pointer to an object of type of_oxm_eth_src.
 * @param value The value to write into the object
 */
void
of_oxm_eth_src_value_set(
    of_oxm_eth_src_t *obj,
    of_mac_addr_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ETH_SRC);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_eth_src_masked */
/** \ingroup of_oxm_eth_src_masked 
 * @{ */

/**
 * Get value from an object of type of_oxm_eth_src_masked.
 * @param obj Pointer to an object of type of_oxm_eth_src_masked.
 * @param value Pointer to the child object of type
 * of_mac_addr_t to be filled out.
 *
 */
void
of_oxm_eth_src_masked_value_get(
    of_oxm_eth_src_masked_t *obj,
    of_mac_addr_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ETH_SRC_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_eth_src_masked.
 * @param obj Pointer to an object of type of_oxm_eth_src_masked.
 * @param value The value to write into the object
 */
void
of_oxm_eth_src_masked_value_set(
    of_oxm_eth_src_masked_t *obj,
    of_mac_addr_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ETH_SRC_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get value_mask from an object of type of_oxm_eth_src_masked.
 * @param obj Pointer to an object of type of_oxm_eth_src_masked.
 * @param value_mask Pointer to the child object of type
 * of_mac_addr_t to be filled out.
 *
 */
void
of_oxm_eth_src_masked_value_mask_get(
    of_oxm_eth_src_masked_t *obj,
    of_mac_addr_t *value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ETH_SRC_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_get(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value_mask in an object of type of_oxm_eth_src_masked.
 * @param obj Pointer to an object of type of_oxm_eth_src_masked.
 * @param value_mask The value to write into the object
 */
void
of_oxm_eth_src_masked_value_mask_set(
    of_oxm_eth_src_masked_t *obj,
    of_mac_addr_t value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ETH_SRC_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_set(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_eth_type */
/** \ingroup of_oxm_eth_type 
 * @{ */

/**
 * Get value from an object of type of_oxm_eth_type.
 * @param obj Pointer to an object of type of_oxm_eth_type.
 * @param value Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_oxm_eth_type_value_get(
    of_oxm_eth_type_t *obj,
    uint16_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ETH_TYPE);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_eth_type.
 * @param obj Pointer to an object of type of_oxm_eth_type.
 * @param value The value to write into the object
 */
void
of_oxm_eth_type_value_set(
    of_oxm_eth_type_t *obj,
    uint16_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ETH_TYPE);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_eth_type_masked */
/** \ingroup of_oxm_eth_type_masked 
 * @{ */

/**
 * Get value from an object of type of_oxm_eth_type_masked.
 * @param obj Pointer to an object of type of_oxm_eth_type_masked.
 * @param value Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_oxm_eth_type_masked_value_get(
    of_oxm_eth_type_masked_t *obj,
    uint16_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ETH_TYPE_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_eth_type_masked.
 * @param obj Pointer to an object of type of_oxm_eth_type_masked.
 * @param value The value to write into the object
 */
void
of_oxm_eth_type_masked_value_set(
    of_oxm_eth_type_masked_t *obj,
    uint16_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ETH_TYPE_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get value_mask from an object of type of_oxm_eth_type_masked.
 * @param obj Pointer to an object of type of_oxm_eth_type_masked.
 * @param value_mask Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_oxm_eth_type_masked_value_mask_get(
    of_oxm_eth_type_masked_t *obj,
    uint16_t *value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ETH_TYPE_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 6;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value_mask in an object of type of_oxm_eth_type_masked.
 * @param obj Pointer to an object of type of_oxm_eth_type_masked.
 * @param value_mask The value to write into the object
 */
void
of_oxm_eth_type_masked_value_mask_set(
    of_oxm_eth_type_masked_t *obj,
    uint16_t value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ETH_TYPE_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 6;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_header */
/** \ingroup of_oxm_header 
 * @{ */

/** @} */

/* Unified accessor functions for of_oxm_icmpv4_code */
/** \ingroup of_oxm_icmpv4_code 
 * @{ */

/**
 * Get value from an object of type of_oxm_icmpv4_code.
 * @param obj Pointer to an object of type of_oxm_icmpv4_code.
 * @param value Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_oxm_icmpv4_code_value_get(
    of_oxm_icmpv4_code_t *obj,
    uint8_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ICMPV4_CODE);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_icmpv4_code.
 * @param obj Pointer to an object of type of_oxm_icmpv4_code.
 * @param value The value to write into the object
 */
void
of_oxm_icmpv4_code_value_set(
    of_oxm_icmpv4_code_t *obj,
    uint8_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ICMPV4_CODE);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_icmpv4_code_masked */
/** \ingroup of_oxm_icmpv4_code_masked 
 * @{ */

/**
 * Get value from an object of type of_oxm_icmpv4_code_masked.
 * @param obj Pointer to an object of type of_oxm_icmpv4_code_masked.
 * @param value Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_oxm_icmpv4_code_masked_value_get(
    of_oxm_icmpv4_code_masked_t *obj,
    uint8_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ICMPV4_CODE_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_icmpv4_code_masked.
 * @param obj Pointer to an object of type of_oxm_icmpv4_code_masked.
 * @param value The value to write into the object
 */
void
of_oxm_icmpv4_code_masked_value_set(
    of_oxm_icmpv4_code_masked_t *obj,
    uint8_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ICMPV4_CODE_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get value_mask from an object of type of_oxm_icmpv4_code_masked.
 * @param obj Pointer to an object of type of_oxm_icmpv4_code_masked.
 * @param value_mask Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_oxm_icmpv4_code_masked_value_mask_get(
    of_oxm_icmpv4_code_masked_t *obj,
    uint8_t *value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ICMPV4_CODE_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 5;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value_mask in an object of type of_oxm_icmpv4_code_masked.
 * @param obj Pointer to an object of type of_oxm_icmpv4_code_masked.
 * @param value_mask The value to write into the object
 */
void
of_oxm_icmpv4_code_masked_value_mask_set(
    of_oxm_icmpv4_code_masked_t *obj,
    uint8_t value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ICMPV4_CODE_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 5;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_icmpv4_type */
/** \ingroup of_oxm_icmpv4_type 
 * @{ */

/**
 * Get value from an object of type of_oxm_icmpv4_type.
 * @param obj Pointer to an object of type of_oxm_icmpv4_type.
 * @param value Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_oxm_icmpv4_type_value_get(
    of_oxm_icmpv4_type_t *obj,
    uint8_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ICMPV4_TYPE);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_icmpv4_type.
 * @param obj Pointer to an object of type of_oxm_icmpv4_type.
 * @param value The value to write into the object
 */
void
of_oxm_icmpv4_type_value_set(
    of_oxm_icmpv4_type_t *obj,
    uint8_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ICMPV4_TYPE);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_icmpv4_type_masked */
/** \ingroup of_oxm_icmpv4_type_masked 
 * @{ */

/**
 * Get value from an object of type of_oxm_icmpv4_type_masked.
 * @param obj Pointer to an object of type of_oxm_icmpv4_type_masked.
 * @param value Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_oxm_icmpv4_type_masked_value_get(
    of_oxm_icmpv4_type_masked_t *obj,
    uint8_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ICMPV4_TYPE_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_icmpv4_type_masked.
 * @param obj Pointer to an object of type of_oxm_icmpv4_type_masked.
 * @param value The value to write into the object
 */
void
of_oxm_icmpv4_type_masked_value_set(
    of_oxm_icmpv4_type_masked_t *obj,
    uint8_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ICMPV4_TYPE_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get value_mask from an object of type of_oxm_icmpv4_type_masked.
 * @param obj Pointer to an object of type of_oxm_icmpv4_type_masked.
 * @param value_mask Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_oxm_icmpv4_type_masked_value_mask_get(
    of_oxm_icmpv4_type_masked_t *obj,
    uint8_t *value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ICMPV4_TYPE_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 5;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value_mask in an object of type of_oxm_icmpv4_type_masked.
 * @param obj Pointer to an object of type of_oxm_icmpv4_type_masked.
 * @param value_mask The value to write into the object
 */
void
of_oxm_icmpv4_type_masked_value_mask_set(
    of_oxm_icmpv4_type_masked_t *obj,
    uint8_t value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ICMPV4_TYPE_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 5;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_icmpv6_code */
/** \ingroup of_oxm_icmpv6_code 
 * @{ */

/**
 * Get value from an object of type of_oxm_icmpv6_code.
 * @param obj Pointer to an object of type of_oxm_icmpv6_code.
 * @param value Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_oxm_icmpv6_code_value_get(
    of_oxm_icmpv6_code_t *obj,
    uint8_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ICMPV6_CODE);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_icmpv6_code.
 * @param obj Pointer to an object of type of_oxm_icmpv6_code.
 * @param value The value to write into the object
 */
void
of_oxm_icmpv6_code_value_set(
    of_oxm_icmpv6_code_t *obj,
    uint8_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ICMPV6_CODE);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_icmpv6_code_masked */
/** \ingroup of_oxm_icmpv6_code_masked 
 * @{ */

/**
 * Get value from an object of type of_oxm_icmpv6_code_masked.
 * @param obj Pointer to an object of type of_oxm_icmpv6_code_masked.
 * @param value Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_oxm_icmpv6_code_masked_value_get(
    of_oxm_icmpv6_code_masked_t *obj,
    uint8_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ICMPV6_CODE_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_icmpv6_code_masked.
 * @param obj Pointer to an object of type of_oxm_icmpv6_code_masked.
 * @param value The value to write into the object
 */
void
of_oxm_icmpv6_code_masked_value_set(
    of_oxm_icmpv6_code_masked_t *obj,
    uint8_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ICMPV6_CODE_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get value_mask from an object of type of_oxm_icmpv6_code_masked.
 * @param obj Pointer to an object of type of_oxm_icmpv6_code_masked.
 * @param value_mask Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_oxm_icmpv6_code_masked_value_mask_get(
    of_oxm_icmpv6_code_masked_t *obj,
    uint8_t *value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ICMPV6_CODE_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 5;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value_mask in an object of type of_oxm_icmpv6_code_masked.
 * @param obj Pointer to an object of type of_oxm_icmpv6_code_masked.
 * @param value_mask The value to write into the object
 */
void
of_oxm_icmpv6_code_masked_value_mask_set(
    of_oxm_icmpv6_code_masked_t *obj,
    uint8_t value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ICMPV6_CODE_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 5;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_icmpv6_type */
/** \ingroup of_oxm_icmpv6_type 
 * @{ */

/**
 * Get value from an object of type of_oxm_icmpv6_type.
 * @param obj Pointer to an object of type of_oxm_icmpv6_type.
 * @param value Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_oxm_icmpv6_type_value_get(
    of_oxm_icmpv6_type_t *obj,
    uint8_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ICMPV6_TYPE);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_icmpv6_type.
 * @param obj Pointer to an object of type of_oxm_icmpv6_type.
 * @param value The value to write into the object
 */
void
of_oxm_icmpv6_type_value_set(
    of_oxm_icmpv6_type_t *obj,
    uint8_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ICMPV6_TYPE);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_icmpv6_type_masked */
/** \ingroup of_oxm_icmpv6_type_masked 
 * @{ */

/**
 * Get value from an object of type of_oxm_icmpv6_type_masked.
 * @param obj Pointer to an object of type of_oxm_icmpv6_type_masked.
 * @param value Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_oxm_icmpv6_type_masked_value_get(
    of_oxm_icmpv6_type_masked_t *obj,
    uint8_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ICMPV6_TYPE_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_icmpv6_type_masked.
 * @param obj Pointer to an object of type of_oxm_icmpv6_type_masked.
 * @param value The value to write into the object
 */
void
of_oxm_icmpv6_type_masked_value_set(
    of_oxm_icmpv6_type_masked_t *obj,
    uint8_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ICMPV6_TYPE_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get value_mask from an object of type of_oxm_icmpv6_type_masked.
 * @param obj Pointer to an object of type of_oxm_icmpv6_type_masked.
 * @param value_mask Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_oxm_icmpv6_type_masked_value_mask_get(
    of_oxm_icmpv6_type_masked_t *obj,
    uint8_t *value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ICMPV6_TYPE_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 5;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value_mask in an object of type of_oxm_icmpv6_type_masked.
 * @param obj Pointer to an object of type of_oxm_icmpv6_type_masked.
 * @param value_mask The value to write into the object
 */
void
of_oxm_icmpv6_type_masked_value_mask_set(
    of_oxm_icmpv6_type_masked_t *obj,
    uint8_t value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_ICMPV6_TYPE_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 5;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_in_phy_port */
/** \ingroup of_oxm_in_phy_port 
 * @{ */

/**
 * Get value from an object of type of_oxm_in_phy_port.
 * @param obj Pointer to an object of type of_oxm_in_phy_port.
 * @param value Pointer to the child object of type
 * of_port_no_t to be filled out.
 *
 */
void
of_oxm_in_phy_port_value_get(
    of_oxm_in_phy_port_t *obj,
    of_port_no_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IN_PHY_PORT);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_get(ver, wbuf, abs_offset, value);
    OF_PORT_NO_VALUE_CHECK(*value, ver);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_in_phy_port.
 * @param obj Pointer to an object of type of_oxm_in_phy_port.
 * @param value The value to write into the object
 */
void
of_oxm_in_phy_port_value_set(
    of_oxm_in_phy_port_t *obj,
    of_port_no_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IN_PHY_PORT);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_set(ver, wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_in_phy_port_masked */
/** \ingroup of_oxm_in_phy_port_masked 
 * @{ */

/**
 * Get value from an object of type of_oxm_in_phy_port_masked.
 * @param obj Pointer to an object of type of_oxm_in_phy_port_masked.
 * @param value Pointer to the child object of type
 * of_port_no_t to be filled out.
 *
 */
void
of_oxm_in_phy_port_masked_value_get(
    of_oxm_in_phy_port_masked_t *obj,
    of_port_no_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IN_PHY_PORT_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_get(ver, wbuf, abs_offset, value);
    OF_PORT_NO_VALUE_CHECK(*value, ver);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_in_phy_port_masked.
 * @param obj Pointer to an object of type of_oxm_in_phy_port_masked.
 * @param value The value to write into the object
 */
void
of_oxm_in_phy_port_masked_value_set(
    of_oxm_in_phy_port_masked_t *obj,
    of_port_no_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IN_PHY_PORT_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_set(ver, wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get value_mask from an object of type of_oxm_in_phy_port_masked.
 * @param obj Pointer to an object of type of_oxm_in_phy_port_masked.
 * @param value_mask Pointer to the child object of type
 * of_port_no_t to be filled out.
 *
 */
void
of_oxm_in_phy_port_masked_value_mask_get(
    of_oxm_in_phy_port_masked_t *obj,
    of_port_no_t *value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IN_PHY_PORT_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_get(ver, wbuf, abs_offset, value_mask);
    OF_PORT_NO_VALUE_CHECK(*value_mask, ver);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value_mask in an object of type of_oxm_in_phy_port_masked.
 * @param obj Pointer to an object of type of_oxm_in_phy_port_masked.
 * @param value_mask The value to write into the object
 */
void
of_oxm_in_phy_port_masked_value_mask_set(
    of_oxm_in_phy_port_masked_t *obj,
    of_port_no_t value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IN_PHY_PORT_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_set(ver, wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_in_port */
/** \ingroup of_oxm_in_port 
 * @{ */

/**
 * Get value from an object of type of_oxm_in_port.
 * @param obj Pointer to an object of type of_oxm_in_port.
 * @param value Pointer to the child object of type
 * of_port_no_t to be filled out.
 *
 */
void
of_oxm_in_port_value_get(
    of_oxm_in_port_t *obj,
    of_port_no_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IN_PORT);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_get(ver, wbuf, abs_offset, value);
    OF_PORT_NO_VALUE_CHECK(*value, ver);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_in_port.
 * @param obj Pointer to an object of type of_oxm_in_port.
 * @param value The value to write into the object
 */
void
of_oxm_in_port_value_set(
    of_oxm_in_port_t *obj,
    of_port_no_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IN_PORT);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_set(ver, wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_in_port_masked */
/** \ingroup of_oxm_in_port_masked 
 * @{ */

/**
 * Get value from an object of type of_oxm_in_port_masked.
 * @param obj Pointer to an object of type of_oxm_in_port_masked.
 * @param value Pointer to the child object of type
 * of_port_no_t to be filled out.
 *
 */
void
of_oxm_in_port_masked_value_get(
    of_oxm_in_port_masked_t *obj,
    of_port_no_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IN_PORT_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_get(ver, wbuf, abs_offset, value);
    OF_PORT_NO_VALUE_CHECK(*value, ver);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_in_port_masked.
 * @param obj Pointer to an object of type of_oxm_in_port_masked.
 * @param value The value to write into the object
 */
void
of_oxm_in_port_masked_value_set(
    of_oxm_in_port_masked_t *obj,
    of_port_no_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IN_PORT_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_set(ver, wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get value_mask from an object of type of_oxm_in_port_masked.
 * @param obj Pointer to an object of type of_oxm_in_port_masked.
 * @param value_mask Pointer to the child object of type
 * of_port_no_t to be filled out.
 *
 */
void
of_oxm_in_port_masked_value_mask_get(
    of_oxm_in_port_masked_t *obj,
    of_port_no_t *value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IN_PORT_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_get(ver, wbuf, abs_offset, value_mask);
    OF_PORT_NO_VALUE_CHECK(*value_mask, ver);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value_mask in an object of type of_oxm_in_port_masked.
 * @param obj Pointer to an object of type of_oxm_in_port_masked.
 * @param value_mask The value to write into the object
 */
void
of_oxm_in_port_masked_value_mask_set(
    of_oxm_in_port_masked_t *obj,
    of_port_no_t value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IN_PORT_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_set(ver, wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_ip_dscp */
/** \ingroup of_oxm_ip_dscp 
 * @{ */

/**
 * Get value from an object of type of_oxm_ip_dscp.
 * @param obj Pointer to an object of type of_oxm_ip_dscp.
 * @param value Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_oxm_ip_dscp_value_get(
    of_oxm_ip_dscp_t *obj,
    uint8_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IP_DSCP);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_ip_dscp.
 * @param obj Pointer to an object of type of_oxm_ip_dscp.
 * @param value The value to write into the object
 */
void
of_oxm_ip_dscp_value_set(
    of_oxm_ip_dscp_t *obj,
    uint8_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IP_DSCP);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_ip_dscp_masked */
/** \ingroup of_oxm_ip_dscp_masked 
 * @{ */

/**
 * Get value from an object of type of_oxm_ip_dscp_masked.
 * @param obj Pointer to an object of type of_oxm_ip_dscp_masked.
 * @param value Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_oxm_ip_dscp_masked_value_get(
    of_oxm_ip_dscp_masked_t *obj,
    uint8_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IP_DSCP_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_ip_dscp_masked.
 * @param obj Pointer to an object of type of_oxm_ip_dscp_masked.
 * @param value The value to write into the object
 */
void
of_oxm_ip_dscp_masked_value_set(
    of_oxm_ip_dscp_masked_t *obj,
    uint8_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IP_DSCP_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get value_mask from an object of type of_oxm_ip_dscp_masked.
 * @param obj Pointer to an object of type of_oxm_ip_dscp_masked.
 * @param value_mask Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_oxm_ip_dscp_masked_value_mask_get(
    of_oxm_ip_dscp_masked_t *obj,
    uint8_t *value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IP_DSCP_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 5;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value_mask in an object of type of_oxm_ip_dscp_masked.
 * @param obj Pointer to an object of type of_oxm_ip_dscp_masked.
 * @param value_mask The value to write into the object
 */
void
of_oxm_ip_dscp_masked_value_mask_set(
    of_oxm_ip_dscp_masked_t *obj,
    uint8_t value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IP_DSCP_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 5;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_ip_ecn */
/** \ingroup of_oxm_ip_ecn 
 * @{ */

/**
 * Get value from an object of type of_oxm_ip_ecn.
 * @param obj Pointer to an object of type of_oxm_ip_ecn.
 * @param value Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_oxm_ip_ecn_value_get(
    of_oxm_ip_ecn_t *obj,
    uint8_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IP_ECN);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_ip_ecn.
 * @param obj Pointer to an object of type of_oxm_ip_ecn.
 * @param value The value to write into the object
 */
void
of_oxm_ip_ecn_value_set(
    of_oxm_ip_ecn_t *obj,
    uint8_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IP_ECN);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_ip_ecn_masked */
/** \ingroup of_oxm_ip_ecn_masked 
 * @{ */

/**
 * Get value from an object of type of_oxm_ip_ecn_masked.
 * @param obj Pointer to an object of type of_oxm_ip_ecn_masked.
 * @param value Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_oxm_ip_ecn_masked_value_get(
    of_oxm_ip_ecn_masked_t *obj,
    uint8_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IP_ECN_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_ip_ecn_masked.
 * @param obj Pointer to an object of type of_oxm_ip_ecn_masked.
 * @param value The value to write into the object
 */
void
of_oxm_ip_ecn_masked_value_set(
    of_oxm_ip_ecn_masked_t *obj,
    uint8_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IP_ECN_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get value_mask from an object of type of_oxm_ip_ecn_masked.
 * @param obj Pointer to an object of type of_oxm_ip_ecn_masked.
 * @param value_mask Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_oxm_ip_ecn_masked_value_mask_get(
    of_oxm_ip_ecn_masked_t *obj,
    uint8_t *value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IP_ECN_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 5;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value_mask in an object of type of_oxm_ip_ecn_masked.
 * @param obj Pointer to an object of type of_oxm_ip_ecn_masked.
 * @param value_mask The value to write into the object
 */
void
of_oxm_ip_ecn_masked_value_mask_set(
    of_oxm_ip_ecn_masked_t *obj,
    uint8_t value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IP_ECN_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 5;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_ip_proto */
/** \ingroup of_oxm_ip_proto 
 * @{ */

/**
 * Get value from an object of type of_oxm_ip_proto.
 * @param obj Pointer to an object of type of_oxm_ip_proto.
 * @param value Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_oxm_ip_proto_value_get(
    of_oxm_ip_proto_t *obj,
    uint8_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IP_PROTO);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_ip_proto.
 * @param obj Pointer to an object of type of_oxm_ip_proto.
 * @param value The value to write into the object
 */
void
of_oxm_ip_proto_value_set(
    of_oxm_ip_proto_t *obj,
    uint8_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IP_PROTO);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_ip_proto_masked */
/** \ingroup of_oxm_ip_proto_masked 
 * @{ */

/**
 * Get value from an object of type of_oxm_ip_proto_masked.
 * @param obj Pointer to an object of type of_oxm_ip_proto_masked.
 * @param value Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_oxm_ip_proto_masked_value_get(
    of_oxm_ip_proto_masked_t *obj,
    uint8_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IP_PROTO_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_ip_proto_masked.
 * @param obj Pointer to an object of type of_oxm_ip_proto_masked.
 * @param value The value to write into the object
 */
void
of_oxm_ip_proto_masked_value_set(
    of_oxm_ip_proto_masked_t *obj,
    uint8_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IP_PROTO_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get value_mask from an object of type of_oxm_ip_proto_masked.
 * @param obj Pointer to an object of type of_oxm_ip_proto_masked.
 * @param value_mask Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_oxm_ip_proto_masked_value_mask_get(
    of_oxm_ip_proto_masked_t *obj,
    uint8_t *value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IP_PROTO_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 5;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value_mask in an object of type of_oxm_ip_proto_masked.
 * @param obj Pointer to an object of type of_oxm_ip_proto_masked.
 * @param value_mask The value to write into the object
 */
void
of_oxm_ip_proto_masked_value_mask_set(
    of_oxm_ip_proto_masked_t *obj,
    uint8_t value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IP_PROTO_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 5;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_ipv4_dst */
/** \ingroup of_oxm_ipv4_dst 
 * @{ */

/**
 * Get value from an object of type of_oxm_ipv4_dst.
 * @param obj Pointer to an object of type of_oxm_ipv4_dst.
 * @param value Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_oxm_ipv4_dst_value_get(
    of_oxm_ipv4_dst_t *obj,
    uint32_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IPV4_DST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_ipv4_dst.
 * @param obj Pointer to an object of type of_oxm_ipv4_dst.
 * @param value The value to write into the object
 */
void
of_oxm_ipv4_dst_value_set(
    of_oxm_ipv4_dst_t *obj,
    uint32_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IPV4_DST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_ipv4_dst_masked */
/** \ingroup of_oxm_ipv4_dst_masked 
 * @{ */

/**
 * Get value from an object of type of_oxm_ipv4_dst_masked.
 * @param obj Pointer to an object of type of_oxm_ipv4_dst_masked.
 * @param value Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_oxm_ipv4_dst_masked_value_get(
    of_oxm_ipv4_dst_masked_t *obj,
    uint32_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IPV4_DST_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_ipv4_dst_masked.
 * @param obj Pointer to an object of type of_oxm_ipv4_dst_masked.
 * @param value The value to write into the object
 */
void
of_oxm_ipv4_dst_masked_value_set(
    of_oxm_ipv4_dst_masked_t *obj,
    uint32_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IPV4_DST_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get value_mask from an object of type of_oxm_ipv4_dst_masked.
 * @param obj Pointer to an object of type of_oxm_ipv4_dst_masked.
 * @param value_mask Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_oxm_ipv4_dst_masked_value_mask_get(
    of_oxm_ipv4_dst_masked_t *obj,
    uint32_t *value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IPV4_DST_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value_mask in an object of type of_oxm_ipv4_dst_masked.
 * @param obj Pointer to an object of type of_oxm_ipv4_dst_masked.
 * @param value_mask The value to write into the object
 */
void
of_oxm_ipv4_dst_masked_value_mask_set(
    of_oxm_ipv4_dst_masked_t *obj,
    uint32_t value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IPV4_DST_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_ipv4_src */
/** \ingroup of_oxm_ipv4_src 
 * @{ */

/**
 * Get value from an object of type of_oxm_ipv4_src.
 * @param obj Pointer to an object of type of_oxm_ipv4_src.
 * @param value Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_oxm_ipv4_src_value_get(
    of_oxm_ipv4_src_t *obj,
    uint32_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IPV4_SRC);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_ipv4_src.
 * @param obj Pointer to an object of type of_oxm_ipv4_src.
 * @param value The value to write into the object
 */
void
of_oxm_ipv4_src_value_set(
    of_oxm_ipv4_src_t *obj,
    uint32_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IPV4_SRC);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_ipv4_src_masked */
/** \ingroup of_oxm_ipv4_src_masked 
 * @{ */

/**
 * Get value from an object of type of_oxm_ipv4_src_masked.
 * @param obj Pointer to an object of type of_oxm_ipv4_src_masked.
 * @param value Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_oxm_ipv4_src_masked_value_get(
    of_oxm_ipv4_src_masked_t *obj,
    uint32_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IPV4_SRC_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_ipv4_src_masked.
 * @param obj Pointer to an object of type of_oxm_ipv4_src_masked.
 * @param value The value to write into the object
 */
void
of_oxm_ipv4_src_masked_value_set(
    of_oxm_ipv4_src_masked_t *obj,
    uint32_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IPV4_SRC_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get value_mask from an object of type of_oxm_ipv4_src_masked.
 * @param obj Pointer to an object of type of_oxm_ipv4_src_masked.
 * @param value_mask Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_oxm_ipv4_src_masked_value_mask_get(
    of_oxm_ipv4_src_masked_t *obj,
    uint32_t *value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IPV4_SRC_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value_mask in an object of type of_oxm_ipv4_src_masked.
 * @param obj Pointer to an object of type of_oxm_ipv4_src_masked.
 * @param value_mask The value to write into the object
 */
void
of_oxm_ipv4_src_masked_value_mask_set(
    of_oxm_ipv4_src_masked_t *obj,
    uint32_t value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IPV4_SRC_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_ipv6_dst */
/** \ingroup of_oxm_ipv6_dst 
 * @{ */

/**
 * Get value from an object of type of_oxm_ipv6_dst.
 * @param obj Pointer to an object of type of_oxm_ipv6_dst.
 * @param value Pointer to the child object of type
 * of_ipv6_t to be filled out.
 *
 */
void
of_oxm_ipv6_dst_value_get(
    of_oxm_ipv6_dst_t *obj,
    of_ipv6_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IPV6_DST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_ipv6_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_ipv6_dst.
 * @param obj Pointer to an object of type of_oxm_ipv6_dst.
 * @param value The value to write into the object
 */
void
of_oxm_ipv6_dst_value_set(
    of_oxm_ipv6_dst_t *obj,
    of_ipv6_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IPV6_DST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_ipv6_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_ipv6_dst_masked */
/** \ingroup of_oxm_ipv6_dst_masked 
 * @{ */

/**
 * Get value from an object of type of_oxm_ipv6_dst_masked.
 * @param obj Pointer to an object of type of_oxm_ipv6_dst_masked.
 * @param value Pointer to the child object of type
 * of_ipv6_t to be filled out.
 *
 */
void
of_oxm_ipv6_dst_masked_value_get(
    of_oxm_ipv6_dst_masked_t *obj,
    of_ipv6_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IPV6_DST_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_ipv6_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_ipv6_dst_masked.
 * @param obj Pointer to an object of type of_oxm_ipv6_dst_masked.
 * @param value The value to write into the object
 */
void
of_oxm_ipv6_dst_masked_value_set(
    of_oxm_ipv6_dst_masked_t *obj,
    of_ipv6_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IPV6_DST_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_ipv6_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get value_mask from an object of type of_oxm_ipv6_dst_masked.
 * @param obj Pointer to an object of type of_oxm_ipv6_dst_masked.
 * @param value_mask Pointer to the child object of type
 * of_ipv6_t to be filled out.
 *
 */
void
of_oxm_ipv6_dst_masked_value_mask_get(
    of_oxm_ipv6_dst_masked_t *obj,
    of_ipv6_t *value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IPV6_DST_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 20;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_ipv6_get(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value_mask in an object of type of_oxm_ipv6_dst_masked.
 * @param obj Pointer to an object of type of_oxm_ipv6_dst_masked.
 * @param value_mask The value to write into the object
 */
void
of_oxm_ipv6_dst_masked_value_mask_set(
    of_oxm_ipv6_dst_masked_t *obj,
    of_ipv6_t value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IPV6_DST_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 20;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_ipv6_set(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_ipv6_flabel */
/** \ingroup of_oxm_ipv6_flabel 
 * @{ */

/**
 * Get value from an object of type of_oxm_ipv6_flabel.
 * @param obj Pointer to an object of type of_oxm_ipv6_flabel.
 * @param value Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_oxm_ipv6_flabel_value_get(
    of_oxm_ipv6_flabel_t *obj,
    uint32_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IPV6_FLABEL);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_ipv6_flabel.
 * @param obj Pointer to an object of type of_oxm_ipv6_flabel.
 * @param value The value to write into the object
 */
void
of_oxm_ipv6_flabel_value_set(
    of_oxm_ipv6_flabel_t *obj,
    uint32_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IPV6_FLABEL);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_ipv6_flabel_masked */
/** \ingroup of_oxm_ipv6_flabel_masked 
 * @{ */

/**
 * Get value from an object of type of_oxm_ipv6_flabel_masked.
 * @param obj Pointer to an object of type of_oxm_ipv6_flabel_masked.
 * @param value Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_oxm_ipv6_flabel_masked_value_get(
    of_oxm_ipv6_flabel_masked_t *obj,
    uint32_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IPV6_FLABEL_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_ipv6_flabel_masked.
 * @param obj Pointer to an object of type of_oxm_ipv6_flabel_masked.
 * @param value The value to write into the object
 */
void
of_oxm_ipv6_flabel_masked_value_set(
    of_oxm_ipv6_flabel_masked_t *obj,
    uint32_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IPV6_FLABEL_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get value_mask from an object of type of_oxm_ipv6_flabel_masked.
 * @param obj Pointer to an object of type of_oxm_ipv6_flabel_masked.
 * @param value_mask Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_oxm_ipv6_flabel_masked_value_mask_get(
    of_oxm_ipv6_flabel_masked_t *obj,
    uint32_t *value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IPV6_FLABEL_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value_mask in an object of type of_oxm_ipv6_flabel_masked.
 * @param obj Pointer to an object of type of_oxm_ipv6_flabel_masked.
 * @param value_mask The value to write into the object
 */
void
of_oxm_ipv6_flabel_masked_value_mask_set(
    of_oxm_ipv6_flabel_masked_t *obj,
    uint32_t value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IPV6_FLABEL_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_ipv6_nd_sll */
/** \ingroup of_oxm_ipv6_nd_sll 
 * @{ */

/**
 * Get value from an object of type of_oxm_ipv6_nd_sll.
 * @param obj Pointer to an object of type of_oxm_ipv6_nd_sll.
 * @param value Pointer to the child object of type
 * of_mac_addr_t to be filled out.
 *
 */
void
of_oxm_ipv6_nd_sll_value_get(
    of_oxm_ipv6_nd_sll_t *obj,
    of_mac_addr_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IPV6_ND_SLL);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_ipv6_nd_sll.
 * @param obj Pointer to an object of type of_oxm_ipv6_nd_sll.
 * @param value The value to write into the object
 */
void
of_oxm_ipv6_nd_sll_value_set(
    of_oxm_ipv6_nd_sll_t *obj,
    of_mac_addr_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IPV6_ND_SLL);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_ipv6_nd_sll_masked */
/** \ingroup of_oxm_ipv6_nd_sll_masked 
 * @{ */

/**
 * Get value from an object of type of_oxm_ipv6_nd_sll_masked.
 * @param obj Pointer to an object of type of_oxm_ipv6_nd_sll_masked.
 * @param value Pointer to the child object of type
 * of_mac_addr_t to be filled out.
 *
 */
void
of_oxm_ipv6_nd_sll_masked_value_get(
    of_oxm_ipv6_nd_sll_masked_t *obj,
    of_mac_addr_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IPV6_ND_SLL_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_ipv6_nd_sll_masked.
 * @param obj Pointer to an object of type of_oxm_ipv6_nd_sll_masked.
 * @param value The value to write into the object
 */
void
of_oxm_ipv6_nd_sll_masked_value_set(
    of_oxm_ipv6_nd_sll_masked_t *obj,
    of_mac_addr_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IPV6_ND_SLL_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get value_mask from an object of type of_oxm_ipv6_nd_sll_masked.
 * @param obj Pointer to an object of type of_oxm_ipv6_nd_sll_masked.
 * @param value_mask Pointer to the child object of type
 * of_mac_addr_t to be filled out.
 *
 */
void
of_oxm_ipv6_nd_sll_masked_value_mask_get(
    of_oxm_ipv6_nd_sll_masked_t *obj,
    of_mac_addr_t *value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IPV6_ND_SLL_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_get(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value_mask in an object of type of_oxm_ipv6_nd_sll_masked.
 * @param obj Pointer to an object of type of_oxm_ipv6_nd_sll_masked.
 * @param value_mask The value to write into the object
 */
void
of_oxm_ipv6_nd_sll_masked_value_mask_set(
    of_oxm_ipv6_nd_sll_masked_t *obj,
    of_mac_addr_t value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IPV6_ND_SLL_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_set(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_ipv6_nd_target */
/** \ingroup of_oxm_ipv6_nd_target 
 * @{ */

/**
 * Get value from an object of type of_oxm_ipv6_nd_target.
 * @param obj Pointer to an object of type of_oxm_ipv6_nd_target.
 * @param value Pointer to the child object of type
 * of_ipv6_t to be filled out.
 *
 */
void
of_oxm_ipv6_nd_target_value_get(
    of_oxm_ipv6_nd_target_t *obj,
    of_ipv6_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IPV6_ND_TARGET);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_ipv6_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_ipv6_nd_target.
 * @param obj Pointer to an object of type of_oxm_ipv6_nd_target.
 * @param value The value to write into the object
 */
void
of_oxm_ipv6_nd_target_value_set(
    of_oxm_ipv6_nd_target_t *obj,
    of_ipv6_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IPV6_ND_TARGET);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_ipv6_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_ipv6_nd_target_masked */
/** \ingroup of_oxm_ipv6_nd_target_masked 
 * @{ */

/**
 * Get value from an object of type of_oxm_ipv6_nd_target_masked.
 * @param obj Pointer to an object of type of_oxm_ipv6_nd_target_masked.
 * @param value Pointer to the child object of type
 * of_ipv6_t to be filled out.
 *
 */
void
of_oxm_ipv6_nd_target_masked_value_get(
    of_oxm_ipv6_nd_target_masked_t *obj,
    of_ipv6_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IPV6_ND_TARGET_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_ipv6_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_ipv6_nd_target_masked.
 * @param obj Pointer to an object of type of_oxm_ipv6_nd_target_masked.
 * @param value The value to write into the object
 */
void
of_oxm_ipv6_nd_target_masked_value_set(
    of_oxm_ipv6_nd_target_masked_t *obj,
    of_ipv6_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IPV6_ND_TARGET_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_ipv6_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get value_mask from an object of type of_oxm_ipv6_nd_target_masked.
 * @param obj Pointer to an object of type of_oxm_ipv6_nd_target_masked.
 * @param value_mask Pointer to the child object of type
 * of_ipv6_t to be filled out.
 *
 */
void
of_oxm_ipv6_nd_target_masked_value_mask_get(
    of_oxm_ipv6_nd_target_masked_t *obj,
    of_ipv6_t *value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IPV6_ND_TARGET_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 20;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_ipv6_get(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value_mask in an object of type of_oxm_ipv6_nd_target_masked.
 * @param obj Pointer to an object of type of_oxm_ipv6_nd_target_masked.
 * @param value_mask The value to write into the object
 */
void
of_oxm_ipv6_nd_target_masked_value_mask_set(
    of_oxm_ipv6_nd_target_masked_t *obj,
    of_ipv6_t value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IPV6_ND_TARGET_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 20;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_ipv6_set(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_ipv6_nd_tll */
/** \ingroup of_oxm_ipv6_nd_tll 
 * @{ */

/**
 * Get value from an object of type of_oxm_ipv6_nd_tll.
 * @param obj Pointer to an object of type of_oxm_ipv6_nd_tll.
 * @param value Pointer to the child object of type
 * of_mac_addr_t to be filled out.
 *
 */
void
of_oxm_ipv6_nd_tll_value_get(
    of_oxm_ipv6_nd_tll_t *obj,
    of_mac_addr_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IPV6_ND_TLL);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_ipv6_nd_tll.
 * @param obj Pointer to an object of type of_oxm_ipv6_nd_tll.
 * @param value The value to write into the object
 */
void
of_oxm_ipv6_nd_tll_value_set(
    of_oxm_ipv6_nd_tll_t *obj,
    of_mac_addr_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IPV6_ND_TLL);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_ipv6_nd_tll_masked */
/** \ingroup of_oxm_ipv6_nd_tll_masked 
 * @{ */

/**
 * Get value from an object of type of_oxm_ipv6_nd_tll_masked.
 * @param obj Pointer to an object of type of_oxm_ipv6_nd_tll_masked.
 * @param value Pointer to the child object of type
 * of_mac_addr_t to be filled out.
 *
 */
void
of_oxm_ipv6_nd_tll_masked_value_get(
    of_oxm_ipv6_nd_tll_masked_t *obj,
    of_mac_addr_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IPV6_ND_TLL_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_ipv6_nd_tll_masked.
 * @param obj Pointer to an object of type of_oxm_ipv6_nd_tll_masked.
 * @param value The value to write into the object
 */
void
of_oxm_ipv6_nd_tll_masked_value_set(
    of_oxm_ipv6_nd_tll_masked_t *obj,
    of_mac_addr_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IPV6_ND_TLL_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get value_mask from an object of type of_oxm_ipv6_nd_tll_masked.
 * @param obj Pointer to an object of type of_oxm_ipv6_nd_tll_masked.
 * @param value_mask Pointer to the child object of type
 * of_mac_addr_t to be filled out.
 *
 */
void
of_oxm_ipv6_nd_tll_masked_value_mask_get(
    of_oxm_ipv6_nd_tll_masked_t *obj,
    of_mac_addr_t *value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IPV6_ND_TLL_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_get(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value_mask in an object of type of_oxm_ipv6_nd_tll_masked.
 * @param obj Pointer to an object of type of_oxm_ipv6_nd_tll_masked.
 * @param value_mask The value to write into the object
 */
void
of_oxm_ipv6_nd_tll_masked_value_mask_set(
    of_oxm_ipv6_nd_tll_masked_t *obj,
    of_mac_addr_t value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IPV6_ND_TLL_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 10;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_set(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_ipv6_src */
/** \ingroup of_oxm_ipv6_src 
 * @{ */

/**
 * Get value from an object of type of_oxm_ipv6_src.
 * @param obj Pointer to an object of type of_oxm_ipv6_src.
 * @param value Pointer to the child object of type
 * of_ipv6_t to be filled out.
 *
 */
void
of_oxm_ipv6_src_value_get(
    of_oxm_ipv6_src_t *obj,
    of_ipv6_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IPV6_SRC);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_ipv6_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_ipv6_src.
 * @param obj Pointer to an object of type of_oxm_ipv6_src.
 * @param value The value to write into the object
 */
void
of_oxm_ipv6_src_value_set(
    of_oxm_ipv6_src_t *obj,
    of_ipv6_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IPV6_SRC);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_ipv6_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_ipv6_src_masked */
/** \ingroup of_oxm_ipv6_src_masked 
 * @{ */

/**
 * Get value from an object of type of_oxm_ipv6_src_masked.
 * @param obj Pointer to an object of type of_oxm_ipv6_src_masked.
 * @param value Pointer to the child object of type
 * of_ipv6_t to be filled out.
 *
 */
void
of_oxm_ipv6_src_masked_value_get(
    of_oxm_ipv6_src_masked_t *obj,
    of_ipv6_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IPV6_SRC_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_ipv6_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_ipv6_src_masked.
 * @param obj Pointer to an object of type of_oxm_ipv6_src_masked.
 * @param value The value to write into the object
 */
void
of_oxm_ipv6_src_masked_value_set(
    of_oxm_ipv6_src_masked_t *obj,
    of_ipv6_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IPV6_SRC_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_ipv6_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get value_mask from an object of type of_oxm_ipv6_src_masked.
 * @param obj Pointer to an object of type of_oxm_ipv6_src_masked.
 * @param value_mask Pointer to the child object of type
 * of_ipv6_t to be filled out.
 *
 */
void
of_oxm_ipv6_src_masked_value_mask_get(
    of_oxm_ipv6_src_masked_t *obj,
    of_ipv6_t *value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IPV6_SRC_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 20;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_ipv6_get(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value_mask in an object of type of_oxm_ipv6_src_masked.
 * @param obj Pointer to an object of type of_oxm_ipv6_src_masked.
 * @param value_mask The value to write into the object
 */
void
of_oxm_ipv6_src_masked_value_mask_set(
    of_oxm_ipv6_src_masked_t *obj,
    of_ipv6_t value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_IPV6_SRC_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 20;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_ipv6_set(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_metadata */
/** \ingroup of_oxm_metadata 
 * @{ */

/**
 * Get value from an object of type of_oxm_metadata.
 * @param obj Pointer to an object of type of_oxm_metadata.
 * @param value Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_oxm_metadata_value_get(
    of_oxm_metadata_t *obj,
    uint64_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_METADATA);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_metadata.
 * @param obj Pointer to an object of type of_oxm_metadata.
 * @param value The value to write into the object
 */
void
of_oxm_metadata_value_set(
    of_oxm_metadata_t *obj,
    uint64_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_METADATA);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_metadata_masked */
/** \ingroup of_oxm_metadata_masked 
 * @{ */

/**
 * Get value from an object of type of_oxm_metadata_masked.
 * @param obj Pointer to an object of type of_oxm_metadata_masked.
 * @param value Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_oxm_metadata_masked_value_get(
    of_oxm_metadata_masked_t *obj,
    uint64_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_METADATA_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_metadata_masked.
 * @param obj Pointer to an object of type of_oxm_metadata_masked.
 * @param value The value to write into the object
 */
void
of_oxm_metadata_masked_value_set(
    of_oxm_metadata_masked_t *obj,
    uint64_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_METADATA_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get value_mask from an object of type of_oxm_metadata_masked.
 * @param obj Pointer to an object of type of_oxm_metadata_masked.
 * @param value_mask Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_oxm_metadata_masked_value_mask_get(
    of_oxm_metadata_masked_t *obj,
    uint64_t *value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_METADATA_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value_mask in an object of type of_oxm_metadata_masked.
 * @param obj Pointer to an object of type of_oxm_metadata_masked.
 * @param value_mask The value to write into the object
 */
void
of_oxm_metadata_masked_value_mask_set(
    of_oxm_metadata_masked_t *obj,
    uint64_t value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_METADATA_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 12;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_mpls_label */
/** \ingroup of_oxm_mpls_label 
 * @{ */

/**
 * Get value from an object of type of_oxm_mpls_label.
 * @param obj Pointer to an object of type of_oxm_mpls_label.
 * @param value Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_oxm_mpls_label_value_get(
    of_oxm_mpls_label_t *obj,
    uint32_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_MPLS_LABEL);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_mpls_label.
 * @param obj Pointer to an object of type of_oxm_mpls_label.
 * @param value The value to write into the object
 */
void
of_oxm_mpls_label_value_set(
    of_oxm_mpls_label_t *obj,
    uint32_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_MPLS_LABEL);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_mpls_label_masked */
/** \ingroup of_oxm_mpls_label_masked 
 * @{ */

/**
 * Get value from an object of type of_oxm_mpls_label_masked.
 * @param obj Pointer to an object of type of_oxm_mpls_label_masked.
 * @param value Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_oxm_mpls_label_masked_value_get(
    of_oxm_mpls_label_masked_t *obj,
    uint32_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_MPLS_LABEL_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_mpls_label_masked.
 * @param obj Pointer to an object of type of_oxm_mpls_label_masked.
 * @param value The value to write into the object
 */
void
of_oxm_mpls_label_masked_value_set(
    of_oxm_mpls_label_masked_t *obj,
    uint32_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_MPLS_LABEL_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get value_mask from an object of type of_oxm_mpls_label_masked.
 * @param obj Pointer to an object of type of_oxm_mpls_label_masked.
 * @param value_mask Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_oxm_mpls_label_masked_value_mask_get(
    of_oxm_mpls_label_masked_t *obj,
    uint32_t *value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_MPLS_LABEL_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value_mask in an object of type of_oxm_mpls_label_masked.
 * @param obj Pointer to an object of type of_oxm_mpls_label_masked.
 * @param value_mask The value to write into the object
 */
void
of_oxm_mpls_label_masked_value_mask_set(
    of_oxm_mpls_label_masked_t *obj,
    uint32_t value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_MPLS_LABEL_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_mpls_tc */
/** \ingroup of_oxm_mpls_tc 
 * @{ */

/**
 * Get value from an object of type of_oxm_mpls_tc.
 * @param obj Pointer to an object of type of_oxm_mpls_tc.
 * @param value Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_oxm_mpls_tc_value_get(
    of_oxm_mpls_tc_t *obj,
    uint8_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_MPLS_TC);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_mpls_tc.
 * @param obj Pointer to an object of type of_oxm_mpls_tc.
 * @param value The value to write into the object
 */
void
of_oxm_mpls_tc_value_set(
    of_oxm_mpls_tc_t *obj,
    uint8_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_MPLS_TC);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_mpls_tc_masked */
/** \ingroup of_oxm_mpls_tc_masked 
 * @{ */

/**
 * Get value from an object of type of_oxm_mpls_tc_masked.
 * @param obj Pointer to an object of type of_oxm_mpls_tc_masked.
 * @param value Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_oxm_mpls_tc_masked_value_get(
    of_oxm_mpls_tc_masked_t *obj,
    uint8_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_MPLS_TC_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_mpls_tc_masked.
 * @param obj Pointer to an object of type of_oxm_mpls_tc_masked.
 * @param value The value to write into the object
 */
void
of_oxm_mpls_tc_masked_value_set(
    of_oxm_mpls_tc_masked_t *obj,
    uint8_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_MPLS_TC_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get value_mask from an object of type of_oxm_mpls_tc_masked.
 * @param obj Pointer to an object of type of_oxm_mpls_tc_masked.
 * @param value_mask Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_oxm_mpls_tc_masked_value_mask_get(
    of_oxm_mpls_tc_masked_t *obj,
    uint8_t *value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_MPLS_TC_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 5;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value_mask in an object of type of_oxm_mpls_tc_masked.
 * @param obj Pointer to an object of type of_oxm_mpls_tc_masked.
 * @param value_mask The value to write into the object
 */
void
of_oxm_mpls_tc_masked_value_mask_set(
    of_oxm_mpls_tc_masked_t *obj,
    uint8_t value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_MPLS_TC_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 5;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_sctp_dst */
/** \ingroup of_oxm_sctp_dst 
 * @{ */

/**
 * Get value from an object of type of_oxm_sctp_dst.
 * @param obj Pointer to an object of type of_oxm_sctp_dst.
 * @param value Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_oxm_sctp_dst_value_get(
    of_oxm_sctp_dst_t *obj,
    uint16_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_SCTP_DST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_sctp_dst.
 * @param obj Pointer to an object of type of_oxm_sctp_dst.
 * @param value The value to write into the object
 */
void
of_oxm_sctp_dst_value_set(
    of_oxm_sctp_dst_t *obj,
    uint16_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_SCTP_DST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_sctp_dst_masked */
/** \ingroup of_oxm_sctp_dst_masked 
 * @{ */

/**
 * Get value from an object of type of_oxm_sctp_dst_masked.
 * @param obj Pointer to an object of type of_oxm_sctp_dst_masked.
 * @param value Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_oxm_sctp_dst_masked_value_get(
    of_oxm_sctp_dst_masked_t *obj,
    uint16_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_SCTP_DST_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_sctp_dst_masked.
 * @param obj Pointer to an object of type of_oxm_sctp_dst_masked.
 * @param value The value to write into the object
 */
void
of_oxm_sctp_dst_masked_value_set(
    of_oxm_sctp_dst_masked_t *obj,
    uint16_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_SCTP_DST_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get value_mask from an object of type of_oxm_sctp_dst_masked.
 * @param obj Pointer to an object of type of_oxm_sctp_dst_masked.
 * @param value_mask Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_oxm_sctp_dst_masked_value_mask_get(
    of_oxm_sctp_dst_masked_t *obj,
    uint16_t *value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_SCTP_DST_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 6;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value_mask in an object of type of_oxm_sctp_dst_masked.
 * @param obj Pointer to an object of type of_oxm_sctp_dst_masked.
 * @param value_mask The value to write into the object
 */
void
of_oxm_sctp_dst_masked_value_mask_set(
    of_oxm_sctp_dst_masked_t *obj,
    uint16_t value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_SCTP_DST_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 6;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_sctp_src */
/** \ingroup of_oxm_sctp_src 
 * @{ */

/**
 * Get value from an object of type of_oxm_sctp_src.
 * @param obj Pointer to an object of type of_oxm_sctp_src.
 * @param value Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_oxm_sctp_src_value_get(
    of_oxm_sctp_src_t *obj,
    uint16_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_SCTP_SRC);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_sctp_src.
 * @param obj Pointer to an object of type of_oxm_sctp_src.
 * @param value The value to write into the object
 */
void
of_oxm_sctp_src_value_set(
    of_oxm_sctp_src_t *obj,
    uint16_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_SCTP_SRC);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_sctp_src_masked */
/** \ingroup of_oxm_sctp_src_masked 
 * @{ */

/**
 * Get value from an object of type of_oxm_sctp_src_masked.
 * @param obj Pointer to an object of type of_oxm_sctp_src_masked.
 * @param value Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_oxm_sctp_src_masked_value_get(
    of_oxm_sctp_src_masked_t *obj,
    uint16_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_SCTP_SRC_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_sctp_src_masked.
 * @param obj Pointer to an object of type of_oxm_sctp_src_masked.
 * @param value The value to write into the object
 */
void
of_oxm_sctp_src_masked_value_set(
    of_oxm_sctp_src_masked_t *obj,
    uint16_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_SCTP_SRC_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get value_mask from an object of type of_oxm_sctp_src_masked.
 * @param obj Pointer to an object of type of_oxm_sctp_src_masked.
 * @param value_mask Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_oxm_sctp_src_masked_value_mask_get(
    of_oxm_sctp_src_masked_t *obj,
    uint16_t *value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_SCTP_SRC_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 6;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value_mask in an object of type of_oxm_sctp_src_masked.
 * @param obj Pointer to an object of type of_oxm_sctp_src_masked.
 * @param value_mask The value to write into the object
 */
void
of_oxm_sctp_src_masked_value_mask_set(
    of_oxm_sctp_src_masked_t *obj,
    uint16_t value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_SCTP_SRC_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 6;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_tcp_dst */
/** \ingroup of_oxm_tcp_dst 
 * @{ */

/**
 * Get value from an object of type of_oxm_tcp_dst.
 * @param obj Pointer to an object of type of_oxm_tcp_dst.
 * @param value Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_oxm_tcp_dst_value_get(
    of_oxm_tcp_dst_t *obj,
    uint16_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_TCP_DST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_tcp_dst.
 * @param obj Pointer to an object of type of_oxm_tcp_dst.
 * @param value The value to write into the object
 */
void
of_oxm_tcp_dst_value_set(
    of_oxm_tcp_dst_t *obj,
    uint16_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_TCP_DST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_tcp_dst_masked */
/** \ingroup of_oxm_tcp_dst_masked 
 * @{ */

/**
 * Get value from an object of type of_oxm_tcp_dst_masked.
 * @param obj Pointer to an object of type of_oxm_tcp_dst_masked.
 * @param value Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_oxm_tcp_dst_masked_value_get(
    of_oxm_tcp_dst_masked_t *obj,
    uint16_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_TCP_DST_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_tcp_dst_masked.
 * @param obj Pointer to an object of type of_oxm_tcp_dst_masked.
 * @param value The value to write into the object
 */
void
of_oxm_tcp_dst_masked_value_set(
    of_oxm_tcp_dst_masked_t *obj,
    uint16_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_TCP_DST_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get value_mask from an object of type of_oxm_tcp_dst_masked.
 * @param obj Pointer to an object of type of_oxm_tcp_dst_masked.
 * @param value_mask Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_oxm_tcp_dst_masked_value_mask_get(
    of_oxm_tcp_dst_masked_t *obj,
    uint16_t *value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_TCP_DST_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 6;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value_mask in an object of type of_oxm_tcp_dst_masked.
 * @param obj Pointer to an object of type of_oxm_tcp_dst_masked.
 * @param value_mask The value to write into the object
 */
void
of_oxm_tcp_dst_masked_value_mask_set(
    of_oxm_tcp_dst_masked_t *obj,
    uint16_t value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_TCP_DST_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 6;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_tcp_src */
/** \ingroup of_oxm_tcp_src 
 * @{ */

/**
 * Get value from an object of type of_oxm_tcp_src.
 * @param obj Pointer to an object of type of_oxm_tcp_src.
 * @param value Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_oxm_tcp_src_value_get(
    of_oxm_tcp_src_t *obj,
    uint16_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_TCP_SRC);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_tcp_src.
 * @param obj Pointer to an object of type of_oxm_tcp_src.
 * @param value The value to write into the object
 */
void
of_oxm_tcp_src_value_set(
    of_oxm_tcp_src_t *obj,
    uint16_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_TCP_SRC);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_tcp_src_masked */
/** \ingroup of_oxm_tcp_src_masked 
 * @{ */

/**
 * Get value from an object of type of_oxm_tcp_src_masked.
 * @param obj Pointer to an object of type of_oxm_tcp_src_masked.
 * @param value Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_oxm_tcp_src_masked_value_get(
    of_oxm_tcp_src_masked_t *obj,
    uint16_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_TCP_SRC_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_tcp_src_masked.
 * @param obj Pointer to an object of type of_oxm_tcp_src_masked.
 * @param value The value to write into the object
 */
void
of_oxm_tcp_src_masked_value_set(
    of_oxm_tcp_src_masked_t *obj,
    uint16_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_TCP_SRC_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get value_mask from an object of type of_oxm_tcp_src_masked.
 * @param obj Pointer to an object of type of_oxm_tcp_src_masked.
 * @param value_mask Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_oxm_tcp_src_masked_value_mask_get(
    of_oxm_tcp_src_masked_t *obj,
    uint16_t *value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_TCP_SRC_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 6;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value_mask in an object of type of_oxm_tcp_src_masked.
 * @param obj Pointer to an object of type of_oxm_tcp_src_masked.
 * @param value_mask The value to write into the object
 */
void
of_oxm_tcp_src_masked_value_mask_set(
    of_oxm_tcp_src_masked_t *obj,
    uint16_t value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_TCP_SRC_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 6;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_udp_dst */
/** \ingroup of_oxm_udp_dst 
 * @{ */

/**
 * Get value from an object of type of_oxm_udp_dst.
 * @param obj Pointer to an object of type of_oxm_udp_dst.
 * @param value Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_oxm_udp_dst_value_get(
    of_oxm_udp_dst_t *obj,
    uint16_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_UDP_DST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_udp_dst.
 * @param obj Pointer to an object of type of_oxm_udp_dst.
 * @param value The value to write into the object
 */
void
of_oxm_udp_dst_value_set(
    of_oxm_udp_dst_t *obj,
    uint16_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_UDP_DST);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_udp_dst_masked */
/** \ingroup of_oxm_udp_dst_masked 
 * @{ */

/**
 * Get value from an object of type of_oxm_udp_dst_masked.
 * @param obj Pointer to an object of type of_oxm_udp_dst_masked.
 * @param value Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_oxm_udp_dst_masked_value_get(
    of_oxm_udp_dst_masked_t *obj,
    uint16_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_UDP_DST_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_udp_dst_masked.
 * @param obj Pointer to an object of type of_oxm_udp_dst_masked.
 * @param value The value to write into the object
 */
void
of_oxm_udp_dst_masked_value_set(
    of_oxm_udp_dst_masked_t *obj,
    uint16_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_UDP_DST_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get value_mask from an object of type of_oxm_udp_dst_masked.
 * @param obj Pointer to an object of type of_oxm_udp_dst_masked.
 * @param value_mask Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_oxm_udp_dst_masked_value_mask_get(
    of_oxm_udp_dst_masked_t *obj,
    uint16_t *value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_UDP_DST_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 6;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value_mask in an object of type of_oxm_udp_dst_masked.
 * @param obj Pointer to an object of type of_oxm_udp_dst_masked.
 * @param value_mask The value to write into the object
 */
void
of_oxm_udp_dst_masked_value_mask_set(
    of_oxm_udp_dst_masked_t *obj,
    uint16_t value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_UDP_DST_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 6;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_udp_src */
/** \ingroup of_oxm_udp_src 
 * @{ */

/**
 * Get value from an object of type of_oxm_udp_src.
 * @param obj Pointer to an object of type of_oxm_udp_src.
 * @param value Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_oxm_udp_src_value_get(
    of_oxm_udp_src_t *obj,
    uint16_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_UDP_SRC);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_udp_src.
 * @param obj Pointer to an object of type of_oxm_udp_src.
 * @param value The value to write into the object
 */
void
of_oxm_udp_src_value_set(
    of_oxm_udp_src_t *obj,
    uint16_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_UDP_SRC);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_udp_src_masked */
/** \ingroup of_oxm_udp_src_masked 
 * @{ */

/**
 * Get value from an object of type of_oxm_udp_src_masked.
 * @param obj Pointer to an object of type of_oxm_udp_src_masked.
 * @param value Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_oxm_udp_src_masked_value_get(
    of_oxm_udp_src_masked_t *obj,
    uint16_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_UDP_SRC_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_udp_src_masked.
 * @param obj Pointer to an object of type of_oxm_udp_src_masked.
 * @param value The value to write into the object
 */
void
of_oxm_udp_src_masked_value_set(
    of_oxm_udp_src_masked_t *obj,
    uint16_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_UDP_SRC_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get value_mask from an object of type of_oxm_udp_src_masked.
 * @param obj Pointer to an object of type of_oxm_udp_src_masked.
 * @param value_mask Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_oxm_udp_src_masked_value_mask_get(
    of_oxm_udp_src_masked_t *obj,
    uint16_t *value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_UDP_SRC_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 6;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value_mask in an object of type of_oxm_udp_src_masked.
 * @param obj Pointer to an object of type of_oxm_udp_src_masked.
 * @param value_mask The value to write into the object
 */
void
of_oxm_udp_src_masked_value_mask_set(
    of_oxm_udp_src_masked_t *obj,
    uint16_t value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_UDP_SRC_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 6;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_vlan_pcp */
/** \ingroup of_oxm_vlan_pcp 
 * @{ */

/**
 * Get value from an object of type of_oxm_vlan_pcp.
 * @param obj Pointer to an object of type of_oxm_vlan_pcp.
 * @param value Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_oxm_vlan_pcp_value_get(
    of_oxm_vlan_pcp_t *obj,
    uint8_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_VLAN_PCP);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_vlan_pcp.
 * @param obj Pointer to an object of type of_oxm_vlan_pcp.
 * @param value The value to write into the object
 */
void
of_oxm_vlan_pcp_value_set(
    of_oxm_vlan_pcp_t *obj,
    uint8_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_VLAN_PCP);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_vlan_pcp_masked */
/** \ingroup of_oxm_vlan_pcp_masked 
 * @{ */

/**
 * Get value from an object of type of_oxm_vlan_pcp_masked.
 * @param obj Pointer to an object of type of_oxm_vlan_pcp_masked.
 * @param value Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_oxm_vlan_pcp_masked_value_get(
    of_oxm_vlan_pcp_masked_t *obj,
    uint8_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_VLAN_PCP_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_vlan_pcp_masked.
 * @param obj Pointer to an object of type of_oxm_vlan_pcp_masked.
 * @param value The value to write into the object
 */
void
of_oxm_vlan_pcp_masked_value_set(
    of_oxm_vlan_pcp_masked_t *obj,
    uint8_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_VLAN_PCP_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get value_mask from an object of type of_oxm_vlan_pcp_masked.
 * @param obj Pointer to an object of type of_oxm_vlan_pcp_masked.
 * @param value_mask Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_oxm_vlan_pcp_masked_value_mask_get(
    of_oxm_vlan_pcp_masked_t *obj,
    uint8_t *value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_VLAN_PCP_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 5;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value_mask in an object of type of_oxm_vlan_pcp_masked.
 * @param obj Pointer to an object of type of_oxm_vlan_pcp_masked.
 * @param value_mask The value to write into the object
 */
void
of_oxm_vlan_pcp_masked_value_mask_set(
    of_oxm_vlan_pcp_masked_t *obj,
    uint8_t value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_VLAN_PCP_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 5;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_vlan_vid */
/** \ingroup of_oxm_vlan_vid 
 * @{ */

/**
 * Get value from an object of type of_oxm_vlan_vid.
 * @param obj Pointer to an object of type of_oxm_vlan_vid.
 * @param value Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_oxm_vlan_vid_value_get(
    of_oxm_vlan_vid_t *obj,
    uint16_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_VLAN_VID);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_vlan_vid.
 * @param obj Pointer to an object of type of_oxm_vlan_vid.
 * @param value The value to write into the object
 */
void
of_oxm_vlan_vid_value_set(
    of_oxm_vlan_vid_t *obj,
    uint16_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_VLAN_VID);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_oxm_vlan_vid_masked */
/** \ingroup of_oxm_vlan_vid_masked 
 * @{ */

/**
 * Get value from an object of type of_oxm_vlan_vid_masked.
 * @param obj Pointer to an object of type of_oxm_vlan_vid_masked.
 * @param value Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_oxm_vlan_vid_masked_value_get(
    of_oxm_vlan_vid_masked_t *obj,
    uint16_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_VLAN_VID_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_oxm_vlan_vid_masked.
 * @param obj Pointer to an object of type of_oxm_vlan_vid_masked.
 * @param value The value to write into the object
 */
void
of_oxm_vlan_vid_masked_value_set(
    of_oxm_vlan_vid_masked_t *obj,
    uint16_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_VLAN_VID_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get value_mask from an object of type of_oxm_vlan_vid_masked.
 * @param obj Pointer to an object of type of_oxm_vlan_vid_masked.
 * @param value_mask Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_oxm_vlan_vid_masked_value_mask_get(
    of_oxm_vlan_vid_masked_t *obj,
    uint16_t *value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_VLAN_VID_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 6;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value_mask in an object of type of_oxm_vlan_vid_masked.
 * @param obj Pointer to an object of type of_oxm_vlan_vid_masked.
 * @param value_mask The value to write into the object
 */
void
of_oxm_vlan_vid_masked_value_mask_set(
    of_oxm_vlan_vid_masked_t *obj,
    uint16_t value_mask)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_OXM_VLAN_VID_MASKED);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 6;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, value_mask);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_packet_queue */
/** \ingroup of_packet_queue 
 * @{ */

/**
 * Get queue_id from an object of type of_packet_queue.
 * @param obj Pointer to an object of type of_packet_queue.
 * @param queue_id Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_packet_queue_queue_id_get(
    of_packet_queue_t *obj,
    uint32_t *queue_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PACKET_QUEUE);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 0;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, queue_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set queue_id in an object of type of_packet_queue.
 * @param obj Pointer to an object of type of_packet_queue.
 * @param queue_id The value to write into the object
 */
void
of_packet_queue_queue_id_set(
    of_packet_queue_t *obj,
    uint32_t queue_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PACKET_QUEUE);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 0;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, queue_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get port from an object of type of_packet_queue.
 * @param obj Pointer to an object of type of_packet_queue.
 * @param port Pointer to the child object of type
 * of_port_no_t to be filled out.
 *
 */
void
of_packet_queue_port_get(
    of_packet_queue_t *obj,
    of_port_no_t *port)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PACKET_QUEUE);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_get(ver, wbuf, abs_offset, port);
    OF_PORT_NO_VALUE_CHECK(*port, ver);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set port in an object of type of_packet_queue.
 * @param obj Pointer to an object of type of_packet_queue.
 * @param port The value to write into the object
 */
void
of_packet_queue_port_set(
    of_packet_queue_t *obj,
    of_port_no_t port)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PACKET_QUEUE);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_set(ver, wbuf, abs_offset, port);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Bind an object of type of_list_queue_prop_t to the parent of type of_packet_queue for
 * member properties
 * @param obj Pointer to an object of type of_packet_queue.
 * @param properties Pointer to the child object of type
 * of_list_queue_prop_t to be filled out.
 * \ingroup of_packet_queue
 *
 * The parameter properties is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_packet_queue_properties_bind(
    of_packet_queue_t *obj,
    of_list_queue_prop_t *properties)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_PACKET_QUEUE);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
        offset = 8;
        cur_len = _END_LEN(obj, offset);
        break;
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_queue_prop_init(properties, obj->version, 0, 1);
    /* Attach to parent */
    properties->parent = (of_object_t *)obj;
    properties->wire_object.wbuf = obj->wire_object.wbuf;
    properties->wire_object.obj_offset = abs_offset;
    properties->wire_object.owned = 0;
    properties->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of properties into a new variable of type of_list_queue_prop_t from
 * a of_packet_queue instance.
 *
 * @param obj Pointer to the source of type of_packet_queue_t
 * @returns A pointer to a new instance of type of_list_queue_prop_t whose contents
 * match that of properties from source
 * @returns NULL if an error occurs
 */
of_list_queue_prop_t *
of_packet_queue_properties_get(of_packet_queue_t *obj) {
    of_list_queue_prop_t _properties;
    of_list_queue_prop_t *_properties_ptr;

    of_packet_queue_properties_bind(obj, &_properties);
    _properties_ptr = (of_list_queue_prop_t *)of_object_dup(&_properties);
    return _properties_ptr;
}

/**
 * Set properties in an object of type of_packet_queue.
 * @param obj Pointer to an object of type of_packet_queue.
 * @param properties Pointer to the child of type of_list_queue_prop_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_packet_queue_properties_set(
    of_packet_queue_t *obj,
    of_list_queue_prop_t *properties)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_PACKET_QUEUE);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
        offset = 8;
        cur_len = _END_LEN(obj, offset);
        break;
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = properties->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == properties->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(properties, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(properties, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (properties->wire_length_set != NULL) {
        properties->wire_length_set((of_object_t *)properties, properties->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_port_desc */
/** \ingroup of_port_desc 
 * @{ */

/**
 * Get port_no from an object of type of_port_desc.
 * @param obj Pointer to an object of type of_port_desc.
 * @param port_no Pointer to the child object of type
 * of_port_no_t to be filled out.
 *
 */
void
of_port_desc_port_no_get(
    of_port_desc_t *obj,
    of_port_no_t *port_no)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_DESC);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 0;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 0;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_get(ver, wbuf, abs_offset, port_no);
    OF_PORT_NO_VALUE_CHECK(*port_no, ver);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set port_no in an object of type of_port_desc.
 * @param obj Pointer to an object of type of_port_desc.
 * @param port_no The value to write into the object
 */
void
of_port_desc_port_no_set(
    of_port_desc_t *obj,
    of_port_no_t port_no)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_DESC);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 0;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 0;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_set(ver, wbuf, abs_offset, port_no);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get hw_addr from an object of type of_port_desc.
 * @param obj Pointer to an object of type of_port_desc.
 * @param hw_addr Pointer to the child object of type
 * of_mac_addr_t to be filled out.
 *
 */
void
of_port_desc_hw_addr_get(
    of_port_desc_t *obj,
    of_mac_addr_t *hw_addr)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_DESC);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 2;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_get(wbuf, abs_offset, hw_addr);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set hw_addr in an object of type of_port_desc.
 * @param obj Pointer to an object of type of_port_desc.
 * @param hw_addr The value to write into the object
 */
void
of_port_desc_hw_addr_set(
    of_port_desc_t *obj,
    of_mac_addr_t hw_addr)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_DESC);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 2;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_mac_set(wbuf, abs_offset, hw_addr);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get name from an object of type of_port_desc.
 * @param obj Pointer to an object of type of_port_desc.
 * @param name Pointer to the child object of type
 * of_port_name_t to be filled out.
 *
 */
void
of_port_desc_name_get(
    of_port_desc_t *obj,
    of_port_name_t *name)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_DESC);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 8;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_name_get(wbuf, abs_offset, name);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set name in an object of type of_port_desc.
 * @param obj Pointer to an object of type of_port_desc.
 * @param name The value to write into the object
 */
void
of_port_desc_name_set(
    of_port_desc_t *obj,
    of_port_name_t name)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_DESC);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 8;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_name_set(wbuf, abs_offset, name);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get config from an object of type of_port_desc.
 * @param obj Pointer to an object of type of_port_desc.
 * @param config Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_port_desc_config_get(
    of_port_desc_t *obj,
    uint32_t *config)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_DESC);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 24;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 32;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, config);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set config in an object of type of_port_desc.
 * @param obj Pointer to an object of type of_port_desc.
 * @param config The value to write into the object
 */
void
of_port_desc_config_set(
    of_port_desc_t *obj,
    uint32_t config)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_DESC);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 24;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 32;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, config);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get state from an object of type of_port_desc.
 * @param obj Pointer to an object of type of_port_desc.
 * @param state Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_port_desc_state_get(
    of_port_desc_t *obj,
    uint32_t *state)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_DESC);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 28;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 36;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, state);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set state in an object of type of_port_desc.
 * @param obj Pointer to an object of type of_port_desc.
 * @param state The value to write into the object
 */
void
of_port_desc_state_set(
    of_port_desc_t *obj,
    uint32_t state)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_DESC);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 28;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 36;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, state);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get curr from an object of type of_port_desc.
 * @param obj Pointer to an object of type of_port_desc.
 * @param curr Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_port_desc_curr_get(
    of_port_desc_t *obj,
    uint32_t *curr)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_DESC);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 32;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 40;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, curr);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set curr in an object of type of_port_desc.
 * @param obj Pointer to an object of type of_port_desc.
 * @param curr The value to write into the object
 */
void
of_port_desc_curr_set(
    of_port_desc_t *obj,
    uint32_t curr)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_DESC);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 32;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 40;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, curr);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get advertised from an object of type of_port_desc.
 * @param obj Pointer to an object of type of_port_desc.
 * @param advertised Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_port_desc_advertised_get(
    of_port_desc_t *obj,
    uint32_t *advertised)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_DESC);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 36;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 44;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, advertised);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set advertised in an object of type of_port_desc.
 * @param obj Pointer to an object of type of_port_desc.
 * @param advertised The value to write into the object
 */
void
of_port_desc_advertised_set(
    of_port_desc_t *obj,
    uint32_t advertised)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_DESC);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 36;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 44;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, advertised);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get supported from an object of type of_port_desc.
 * @param obj Pointer to an object of type of_port_desc.
 * @param supported Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_port_desc_supported_get(
    of_port_desc_t *obj,
    uint32_t *supported)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_DESC);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 40;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 48;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, supported);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set supported in an object of type of_port_desc.
 * @param obj Pointer to an object of type of_port_desc.
 * @param supported The value to write into the object
 */
void
of_port_desc_supported_set(
    of_port_desc_t *obj,
    uint32_t supported)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_DESC);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 40;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 48;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, supported);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get peer from an object of type of_port_desc.
 * @param obj Pointer to an object of type of_port_desc.
 * @param peer Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_port_desc_peer_get(
    of_port_desc_t *obj,
    uint32_t *peer)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_DESC);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 44;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 52;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, peer);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set peer in an object of type of_port_desc.
 * @param obj Pointer to an object of type of_port_desc.
 * @param peer The value to write into the object
 */
void
of_port_desc_peer_set(
    of_port_desc_t *obj,
    uint32_t peer)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_DESC);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 44;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 52;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, peer);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get curr_speed from an object of type of_port_desc.
 * @param obj Pointer to an object of type of_port_desc.
 * @param curr_speed Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_port_desc_curr_speed_get(
    of_port_desc_t *obj,
    uint32_t *curr_speed)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_DESC);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 56;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, curr_speed);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set curr_speed in an object of type of_port_desc.
 * @param obj Pointer to an object of type of_port_desc.
 * @param curr_speed The value to write into the object
 */
void
of_port_desc_curr_speed_set(
    of_port_desc_t *obj,
    uint32_t curr_speed)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_DESC);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 56;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, curr_speed);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get max_speed from an object of type of_port_desc.
 * @param obj Pointer to an object of type of_port_desc.
 * @param max_speed Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_port_desc_max_speed_get(
    of_port_desc_t *obj,
    uint32_t *max_speed)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_DESC);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 60;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, max_speed);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set max_speed in an object of type of_port_desc.
 * @param obj Pointer to an object of type of_port_desc.
 * @param max_speed The value to write into the object
 */
void
of_port_desc_max_speed_set(
    of_port_desc_t *obj,
    uint32_t max_speed)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_DESC);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 60;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, max_speed);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_port_stats_entry */
/** \ingroup of_port_stats_entry 
 * @{ */

/**
 * Get port_no from an object of type of_port_stats_entry.
 * @param obj Pointer to an object of type of_port_stats_entry.
 * @param port_no Pointer to the child object of type
 * of_port_no_t to be filled out.
 *
 */
void
of_port_stats_entry_port_no_get(
    of_port_stats_entry_t *obj,
    of_port_no_t *port_no)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 0;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 0;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_get(ver, wbuf, abs_offset, port_no);
    OF_PORT_NO_VALUE_CHECK(*port_no, ver);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set port_no in an object of type of_port_stats_entry.
 * @param obj Pointer to an object of type of_port_stats_entry.
 * @param port_no The value to write into the object
 */
void
of_port_stats_entry_port_no_set(
    of_port_stats_entry_t *obj,
    of_port_no_t port_no)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 0;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 0;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_set(ver, wbuf, abs_offset, port_no);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get rx_packets from an object of type of_port_stats_entry.
 * @param obj Pointer to an object of type of_port_stats_entry.
 * @param rx_packets Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_port_stats_entry_rx_packets_get(
    of_port_stats_entry_t *obj,
    uint64_t *rx_packets)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, rx_packets);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set rx_packets in an object of type of_port_stats_entry.
 * @param obj Pointer to an object of type of_port_stats_entry.
 * @param rx_packets The value to write into the object
 */
void
of_port_stats_entry_rx_packets_set(
    of_port_stats_entry_t *obj,
    uint64_t rx_packets)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, rx_packets);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get tx_packets from an object of type of_port_stats_entry.
 * @param obj Pointer to an object of type of_port_stats_entry.
 * @param tx_packets Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_port_stats_entry_tx_packets_get(
    of_port_stats_entry_t *obj,
    uint64_t *tx_packets)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, tx_packets);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set tx_packets in an object of type of_port_stats_entry.
 * @param obj Pointer to an object of type of_port_stats_entry.
 * @param tx_packets The value to write into the object
 */
void
of_port_stats_entry_tx_packets_set(
    of_port_stats_entry_t *obj,
    uint64_t tx_packets)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, tx_packets);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get rx_bytes from an object of type of_port_stats_entry.
 * @param obj Pointer to an object of type of_port_stats_entry.
 * @param rx_bytes Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_port_stats_entry_rx_bytes_get(
    of_port_stats_entry_t *obj,
    uint64_t *rx_bytes)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 24;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, rx_bytes);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set rx_bytes in an object of type of_port_stats_entry.
 * @param obj Pointer to an object of type of_port_stats_entry.
 * @param rx_bytes The value to write into the object
 */
void
of_port_stats_entry_rx_bytes_set(
    of_port_stats_entry_t *obj,
    uint64_t rx_bytes)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 24;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, rx_bytes);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get tx_bytes from an object of type of_port_stats_entry.
 * @param obj Pointer to an object of type of_port_stats_entry.
 * @param tx_bytes Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_port_stats_entry_tx_bytes_get(
    of_port_stats_entry_t *obj,
    uint64_t *tx_bytes)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 32;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, tx_bytes);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set tx_bytes in an object of type of_port_stats_entry.
 * @param obj Pointer to an object of type of_port_stats_entry.
 * @param tx_bytes The value to write into the object
 */
void
of_port_stats_entry_tx_bytes_set(
    of_port_stats_entry_t *obj,
    uint64_t tx_bytes)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 32;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, tx_bytes);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get rx_dropped from an object of type of_port_stats_entry.
 * @param obj Pointer to an object of type of_port_stats_entry.
 * @param rx_dropped Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_port_stats_entry_rx_dropped_get(
    of_port_stats_entry_t *obj,
    uint64_t *rx_dropped)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 40;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, rx_dropped);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set rx_dropped in an object of type of_port_stats_entry.
 * @param obj Pointer to an object of type of_port_stats_entry.
 * @param rx_dropped The value to write into the object
 */
void
of_port_stats_entry_rx_dropped_set(
    of_port_stats_entry_t *obj,
    uint64_t rx_dropped)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 40;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, rx_dropped);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get tx_dropped from an object of type of_port_stats_entry.
 * @param obj Pointer to an object of type of_port_stats_entry.
 * @param tx_dropped Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_port_stats_entry_tx_dropped_get(
    of_port_stats_entry_t *obj,
    uint64_t *tx_dropped)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 48;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, tx_dropped);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set tx_dropped in an object of type of_port_stats_entry.
 * @param obj Pointer to an object of type of_port_stats_entry.
 * @param tx_dropped The value to write into the object
 */
void
of_port_stats_entry_tx_dropped_set(
    of_port_stats_entry_t *obj,
    uint64_t tx_dropped)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 48;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, tx_dropped);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get rx_errors from an object of type of_port_stats_entry.
 * @param obj Pointer to an object of type of_port_stats_entry.
 * @param rx_errors Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_port_stats_entry_rx_errors_get(
    of_port_stats_entry_t *obj,
    uint64_t *rx_errors)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 56;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, rx_errors);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set rx_errors in an object of type of_port_stats_entry.
 * @param obj Pointer to an object of type of_port_stats_entry.
 * @param rx_errors The value to write into the object
 */
void
of_port_stats_entry_rx_errors_set(
    of_port_stats_entry_t *obj,
    uint64_t rx_errors)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 56;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, rx_errors);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get tx_errors from an object of type of_port_stats_entry.
 * @param obj Pointer to an object of type of_port_stats_entry.
 * @param tx_errors Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_port_stats_entry_tx_errors_get(
    of_port_stats_entry_t *obj,
    uint64_t *tx_errors)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 64;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, tx_errors);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set tx_errors in an object of type of_port_stats_entry.
 * @param obj Pointer to an object of type of_port_stats_entry.
 * @param tx_errors The value to write into the object
 */
void
of_port_stats_entry_tx_errors_set(
    of_port_stats_entry_t *obj,
    uint64_t tx_errors)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 64;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, tx_errors);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get rx_frame_err from an object of type of_port_stats_entry.
 * @param obj Pointer to an object of type of_port_stats_entry.
 * @param rx_frame_err Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_port_stats_entry_rx_frame_err_get(
    of_port_stats_entry_t *obj,
    uint64_t *rx_frame_err)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 72;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, rx_frame_err);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set rx_frame_err in an object of type of_port_stats_entry.
 * @param obj Pointer to an object of type of_port_stats_entry.
 * @param rx_frame_err The value to write into the object
 */
void
of_port_stats_entry_rx_frame_err_set(
    of_port_stats_entry_t *obj,
    uint64_t rx_frame_err)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 72;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, rx_frame_err);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get rx_over_err from an object of type of_port_stats_entry.
 * @param obj Pointer to an object of type of_port_stats_entry.
 * @param rx_over_err Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_port_stats_entry_rx_over_err_get(
    of_port_stats_entry_t *obj,
    uint64_t *rx_over_err)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 80;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, rx_over_err);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set rx_over_err in an object of type of_port_stats_entry.
 * @param obj Pointer to an object of type of_port_stats_entry.
 * @param rx_over_err The value to write into the object
 */
void
of_port_stats_entry_rx_over_err_set(
    of_port_stats_entry_t *obj,
    uint64_t rx_over_err)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 80;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, rx_over_err);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get rx_crc_err from an object of type of_port_stats_entry.
 * @param obj Pointer to an object of type of_port_stats_entry.
 * @param rx_crc_err Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_port_stats_entry_rx_crc_err_get(
    of_port_stats_entry_t *obj,
    uint64_t *rx_crc_err)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 88;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, rx_crc_err);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set rx_crc_err in an object of type of_port_stats_entry.
 * @param obj Pointer to an object of type of_port_stats_entry.
 * @param rx_crc_err The value to write into the object
 */
void
of_port_stats_entry_rx_crc_err_set(
    of_port_stats_entry_t *obj,
    uint64_t rx_crc_err)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 88;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, rx_crc_err);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get collisions from an object of type of_port_stats_entry.
 * @param obj Pointer to an object of type of_port_stats_entry.
 * @param collisions Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_port_stats_entry_collisions_get(
    of_port_stats_entry_t *obj,
    uint64_t *collisions)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 96;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, collisions);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set collisions in an object of type of_port_stats_entry.
 * @param obj Pointer to an object of type of_port_stats_entry.
 * @param collisions The value to write into the object
 */
void
of_port_stats_entry_collisions_set(
    of_port_stats_entry_t *obj,
    uint64_t collisions)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 96;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, collisions);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get duration_sec from an object of type of_port_stats_entry.
 * @param obj Pointer to an object of type of_port_stats_entry.
 * @param duration_sec Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_port_stats_entry_duration_sec_get(
    of_port_stats_entry_t *obj,
    uint32_t *duration_sec)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 104;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, duration_sec);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set duration_sec in an object of type of_port_stats_entry.
 * @param obj Pointer to an object of type of_port_stats_entry.
 * @param duration_sec The value to write into the object
 */
void
of_port_stats_entry_duration_sec_set(
    of_port_stats_entry_t *obj,
    uint32_t duration_sec)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 104;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, duration_sec);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get duration_nsec from an object of type of_port_stats_entry.
 * @param obj Pointer to an object of type of_port_stats_entry.
 * @param duration_nsec Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_port_stats_entry_duration_nsec_get(
    of_port_stats_entry_t *obj,
    uint32_t *duration_nsec)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 108;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, duration_nsec);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set duration_nsec in an object of type of_port_stats_entry.
 * @param obj Pointer to an object of type of_port_stats_entry.
 * @param duration_nsec The value to write into the object
 */
void
of_port_stats_entry_duration_nsec_set(
    of_port_stats_entry_t *obj,
    uint32_t duration_nsec)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_PORT_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 108;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, duration_nsec);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_queue_prop_experimenter */
/** \ingroup of_queue_prop_experimenter 
 * @{ */

/**
 * Get experimenter from an object of type of_queue_prop_experimenter.
 * @param obj Pointer to an object of type of_queue_prop_experimenter.
 * @param experimenter Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_queue_prop_experimenter_experimenter_get(
    of_queue_prop_experimenter_t *obj,
    uint32_t *experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_QUEUE_PROP_EXPERIMENTER);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set experimenter in an object of type of_queue_prop_experimenter.
 * @param obj Pointer to an object of type of_queue_prop_experimenter.
 * @param experimenter The value to write into the object
 */
void
of_queue_prop_experimenter_experimenter_set(
    of_queue_prop_experimenter_t *obj,
    uint32_t experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_QUEUE_PROP_EXPERIMENTER);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get data from an object of type of_queue_prop_experimenter.
 * @param obj Pointer to an object of type of_queue_prop_experimenter.
 * @param data Pointer to the child object of type
 * of_octets_t to be filled out.
 *
 */
void
of_queue_prop_experimenter_data_get(
    of_queue_prop_experimenter_t *obj,
    of_octets_t *data)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_QUEUE_PROP_EXPERIMENTER);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);
    ASSERT(cur_len + abs_offset <= WBUF_CURRENT_BYTES(wbuf));
    data->bytes = cur_len;
    data->data = OF_WIRE_BUFFER_INDEX(wbuf, abs_offset);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set data in an object of type of_queue_prop_experimenter.
 * @param obj Pointer to an object of type of_queue_prop_experimenter.
 * @param data The value to write into the object
 */
int WARN_UNUSED_RESULT
of_queue_prop_experimenter_data_set(
    of_queue_prop_experimenter_t *obj,
    of_octets_t *data)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_QUEUE_PROP_EXPERIMENTER);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);
    new_len = data->bytes;
    of_wire_buffer_grow(wbuf, abs_offset + (new_len - cur_len));
    of_wire_buffer_octets_data_set(wbuf, abs_offset, data, cur_len);

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_queue_prop_header */
/** \ingroup of_queue_prop_header 
 * @{ */

/** @} */

/* Unified accessor functions for of_queue_prop_max_rate */
/** \ingroup of_queue_prop_max_rate 
 * @{ */

/**
 * Get rate from an object of type of_queue_prop_max_rate.
 * @param obj Pointer to an object of type of_queue_prop_max_rate.
 * @param rate Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_queue_prop_max_rate_rate_get(
    of_queue_prop_max_rate_t *obj,
    uint16_t *rate)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_QUEUE_PROP_MAX_RATE);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, rate);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set rate in an object of type of_queue_prop_max_rate.
 * @param obj Pointer to an object of type of_queue_prop_max_rate.
 * @param rate The value to write into the object
 */
void
of_queue_prop_max_rate_rate_set(
    of_queue_prop_max_rate_t *obj,
    uint16_t rate)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_QUEUE_PROP_MAX_RATE);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, rate);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_queue_prop_min_rate */
/** \ingroup of_queue_prop_min_rate 
 * @{ */

/**
 * Get rate from an object of type of_queue_prop_min_rate.
 * @param obj Pointer to an object of type of_queue_prop_min_rate.
 * @param rate Pointer to the child object of type
 * uint16_t to be filled out.
 *
 */
void
of_queue_prop_min_rate_rate_get(
    of_queue_prop_min_rate_t *obj,
    uint16_t *rate)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_QUEUE_PROP_MIN_RATE);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_get(wbuf, abs_offset, rate);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set rate in an object of type of_queue_prop_min_rate.
 * @param obj Pointer to an object of type of_queue_prop_min_rate.
 * @param rate The value to write into the object
 */
void
of_queue_prop_min_rate_rate_set(
    of_queue_prop_min_rate_t *obj,
    uint16_t rate)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_QUEUE_PROP_MIN_RATE);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u16_set(wbuf, abs_offset, rate);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_queue_stats_entry */
/** \ingroup of_queue_stats_entry 
 * @{ */

/**
 * Get port_no from an object of type of_queue_stats_entry.
 * @param obj Pointer to an object of type of_queue_stats_entry.
 * @param port_no Pointer to the child object of type
 * of_port_no_t to be filled out.
 *
 */
void
of_queue_stats_entry_port_no_get(
    of_queue_stats_entry_t *obj,
    of_port_no_t *port_no)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_QUEUE_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 0;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 0;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_get(ver, wbuf, abs_offset, port_no);
    OF_PORT_NO_VALUE_CHECK(*port_no, ver);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set port_no in an object of type of_queue_stats_entry.
 * @param obj Pointer to an object of type of_queue_stats_entry.
 * @param port_no The value to write into the object
 */
void
of_queue_stats_entry_port_no_set(
    of_queue_stats_entry_t *obj,
    of_port_no_t port_no)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_QUEUE_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 0;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 0;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_port_no_set(ver, wbuf, abs_offset, port_no);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get queue_id from an object of type of_queue_stats_entry.
 * @param obj Pointer to an object of type of_queue_stats_entry.
 * @param queue_id Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_queue_stats_entry_queue_id_get(
    of_queue_stats_entry_t *obj,
    uint32_t *queue_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_QUEUE_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, queue_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set queue_id in an object of type of_queue_stats_entry.
 * @param obj Pointer to an object of type of_queue_stats_entry.
 * @param queue_id The value to write into the object
 */
void
of_queue_stats_entry_queue_id_set(
    of_queue_stats_entry_t *obj,
    uint32_t queue_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_QUEUE_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, queue_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get tx_bytes from an object of type of_queue_stats_entry.
 * @param obj Pointer to an object of type of_queue_stats_entry.
 * @param tx_bytes Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_queue_stats_entry_tx_bytes_get(
    of_queue_stats_entry_t *obj,
    uint64_t *tx_bytes)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_QUEUE_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, tx_bytes);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set tx_bytes in an object of type of_queue_stats_entry.
 * @param obj Pointer to an object of type of_queue_stats_entry.
 * @param tx_bytes The value to write into the object
 */
void
of_queue_stats_entry_tx_bytes_set(
    of_queue_stats_entry_t *obj,
    uint64_t tx_bytes)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_QUEUE_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, tx_bytes);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get tx_packets from an object of type of_queue_stats_entry.
 * @param obj Pointer to an object of type of_queue_stats_entry.
 * @param tx_packets Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_queue_stats_entry_tx_packets_get(
    of_queue_stats_entry_t *obj,
    uint64_t *tx_packets)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_QUEUE_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, tx_packets);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set tx_packets in an object of type of_queue_stats_entry.
 * @param obj Pointer to an object of type of_queue_stats_entry.
 * @param tx_packets The value to write into the object
 */
void
of_queue_stats_entry_tx_packets_set(
    of_queue_stats_entry_t *obj,
    uint64_t tx_packets)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_QUEUE_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, tx_packets);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get tx_errors from an object of type of_queue_stats_entry.
 * @param obj Pointer to an object of type of_queue_stats_entry.
 * @param tx_errors Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_queue_stats_entry_tx_errors_get(
    of_queue_stats_entry_t *obj,
    uint64_t *tx_errors)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_QUEUE_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 24;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, tx_errors);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set tx_errors in an object of type of_queue_stats_entry.
 * @param obj Pointer to an object of type of_queue_stats_entry.
 * @param tx_errors The value to write into the object
 */
void
of_queue_stats_entry_tx_errors_set(
    of_queue_stats_entry_t *obj,
    uint64_t tx_errors)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_QUEUE_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 24;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, tx_errors);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get duration_sec from an object of type of_queue_stats_entry.
 * @param obj Pointer to an object of type of_queue_stats_entry.
 * @param duration_sec Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_queue_stats_entry_duration_sec_get(
    of_queue_stats_entry_t *obj,
    uint32_t *duration_sec)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_QUEUE_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 32;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, duration_sec);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set duration_sec in an object of type of_queue_stats_entry.
 * @param obj Pointer to an object of type of_queue_stats_entry.
 * @param duration_sec The value to write into the object
 */
void
of_queue_stats_entry_duration_sec_set(
    of_queue_stats_entry_t *obj,
    uint32_t duration_sec)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_QUEUE_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 32;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, duration_sec);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get duration_nsec from an object of type of_queue_stats_entry.
 * @param obj Pointer to an object of type of_queue_stats_entry.
 * @param duration_nsec Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_queue_stats_entry_duration_nsec_get(
    of_queue_stats_entry_t *obj,
    uint32_t *duration_nsec)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_QUEUE_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 36;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, duration_nsec);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set duration_nsec in an object of type of_queue_stats_entry.
 * @param obj Pointer to an object of type of_queue_stats_entry.
 * @param duration_nsec The value to write into the object
 */
void
of_queue_stats_entry_duration_nsec_set(
    of_queue_stats_entry_t *obj,
    uint32_t duration_nsec)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_QUEUE_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 36;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, duration_nsec);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_table_feature_prop_apply_actions */
/** \ingroup of_table_feature_prop_apply_actions 
 * @{ */

/**
 * Bind an object of type of_list_action_id_t to the parent of type of_table_feature_prop_apply_actions for
 * member action_ids
 * @param obj Pointer to an object of type of_table_feature_prop_apply_actions.
 * @param action_ids Pointer to the child object of type
 * of_list_action_id_t to be filled out.
 * \ingroup of_table_feature_prop_apply_actions
 *
 * The parameter action_ids is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_table_feature_prop_apply_actions_action_ids_bind(
    of_table_feature_prop_apply_actions_t *obj,
    of_list_action_id_t *action_ids)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_TABLE_FEATURE_PROP_APPLY_ACTIONS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_action_id_init(action_ids, obj->version, 0, 1);
    /* Attach to parent */
    action_ids->parent = (of_object_t *)obj;
    action_ids->wire_object.wbuf = obj->wire_object.wbuf;
    action_ids->wire_object.obj_offset = abs_offset;
    action_ids->wire_object.owned = 0;
    action_ids->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of action_ids into a new variable of type of_list_action_id_t from
 * a of_table_feature_prop_apply_actions instance.
 *
 * @param obj Pointer to the source of type of_table_feature_prop_apply_actions_t
 * @returns A pointer to a new instance of type of_list_action_id_t whose contents
 * match that of action_ids from source
 * @returns NULL if an error occurs
 */
of_list_action_id_t *
of_table_feature_prop_apply_actions_action_ids_get(of_table_feature_prop_apply_actions_t *obj) {
    of_list_action_id_t _action_ids;
    of_list_action_id_t *_action_ids_ptr;

    of_table_feature_prop_apply_actions_action_ids_bind(obj, &_action_ids);
    _action_ids_ptr = (of_list_action_id_t *)of_object_dup(&_action_ids);
    return _action_ids_ptr;
}

/**
 * Set action_ids in an object of type of_table_feature_prop_apply_actions.
 * @param obj Pointer to an object of type of_table_feature_prop_apply_actions.
 * @param action_ids Pointer to the child of type of_list_action_id_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_table_feature_prop_apply_actions_action_ids_set(
    of_table_feature_prop_apply_actions_t *obj,
    of_list_action_id_t *action_ids)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_TABLE_FEATURE_PROP_APPLY_ACTIONS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = action_ids->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == action_ids->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(action_ids, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(action_ids, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (action_ids->wire_length_set != NULL) {
        action_ids->wire_length_set((of_object_t *)action_ids, action_ids->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_table_feature_prop_apply_actions_miss */
/** \ingroup of_table_feature_prop_apply_actions_miss 
 * @{ */

/**
 * Bind an object of type of_list_action_id_t to the parent of type of_table_feature_prop_apply_actions_miss for
 * member action_ids
 * @param obj Pointer to an object of type of_table_feature_prop_apply_actions_miss.
 * @param action_ids Pointer to the child object of type
 * of_list_action_id_t to be filled out.
 * \ingroup of_table_feature_prop_apply_actions_miss
 *
 * The parameter action_ids is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_table_feature_prop_apply_actions_miss_action_ids_bind(
    of_table_feature_prop_apply_actions_miss_t *obj,
    of_list_action_id_t *action_ids)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_TABLE_FEATURE_PROP_APPLY_ACTIONS_MISS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_action_id_init(action_ids, obj->version, 0, 1);
    /* Attach to parent */
    action_ids->parent = (of_object_t *)obj;
    action_ids->wire_object.wbuf = obj->wire_object.wbuf;
    action_ids->wire_object.obj_offset = abs_offset;
    action_ids->wire_object.owned = 0;
    action_ids->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of action_ids into a new variable of type of_list_action_id_t from
 * a of_table_feature_prop_apply_actions_miss instance.
 *
 * @param obj Pointer to the source of type of_table_feature_prop_apply_actions_miss_t
 * @returns A pointer to a new instance of type of_list_action_id_t whose contents
 * match that of action_ids from source
 * @returns NULL if an error occurs
 */
of_list_action_id_t *
of_table_feature_prop_apply_actions_miss_action_ids_get(of_table_feature_prop_apply_actions_miss_t *obj) {
    of_list_action_id_t _action_ids;
    of_list_action_id_t *_action_ids_ptr;

    of_table_feature_prop_apply_actions_miss_action_ids_bind(obj, &_action_ids);
    _action_ids_ptr = (of_list_action_id_t *)of_object_dup(&_action_ids);
    return _action_ids_ptr;
}

/**
 * Set action_ids in an object of type of_table_feature_prop_apply_actions_miss.
 * @param obj Pointer to an object of type of_table_feature_prop_apply_actions_miss.
 * @param action_ids Pointer to the child of type of_list_action_id_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_table_feature_prop_apply_actions_miss_action_ids_set(
    of_table_feature_prop_apply_actions_miss_t *obj,
    of_list_action_id_t *action_ids)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_TABLE_FEATURE_PROP_APPLY_ACTIONS_MISS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = action_ids->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == action_ids->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(action_ids, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(action_ids, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (action_ids->wire_length_set != NULL) {
        action_ids->wire_length_set((of_object_t *)action_ids, action_ids->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_table_feature_prop_apply_setfield */
/** \ingroup of_table_feature_prop_apply_setfield 
 * @{ */

/**
 * Bind an object of type of_list_uint32_t to the parent of type of_table_feature_prop_apply_setfield for
 * member oxm_ids
 * @param obj Pointer to an object of type of_table_feature_prop_apply_setfield.
 * @param oxm_ids Pointer to the child object of type
 * of_list_uint32_t to be filled out.
 * \ingroup of_table_feature_prop_apply_setfield
 *
 * The parameter oxm_ids is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_table_feature_prop_apply_setfield_oxm_ids_bind(
    of_table_feature_prop_apply_setfield_t *obj,
    of_list_uint32_t *oxm_ids)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_TABLE_FEATURE_PROP_APPLY_SETFIELD);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_uint32_init(oxm_ids, obj->version, 0, 1);
    /* Attach to parent */
    oxm_ids->parent = (of_object_t *)obj;
    oxm_ids->wire_object.wbuf = obj->wire_object.wbuf;
    oxm_ids->wire_object.obj_offset = abs_offset;
    oxm_ids->wire_object.owned = 0;
    oxm_ids->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of oxm_ids into a new variable of type of_list_uint32_t from
 * a of_table_feature_prop_apply_setfield instance.
 *
 * @param obj Pointer to the source of type of_table_feature_prop_apply_setfield_t
 * @returns A pointer to a new instance of type of_list_uint32_t whose contents
 * match that of oxm_ids from source
 * @returns NULL if an error occurs
 */
of_list_uint32_t *
of_table_feature_prop_apply_setfield_oxm_ids_get(of_table_feature_prop_apply_setfield_t *obj) {
    of_list_uint32_t _oxm_ids;
    of_list_uint32_t *_oxm_ids_ptr;

    of_table_feature_prop_apply_setfield_oxm_ids_bind(obj, &_oxm_ids);
    _oxm_ids_ptr = (of_list_uint32_t *)of_object_dup(&_oxm_ids);
    return _oxm_ids_ptr;
}

/**
 * Set oxm_ids in an object of type of_table_feature_prop_apply_setfield.
 * @param obj Pointer to an object of type of_table_feature_prop_apply_setfield.
 * @param oxm_ids Pointer to the child of type of_list_uint32_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_table_feature_prop_apply_setfield_oxm_ids_set(
    of_table_feature_prop_apply_setfield_t *obj,
    of_list_uint32_t *oxm_ids)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_TABLE_FEATURE_PROP_APPLY_SETFIELD);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = oxm_ids->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == oxm_ids->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(oxm_ids, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(oxm_ids, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (oxm_ids->wire_length_set != NULL) {
        oxm_ids->wire_length_set((of_object_t *)oxm_ids, oxm_ids->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_table_feature_prop_apply_setfield_miss */
/** \ingroup of_table_feature_prop_apply_setfield_miss 
 * @{ */

/**
 * Bind an object of type of_list_uint32_t to the parent of type of_table_feature_prop_apply_setfield_miss for
 * member oxm_ids
 * @param obj Pointer to an object of type of_table_feature_prop_apply_setfield_miss.
 * @param oxm_ids Pointer to the child object of type
 * of_list_uint32_t to be filled out.
 * \ingroup of_table_feature_prop_apply_setfield_miss
 *
 * The parameter oxm_ids is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_table_feature_prop_apply_setfield_miss_oxm_ids_bind(
    of_table_feature_prop_apply_setfield_miss_t *obj,
    of_list_uint32_t *oxm_ids)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_TABLE_FEATURE_PROP_APPLY_SETFIELD_MISS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_uint32_init(oxm_ids, obj->version, 0, 1);
    /* Attach to parent */
    oxm_ids->parent = (of_object_t *)obj;
    oxm_ids->wire_object.wbuf = obj->wire_object.wbuf;
    oxm_ids->wire_object.obj_offset = abs_offset;
    oxm_ids->wire_object.owned = 0;
    oxm_ids->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of oxm_ids into a new variable of type of_list_uint32_t from
 * a of_table_feature_prop_apply_setfield_miss instance.
 *
 * @param obj Pointer to the source of type of_table_feature_prop_apply_setfield_miss_t
 * @returns A pointer to a new instance of type of_list_uint32_t whose contents
 * match that of oxm_ids from source
 * @returns NULL if an error occurs
 */
of_list_uint32_t *
of_table_feature_prop_apply_setfield_miss_oxm_ids_get(of_table_feature_prop_apply_setfield_miss_t *obj) {
    of_list_uint32_t _oxm_ids;
    of_list_uint32_t *_oxm_ids_ptr;

    of_table_feature_prop_apply_setfield_miss_oxm_ids_bind(obj, &_oxm_ids);
    _oxm_ids_ptr = (of_list_uint32_t *)of_object_dup(&_oxm_ids);
    return _oxm_ids_ptr;
}

/**
 * Set oxm_ids in an object of type of_table_feature_prop_apply_setfield_miss.
 * @param obj Pointer to an object of type of_table_feature_prop_apply_setfield_miss.
 * @param oxm_ids Pointer to the child of type of_list_uint32_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_table_feature_prop_apply_setfield_miss_oxm_ids_set(
    of_table_feature_prop_apply_setfield_miss_t *obj,
    of_list_uint32_t *oxm_ids)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_TABLE_FEATURE_PROP_APPLY_SETFIELD_MISS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = oxm_ids->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == oxm_ids->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(oxm_ids, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(oxm_ids, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (oxm_ids->wire_length_set != NULL) {
        oxm_ids->wire_length_set((of_object_t *)oxm_ids, oxm_ids->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_table_feature_prop_experimenter */
/** \ingroup of_table_feature_prop_experimenter 
 * @{ */

/**
 * Get experimenter from an object of type of_table_feature_prop_experimenter.
 * @param obj Pointer to an object of type of_table_feature_prop_experimenter.
 * @param experimenter Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_table_feature_prop_experimenter_experimenter_get(
    of_table_feature_prop_experimenter_t *obj,
    uint32_t *experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_FEATURE_PROP_EXPERIMENTER);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set experimenter in an object of type of_table_feature_prop_experimenter.
 * @param obj Pointer to an object of type of_table_feature_prop_experimenter.
 * @param experimenter The value to write into the object
 */
void
of_table_feature_prop_experimenter_experimenter_set(
    of_table_feature_prop_experimenter_t *obj,
    uint32_t experimenter)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_FEATURE_PROP_EXPERIMENTER);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, experimenter);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get subtype from an object of type of_table_feature_prop_experimenter.
 * @param obj Pointer to an object of type of_table_feature_prop_experimenter.
 * @param subtype Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_table_feature_prop_experimenter_subtype_get(
    of_table_feature_prop_experimenter_t *obj,
    uint32_t *subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_FEATURE_PROP_EXPERIMENTER);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set subtype in an object of type of_table_feature_prop_experimenter.
 * @param obj Pointer to an object of type of_table_feature_prop_experimenter.
 * @param subtype The value to write into the object
 */
void
of_table_feature_prop_experimenter_subtype_set(
    of_table_feature_prop_experimenter_t *obj,
    uint32_t subtype)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_FEATURE_PROP_EXPERIMENTER);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, subtype);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get experimenter_data from an object of type of_table_feature_prop_experimenter.
 * @param obj Pointer to an object of type of_table_feature_prop_experimenter.
 * @param experimenter_data Pointer to the child object of type
 * of_octets_t to be filled out.
 *
 */
void
of_table_feature_prop_experimenter_experimenter_data_get(
    of_table_feature_prop_experimenter_t *obj,
    of_octets_t *experimenter_data)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_TABLE_FEATURE_PROP_EXPERIMENTER);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 12;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);
    ASSERT(cur_len + abs_offset <= WBUF_CURRENT_BYTES(wbuf));
    experimenter_data->bytes = cur_len;
    experimenter_data->data = OF_WIRE_BUFFER_INDEX(wbuf, abs_offset);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set experimenter_data in an object of type of_table_feature_prop_experimenter.
 * @param obj Pointer to an object of type of_table_feature_prop_experimenter.
 * @param experimenter_data The value to write into the object
 */
int WARN_UNUSED_RESULT
of_table_feature_prop_experimenter_experimenter_data_set(
    of_table_feature_prop_experimenter_t *obj,
    of_octets_t *experimenter_data)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_TABLE_FEATURE_PROP_EXPERIMENTER);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 12;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);
    new_len = experimenter_data->bytes;
    of_wire_buffer_grow(wbuf, abs_offset + (new_len - cur_len));
    of_wire_buffer_octets_data_set(wbuf, abs_offset, experimenter_data, cur_len);

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_table_feature_prop_header */
/** \ingroup of_table_feature_prop_header 
 * @{ */

/** @} */

/* Unified accessor functions for of_table_feature_prop_instructions */
/** \ingroup of_table_feature_prop_instructions 
 * @{ */

/**
 * Bind an object of type of_list_instruction_t to the parent of type of_table_feature_prop_instructions for
 * member instruction_ids
 * @param obj Pointer to an object of type of_table_feature_prop_instructions.
 * @param instruction_ids Pointer to the child object of type
 * of_list_instruction_t to be filled out.
 * \ingroup of_table_feature_prop_instructions
 *
 * The parameter instruction_ids is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_table_feature_prop_instructions_instruction_ids_bind(
    of_table_feature_prop_instructions_t *obj,
    of_list_instruction_t *instruction_ids)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_TABLE_FEATURE_PROP_INSTRUCTIONS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_instruction_init(instruction_ids, obj->version, 0, 1);
    /* Attach to parent */
    instruction_ids->parent = (of_object_t *)obj;
    instruction_ids->wire_object.wbuf = obj->wire_object.wbuf;
    instruction_ids->wire_object.obj_offset = abs_offset;
    instruction_ids->wire_object.owned = 0;
    instruction_ids->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of instruction_ids into a new variable of type of_list_instruction_t from
 * a of_table_feature_prop_instructions instance.
 *
 * @param obj Pointer to the source of type of_table_feature_prop_instructions_t
 * @returns A pointer to a new instance of type of_list_instruction_t whose contents
 * match that of instruction_ids from source
 * @returns NULL if an error occurs
 */
of_list_instruction_t *
of_table_feature_prop_instructions_instruction_ids_get(of_table_feature_prop_instructions_t *obj) {
    of_list_instruction_t _instruction_ids;
    of_list_instruction_t *_instruction_ids_ptr;

    of_table_feature_prop_instructions_instruction_ids_bind(obj, &_instruction_ids);
    _instruction_ids_ptr = (of_list_instruction_t *)of_object_dup(&_instruction_ids);
    return _instruction_ids_ptr;
}

/**
 * Set instruction_ids in an object of type of_table_feature_prop_instructions.
 * @param obj Pointer to an object of type of_table_feature_prop_instructions.
 * @param instruction_ids Pointer to the child of type of_list_instruction_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_table_feature_prop_instructions_instruction_ids_set(
    of_table_feature_prop_instructions_t *obj,
    of_list_instruction_t *instruction_ids)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_TABLE_FEATURE_PROP_INSTRUCTIONS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = instruction_ids->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == instruction_ids->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(instruction_ids, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(instruction_ids, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (instruction_ids->wire_length_set != NULL) {
        instruction_ids->wire_length_set((of_object_t *)instruction_ids, instruction_ids->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_table_feature_prop_instructions_miss */
/** \ingroup of_table_feature_prop_instructions_miss 
 * @{ */

/**
 * Bind an object of type of_list_instruction_t to the parent of type of_table_feature_prop_instructions_miss for
 * member instruction_ids
 * @param obj Pointer to an object of type of_table_feature_prop_instructions_miss.
 * @param instruction_ids Pointer to the child object of type
 * of_list_instruction_t to be filled out.
 * \ingroup of_table_feature_prop_instructions_miss
 *
 * The parameter instruction_ids is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_table_feature_prop_instructions_miss_instruction_ids_bind(
    of_table_feature_prop_instructions_miss_t *obj,
    of_list_instruction_t *instruction_ids)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_TABLE_FEATURE_PROP_INSTRUCTIONS_MISS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_instruction_init(instruction_ids, obj->version, 0, 1);
    /* Attach to parent */
    instruction_ids->parent = (of_object_t *)obj;
    instruction_ids->wire_object.wbuf = obj->wire_object.wbuf;
    instruction_ids->wire_object.obj_offset = abs_offset;
    instruction_ids->wire_object.owned = 0;
    instruction_ids->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of instruction_ids into a new variable of type of_list_instruction_t from
 * a of_table_feature_prop_instructions_miss instance.
 *
 * @param obj Pointer to the source of type of_table_feature_prop_instructions_miss_t
 * @returns A pointer to a new instance of type of_list_instruction_t whose contents
 * match that of instruction_ids from source
 * @returns NULL if an error occurs
 */
of_list_instruction_t *
of_table_feature_prop_instructions_miss_instruction_ids_get(of_table_feature_prop_instructions_miss_t *obj) {
    of_list_instruction_t _instruction_ids;
    of_list_instruction_t *_instruction_ids_ptr;

    of_table_feature_prop_instructions_miss_instruction_ids_bind(obj, &_instruction_ids);
    _instruction_ids_ptr = (of_list_instruction_t *)of_object_dup(&_instruction_ids);
    return _instruction_ids_ptr;
}

/**
 * Set instruction_ids in an object of type of_table_feature_prop_instructions_miss.
 * @param obj Pointer to an object of type of_table_feature_prop_instructions_miss.
 * @param instruction_ids Pointer to the child of type of_list_instruction_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_table_feature_prop_instructions_miss_instruction_ids_set(
    of_table_feature_prop_instructions_miss_t *obj,
    of_list_instruction_t *instruction_ids)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_TABLE_FEATURE_PROP_INSTRUCTIONS_MISS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = instruction_ids->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == instruction_ids->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(instruction_ids, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(instruction_ids, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (instruction_ids->wire_length_set != NULL) {
        instruction_ids->wire_length_set((of_object_t *)instruction_ids, instruction_ids->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_table_feature_prop_match */
/** \ingroup of_table_feature_prop_match 
 * @{ */

/**
 * Bind an object of type of_list_uint32_t to the parent of type of_table_feature_prop_match for
 * member oxm_ids
 * @param obj Pointer to an object of type of_table_feature_prop_match.
 * @param oxm_ids Pointer to the child object of type
 * of_list_uint32_t to be filled out.
 * \ingroup of_table_feature_prop_match
 *
 * The parameter oxm_ids is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_table_feature_prop_match_oxm_ids_bind(
    of_table_feature_prop_match_t *obj,
    of_list_uint32_t *oxm_ids)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_TABLE_FEATURE_PROP_MATCH);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_uint32_init(oxm_ids, obj->version, 0, 1);
    /* Attach to parent */
    oxm_ids->parent = (of_object_t *)obj;
    oxm_ids->wire_object.wbuf = obj->wire_object.wbuf;
    oxm_ids->wire_object.obj_offset = abs_offset;
    oxm_ids->wire_object.owned = 0;
    oxm_ids->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of oxm_ids into a new variable of type of_list_uint32_t from
 * a of_table_feature_prop_match instance.
 *
 * @param obj Pointer to the source of type of_table_feature_prop_match_t
 * @returns A pointer to a new instance of type of_list_uint32_t whose contents
 * match that of oxm_ids from source
 * @returns NULL if an error occurs
 */
of_list_uint32_t *
of_table_feature_prop_match_oxm_ids_get(of_table_feature_prop_match_t *obj) {
    of_list_uint32_t _oxm_ids;
    of_list_uint32_t *_oxm_ids_ptr;

    of_table_feature_prop_match_oxm_ids_bind(obj, &_oxm_ids);
    _oxm_ids_ptr = (of_list_uint32_t *)of_object_dup(&_oxm_ids);
    return _oxm_ids_ptr;
}

/**
 * Set oxm_ids in an object of type of_table_feature_prop_match.
 * @param obj Pointer to an object of type of_table_feature_prop_match.
 * @param oxm_ids Pointer to the child of type of_list_uint32_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_table_feature_prop_match_oxm_ids_set(
    of_table_feature_prop_match_t *obj,
    of_list_uint32_t *oxm_ids)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_TABLE_FEATURE_PROP_MATCH);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = oxm_ids->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == oxm_ids->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(oxm_ids, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(oxm_ids, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (oxm_ids->wire_length_set != NULL) {
        oxm_ids->wire_length_set((of_object_t *)oxm_ids, oxm_ids->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_table_feature_prop_next_tables */
/** \ingroup of_table_feature_prop_next_tables 
 * @{ */

/**
 * Bind an object of type of_list_uint8_t to the parent of type of_table_feature_prop_next_tables for
 * member next_table_ids
 * @param obj Pointer to an object of type of_table_feature_prop_next_tables.
 * @param next_table_ids Pointer to the child object of type
 * of_list_uint8_t to be filled out.
 * \ingroup of_table_feature_prop_next_tables
 *
 * The parameter next_table_ids is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_table_feature_prop_next_tables_next_table_ids_bind(
    of_table_feature_prop_next_tables_t *obj,
    of_list_uint8_t *next_table_ids)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_TABLE_FEATURE_PROP_NEXT_TABLES);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_uint8_init(next_table_ids, obj->version, 0, 1);
    /* Attach to parent */
    next_table_ids->parent = (of_object_t *)obj;
    next_table_ids->wire_object.wbuf = obj->wire_object.wbuf;
    next_table_ids->wire_object.obj_offset = abs_offset;
    next_table_ids->wire_object.owned = 0;
    next_table_ids->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of next_table_ids into a new variable of type of_list_uint8_t from
 * a of_table_feature_prop_next_tables instance.
 *
 * @param obj Pointer to the source of type of_table_feature_prop_next_tables_t
 * @returns A pointer to a new instance of type of_list_uint8_t whose contents
 * match that of next_table_ids from source
 * @returns NULL if an error occurs
 */
of_list_uint8_t *
of_table_feature_prop_next_tables_next_table_ids_get(of_table_feature_prop_next_tables_t *obj) {
    of_list_uint8_t _next_table_ids;
    of_list_uint8_t *_next_table_ids_ptr;

    of_table_feature_prop_next_tables_next_table_ids_bind(obj, &_next_table_ids);
    _next_table_ids_ptr = (of_list_uint8_t *)of_object_dup(&_next_table_ids);
    return _next_table_ids_ptr;
}

/**
 * Set next_table_ids in an object of type of_table_feature_prop_next_tables.
 * @param obj Pointer to an object of type of_table_feature_prop_next_tables.
 * @param next_table_ids Pointer to the child of type of_list_uint8_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_table_feature_prop_next_tables_next_table_ids_set(
    of_table_feature_prop_next_tables_t *obj,
    of_list_uint8_t *next_table_ids)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_TABLE_FEATURE_PROP_NEXT_TABLES);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = next_table_ids->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == next_table_ids->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(next_table_ids, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(next_table_ids, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (next_table_ids->wire_length_set != NULL) {
        next_table_ids->wire_length_set((of_object_t *)next_table_ids, next_table_ids->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_table_feature_prop_next_tables_miss */
/** \ingroup of_table_feature_prop_next_tables_miss 
 * @{ */

/**
 * Bind an object of type of_list_uint8_t to the parent of type of_table_feature_prop_next_tables_miss for
 * member next_table_ids
 * @param obj Pointer to an object of type of_table_feature_prop_next_tables_miss.
 * @param next_table_ids Pointer to the child object of type
 * of_list_uint8_t to be filled out.
 * \ingroup of_table_feature_prop_next_tables_miss
 *
 * The parameter next_table_ids is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_table_feature_prop_next_tables_miss_next_table_ids_bind(
    of_table_feature_prop_next_tables_miss_t *obj,
    of_list_uint8_t *next_table_ids)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_TABLE_FEATURE_PROP_NEXT_TABLES_MISS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_uint8_init(next_table_ids, obj->version, 0, 1);
    /* Attach to parent */
    next_table_ids->parent = (of_object_t *)obj;
    next_table_ids->wire_object.wbuf = obj->wire_object.wbuf;
    next_table_ids->wire_object.obj_offset = abs_offset;
    next_table_ids->wire_object.owned = 0;
    next_table_ids->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of next_table_ids into a new variable of type of_list_uint8_t from
 * a of_table_feature_prop_next_tables_miss instance.
 *
 * @param obj Pointer to the source of type of_table_feature_prop_next_tables_miss_t
 * @returns A pointer to a new instance of type of_list_uint8_t whose contents
 * match that of next_table_ids from source
 * @returns NULL if an error occurs
 */
of_list_uint8_t *
of_table_feature_prop_next_tables_miss_next_table_ids_get(of_table_feature_prop_next_tables_miss_t *obj) {
    of_list_uint8_t _next_table_ids;
    of_list_uint8_t *_next_table_ids_ptr;

    of_table_feature_prop_next_tables_miss_next_table_ids_bind(obj, &_next_table_ids);
    _next_table_ids_ptr = (of_list_uint8_t *)of_object_dup(&_next_table_ids);
    return _next_table_ids_ptr;
}

/**
 * Set next_table_ids in an object of type of_table_feature_prop_next_tables_miss.
 * @param obj Pointer to an object of type of_table_feature_prop_next_tables_miss.
 * @param next_table_ids Pointer to the child of type of_list_uint8_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_table_feature_prop_next_tables_miss_next_table_ids_set(
    of_table_feature_prop_next_tables_miss_t *obj,
    of_list_uint8_t *next_table_ids)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_TABLE_FEATURE_PROP_NEXT_TABLES_MISS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = next_table_ids->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == next_table_ids->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(next_table_ids, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(next_table_ids, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (next_table_ids->wire_length_set != NULL) {
        next_table_ids->wire_length_set((of_object_t *)next_table_ids, next_table_ids->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_table_feature_prop_wildcards */
/** \ingroup of_table_feature_prop_wildcards 
 * @{ */

/**
 * Bind an object of type of_list_uint32_t to the parent of type of_table_feature_prop_wildcards for
 * member oxm_ids
 * @param obj Pointer to an object of type of_table_feature_prop_wildcards.
 * @param oxm_ids Pointer to the child object of type
 * of_list_uint32_t to be filled out.
 * \ingroup of_table_feature_prop_wildcards
 *
 * The parameter oxm_ids is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_table_feature_prop_wildcards_oxm_ids_bind(
    of_table_feature_prop_wildcards_t *obj,
    of_list_uint32_t *oxm_ids)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_TABLE_FEATURE_PROP_WILDCARDS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_uint32_init(oxm_ids, obj->version, 0, 1);
    /* Attach to parent */
    oxm_ids->parent = (of_object_t *)obj;
    oxm_ids->wire_object.wbuf = obj->wire_object.wbuf;
    oxm_ids->wire_object.obj_offset = abs_offset;
    oxm_ids->wire_object.owned = 0;
    oxm_ids->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of oxm_ids into a new variable of type of_list_uint32_t from
 * a of_table_feature_prop_wildcards instance.
 *
 * @param obj Pointer to the source of type of_table_feature_prop_wildcards_t
 * @returns A pointer to a new instance of type of_list_uint32_t whose contents
 * match that of oxm_ids from source
 * @returns NULL if an error occurs
 */
of_list_uint32_t *
of_table_feature_prop_wildcards_oxm_ids_get(of_table_feature_prop_wildcards_t *obj) {
    of_list_uint32_t _oxm_ids;
    of_list_uint32_t *_oxm_ids_ptr;

    of_table_feature_prop_wildcards_oxm_ids_bind(obj, &_oxm_ids);
    _oxm_ids_ptr = (of_list_uint32_t *)of_object_dup(&_oxm_ids);
    return _oxm_ids_ptr;
}

/**
 * Set oxm_ids in an object of type of_table_feature_prop_wildcards.
 * @param obj Pointer to an object of type of_table_feature_prop_wildcards.
 * @param oxm_ids Pointer to the child of type of_list_uint32_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_table_feature_prop_wildcards_oxm_ids_set(
    of_table_feature_prop_wildcards_t *obj,
    of_list_uint32_t *oxm_ids)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_TABLE_FEATURE_PROP_WILDCARDS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = oxm_ids->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == oxm_ids->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(oxm_ids, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(oxm_ids, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (oxm_ids->wire_length_set != NULL) {
        oxm_ids->wire_length_set((of_object_t *)oxm_ids, oxm_ids->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_table_feature_prop_write_actions */
/** \ingroup of_table_feature_prop_write_actions 
 * @{ */

/**
 * Bind an object of type of_list_action_id_t to the parent of type of_table_feature_prop_write_actions for
 * member action_ids
 * @param obj Pointer to an object of type of_table_feature_prop_write_actions.
 * @param action_ids Pointer to the child object of type
 * of_list_action_id_t to be filled out.
 * \ingroup of_table_feature_prop_write_actions
 *
 * The parameter action_ids is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_table_feature_prop_write_actions_action_ids_bind(
    of_table_feature_prop_write_actions_t *obj,
    of_list_action_id_t *action_ids)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_TABLE_FEATURE_PROP_WRITE_ACTIONS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_action_id_init(action_ids, obj->version, 0, 1);
    /* Attach to parent */
    action_ids->parent = (of_object_t *)obj;
    action_ids->wire_object.wbuf = obj->wire_object.wbuf;
    action_ids->wire_object.obj_offset = abs_offset;
    action_ids->wire_object.owned = 0;
    action_ids->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of action_ids into a new variable of type of_list_action_id_t from
 * a of_table_feature_prop_write_actions instance.
 *
 * @param obj Pointer to the source of type of_table_feature_prop_write_actions_t
 * @returns A pointer to a new instance of type of_list_action_id_t whose contents
 * match that of action_ids from source
 * @returns NULL if an error occurs
 */
of_list_action_id_t *
of_table_feature_prop_write_actions_action_ids_get(of_table_feature_prop_write_actions_t *obj) {
    of_list_action_id_t _action_ids;
    of_list_action_id_t *_action_ids_ptr;

    of_table_feature_prop_write_actions_action_ids_bind(obj, &_action_ids);
    _action_ids_ptr = (of_list_action_id_t *)of_object_dup(&_action_ids);
    return _action_ids_ptr;
}

/**
 * Set action_ids in an object of type of_table_feature_prop_write_actions.
 * @param obj Pointer to an object of type of_table_feature_prop_write_actions.
 * @param action_ids Pointer to the child of type of_list_action_id_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_table_feature_prop_write_actions_action_ids_set(
    of_table_feature_prop_write_actions_t *obj,
    of_list_action_id_t *action_ids)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_TABLE_FEATURE_PROP_WRITE_ACTIONS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = action_ids->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == action_ids->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(action_ids, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(action_ids, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (action_ids->wire_length_set != NULL) {
        action_ids->wire_length_set((of_object_t *)action_ids, action_ids->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_table_feature_prop_write_actions_miss */
/** \ingroup of_table_feature_prop_write_actions_miss 
 * @{ */

/**
 * Bind an object of type of_list_action_id_t to the parent of type of_table_feature_prop_write_actions_miss for
 * member action_ids
 * @param obj Pointer to an object of type of_table_feature_prop_write_actions_miss.
 * @param action_ids Pointer to the child object of type
 * of_list_action_id_t to be filled out.
 * \ingroup of_table_feature_prop_write_actions_miss
 *
 * The parameter action_ids is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_table_feature_prop_write_actions_miss_action_ids_bind(
    of_table_feature_prop_write_actions_miss_t *obj,
    of_list_action_id_t *action_ids)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_TABLE_FEATURE_PROP_WRITE_ACTIONS_MISS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_action_id_init(action_ids, obj->version, 0, 1);
    /* Attach to parent */
    action_ids->parent = (of_object_t *)obj;
    action_ids->wire_object.wbuf = obj->wire_object.wbuf;
    action_ids->wire_object.obj_offset = abs_offset;
    action_ids->wire_object.owned = 0;
    action_ids->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of action_ids into a new variable of type of_list_action_id_t from
 * a of_table_feature_prop_write_actions_miss instance.
 *
 * @param obj Pointer to the source of type of_table_feature_prop_write_actions_miss_t
 * @returns A pointer to a new instance of type of_list_action_id_t whose contents
 * match that of action_ids from source
 * @returns NULL if an error occurs
 */
of_list_action_id_t *
of_table_feature_prop_write_actions_miss_action_ids_get(of_table_feature_prop_write_actions_miss_t *obj) {
    of_list_action_id_t _action_ids;
    of_list_action_id_t *_action_ids_ptr;

    of_table_feature_prop_write_actions_miss_action_ids_bind(obj, &_action_ids);
    _action_ids_ptr = (of_list_action_id_t *)of_object_dup(&_action_ids);
    return _action_ids_ptr;
}

/**
 * Set action_ids in an object of type of_table_feature_prop_write_actions_miss.
 * @param obj Pointer to an object of type of_table_feature_prop_write_actions_miss.
 * @param action_ids Pointer to the child of type of_list_action_id_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_table_feature_prop_write_actions_miss_action_ids_set(
    of_table_feature_prop_write_actions_miss_t *obj,
    of_list_action_id_t *action_ids)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_TABLE_FEATURE_PROP_WRITE_ACTIONS_MISS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = action_ids->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == action_ids->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(action_ids, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(action_ids, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (action_ids->wire_length_set != NULL) {
        action_ids->wire_length_set((of_object_t *)action_ids, action_ids->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_table_feature_prop_write_setfield */
/** \ingroup of_table_feature_prop_write_setfield 
 * @{ */

/**
 * Bind an object of type of_list_uint32_t to the parent of type of_table_feature_prop_write_setfield for
 * member oxm_ids
 * @param obj Pointer to an object of type of_table_feature_prop_write_setfield.
 * @param oxm_ids Pointer to the child object of type
 * of_list_uint32_t to be filled out.
 * \ingroup of_table_feature_prop_write_setfield
 *
 * The parameter oxm_ids is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_table_feature_prop_write_setfield_oxm_ids_bind(
    of_table_feature_prop_write_setfield_t *obj,
    of_list_uint32_t *oxm_ids)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_TABLE_FEATURE_PROP_WRITE_SETFIELD);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_uint32_init(oxm_ids, obj->version, 0, 1);
    /* Attach to parent */
    oxm_ids->parent = (of_object_t *)obj;
    oxm_ids->wire_object.wbuf = obj->wire_object.wbuf;
    oxm_ids->wire_object.obj_offset = abs_offset;
    oxm_ids->wire_object.owned = 0;
    oxm_ids->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of oxm_ids into a new variable of type of_list_uint32_t from
 * a of_table_feature_prop_write_setfield instance.
 *
 * @param obj Pointer to the source of type of_table_feature_prop_write_setfield_t
 * @returns A pointer to a new instance of type of_list_uint32_t whose contents
 * match that of oxm_ids from source
 * @returns NULL if an error occurs
 */
of_list_uint32_t *
of_table_feature_prop_write_setfield_oxm_ids_get(of_table_feature_prop_write_setfield_t *obj) {
    of_list_uint32_t _oxm_ids;
    of_list_uint32_t *_oxm_ids_ptr;

    of_table_feature_prop_write_setfield_oxm_ids_bind(obj, &_oxm_ids);
    _oxm_ids_ptr = (of_list_uint32_t *)of_object_dup(&_oxm_ids);
    return _oxm_ids_ptr;
}

/**
 * Set oxm_ids in an object of type of_table_feature_prop_write_setfield.
 * @param obj Pointer to an object of type of_table_feature_prop_write_setfield.
 * @param oxm_ids Pointer to the child of type of_list_uint32_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_table_feature_prop_write_setfield_oxm_ids_set(
    of_table_feature_prop_write_setfield_t *obj,
    of_list_uint32_t *oxm_ids)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_TABLE_FEATURE_PROP_WRITE_SETFIELD);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = oxm_ids->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == oxm_ids->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(oxm_ids, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(oxm_ids, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (oxm_ids->wire_length_set != NULL) {
        oxm_ids->wire_length_set((of_object_t *)oxm_ids, oxm_ids->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_table_feature_prop_write_setfield_miss */
/** \ingroup of_table_feature_prop_write_setfield_miss 
 * @{ */

/**
 * Bind an object of type of_list_uint32_t to the parent of type of_table_feature_prop_write_setfield_miss for
 * member oxm_ids
 * @param obj Pointer to an object of type of_table_feature_prop_write_setfield_miss.
 * @param oxm_ids Pointer to the child object of type
 * of_list_uint32_t to be filled out.
 * \ingroup of_table_feature_prop_write_setfield_miss
 *
 * The parameter oxm_ids is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_table_feature_prop_write_setfield_miss_oxm_ids_bind(
    of_table_feature_prop_write_setfield_miss_t *obj,
    of_list_uint32_t *oxm_ids)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_TABLE_FEATURE_PROP_WRITE_SETFIELD_MISS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_uint32_init(oxm_ids, obj->version, 0, 1);
    /* Attach to parent */
    oxm_ids->parent = (of_object_t *)obj;
    oxm_ids->wire_object.wbuf = obj->wire_object.wbuf;
    oxm_ids->wire_object.obj_offset = abs_offset;
    oxm_ids->wire_object.owned = 0;
    oxm_ids->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of oxm_ids into a new variable of type of_list_uint32_t from
 * a of_table_feature_prop_write_setfield_miss instance.
 *
 * @param obj Pointer to the source of type of_table_feature_prop_write_setfield_miss_t
 * @returns A pointer to a new instance of type of_list_uint32_t whose contents
 * match that of oxm_ids from source
 * @returns NULL if an error occurs
 */
of_list_uint32_t *
of_table_feature_prop_write_setfield_miss_oxm_ids_get(of_table_feature_prop_write_setfield_miss_t *obj) {
    of_list_uint32_t _oxm_ids;
    of_list_uint32_t *_oxm_ids_ptr;

    of_table_feature_prop_write_setfield_miss_oxm_ids_bind(obj, &_oxm_ids);
    _oxm_ids_ptr = (of_list_uint32_t *)of_object_dup(&_oxm_ids);
    return _oxm_ids_ptr;
}

/**
 * Set oxm_ids in an object of type of_table_feature_prop_write_setfield_miss.
 * @param obj Pointer to an object of type of_table_feature_prop_write_setfield_miss.
 * @param oxm_ids Pointer to the child of type of_list_uint32_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_table_feature_prop_write_setfield_miss_oxm_ids_set(
    of_table_feature_prop_write_setfield_miss_t *obj,
    of_list_uint32_t *oxm_ids)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_TABLE_FEATURE_PROP_WRITE_SETFIELD_MISS);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 4;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = oxm_ids->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == oxm_ids->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(oxm_ids, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(oxm_ids, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (oxm_ids->wire_length_set != NULL) {
        oxm_ids->wire_length_set((of_object_t *)oxm_ids, oxm_ids->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_table_features */
/** \ingroup of_table_features 
 * @{ */

/**
 * Get table_id from an object of type of_table_features.
 * @param obj Pointer to an object of type of_table_features.
 * @param table_id Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_table_features_table_id_get(
    of_table_features_t *obj,
    uint8_t *table_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_FEATURES);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 2;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, table_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set table_id in an object of type of_table_features.
 * @param obj Pointer to an object of type of_table_features.
 * @param table_id The value to write into the object
 */
void
of_table_features_table_id_set(
    of_table_features_t *obj,
    uint8_t table_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_FEATURES);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 2;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, table_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get name from an object of type of_table_features.
 * @param obj Pointer to an object of type of_table_features.
 * @param name Pointer to the child object of type
 * of_table_name_t to be filled out.
 *
 */
void
of_table_features_name_get(
    of_table_features_t *obj,
    of_table_name_t *name)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_FEATURES);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_tab_name_get(wbuf, abs_offset, name);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set name in an object of type of_table_features.
 * @param obj Pointer to an object of type of_table_features.
 * @param name The value to write into the object
 */
void
of_table_features_name_set(
    of_table_features_t *obj,
    of_table_name_t name)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_FEATURES);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_tab_name_set(wbuf, abs_offset, name);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get metadata_match from an object of type of_table_features.
 * @param obj Pointer to an object of type of_table_features.
 * @param metadata_match Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_table_features_metadata_match_get(
    of_table_features_t *obj,
    uint64_t *metadata_match)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_FEATURES);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 40;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, metadata_match);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set metadata_match in an object of type of_table_features.
 * @param obj Pointer to an object of type of_table_features.
 * @param metadata_match The value to write into the object
 */
void
of_table_features_metadata_match_set(
    of_table_features_t *obj,
    uint64_t metadata_match)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_FEATURES);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 40;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, metadata_match);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get metadata_write from an object of type of_table_features.
 * @param obj Pointer to an object of type of_table_features.
 * @param metadata_write Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_table_features_metadata_write_get(
    of_table_features_t *obj,
    uint64_t *metadata_write)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_FEATURES);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 48;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, metadata_write);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set metadata_write in an object of type of_table_features.
 * @param obj Pointer to an object of type of_table_features.
 * @param metadata_write The value to write into the object
 */
void
of_table_features_metadata_write_set(
    of_table_features_t *obj,
    uint64_t metadata_write)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_FEATURES);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 48;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, metadata_write);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get config from an object of type of_table_features.
 * @param obj Pointer to an object of type of_table_features.
 * @param config Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_table_features_config_get(
    of_table_features_t *obj,
    uint32_t *config)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_FEATURES);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 56;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, config);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set config in an object of type of_table_features.
 * @param obj Pointer to an object of type of_table_features.
 * @param config The value to write into the object
 */
void
of_table_features_config_set(
    of_table_features_t *obj,
    uint32_t config)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_FEATURES);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 56;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, config);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get max_entries from an object of type of_table_features.
 * @param obj Pointer to an object of type of_table_features.
 * @param max_entries Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_table_features_max_entries_get(
    of_table_features_t *obj,
    uint32_t *max_entries)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_FEATURES);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 60;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, max_entries);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set max_entries in an object of type of_table_features.
 * @param obj Pointer to an object of type of_table_features.
 * @param max_entries The value to write into the object
 */
void
of_table_features_max_entries_set(
    of_table_features_t *obj,
    uint32_t max_entries)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_FEATURES);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 60;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, max_entries);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Bind an object of type of_list_table_feature_prop_t to the parent of type of_table_features for
 * member properties
 * @param obj Pointer to an object of type of_table_features.
 * @param properties Pointer to the child object of type
 * of_list_table_feature_prop_t to be filled out.
 * \ingroup of_table_features
 *
 * The parameter properties is filled out to point to the same underlying
 * wire buffer as its parent.
 *
 */
void
of_table_features_properties_bind(
    of_table_features_t *obj,
    of_list_table_feature_prop_t *properties)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */

    ASSERT(obj->object_id == OF_TABLE_FEATURES);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 64;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* Initialize child */
    of_list_table_feature_prop_init(properties, obj->version, 0, 1);
    /* Attach to parent */
    properties->parent = (of_object_t *)obj;
    properties->wire_object.wbuf = obj->wire_object.wbuf;
    properties->wire_object.obj_offset = abs_offset;
    properties->wire_object.owned = 0;
    properties->length = cur_len;

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Create a copy of properties into a new variable of type of_list_table_feature_prop_t from
 * a of_table_features instance.
 *
 * @param obj Pointer to the source of type of_table_features_t
 * @returns A pointer to a new instance of type of_list_table_feature_prop_t whose contents
 * match that of properties from source
 * @returns NULL if an error occurs
 */
of_list_table_feature_prop_t *
of_table_features_properties_get(of_table_features_t *obj) {
    of_list_table_feature_prop_t _properties;
    of_list_table_feature_prop_t *_properties_ptr;

    of_table_features_properties_bind(obj, &_properties);
    _properties_ptr = (of_list_table_feature_prop_t *)of_object_dup(&_properties);
    return _properties_ptr;
}

/**
 * Set properties in an object of type of_table_features.
 * @param obj Pointer to an object of type of_table_features.
 * @param properties Pointer to the child of type of_list_table_feature_prop_t.
 *
 * If the child's wire buffer is the same as the parent's, then
 * nothing is done as the changes have already been registered in the
 * parent.  Otherwise, the data in the child's wire buffer is inserted
 * into the parent's and the appropriate lengths are updated.
 */
int WARN_UNUSED_RESULT
of_table_features_properties_set(
    of_table_features_t *obj,
    of_list_table_feature_prop_t *properties)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;
    int cur_len = 0; /* Current length of object data */
    int new_len, delta; /* For set, need new length and delta */

    ASSERT(obj->object_id == OF_TABLE_FEATURES);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 64;
        cur_len = _END_LEN(obj, offset);
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    ASSERT(cur_len >= 0 && cur_len < 64 * 1024);

    /* LOCI object type */
    new_len = properties->length;
    /* If underlying buffer already shared; nothing to do */
    if (obj->wire_object.wbuf == properties->wire_object.wbuf) {
        of_wire_buffer_grow(wbuf, abs_offset + new_len);
        /* Verify that the offsets are correct */
        ASSERT(abs_offset == OF_OBJECT_ABSOLUTE_OFFSET(properties, 0));
        /* ASSERT(new_len == cur_len); */ /* fixme: may fail for OXM lists */
        return OF_ERROR_NONE;
    }

    /* Otherwise, replace existing object in data buffer */
    of_wire_buffer_replace_data(wbuf, abs_offset, cur_len,
        OF_OBJECT_BUFFER_INDEX(properties, 0), new_len);

    /* @fixme Shouldn't this precede copying value's data to buffer? */
    if (properties->wire_length_set != NULL) {
        properties->wire_length_set((of_object_t *)properties, properties->length);
    }

    /* Not scalar, update lengths if needed */
    delta = new_len - cur_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    OF_LENGTH_CHECK_ASSERT(obj);

    return OF_ERROR_NONE;
}

/** @} */

/* Unified accessor functions for of_table_stats_entry */
/** \ingroup of_table_stats_entry 
 * @{ */

/**
 * Get table_id from an object of type of_table_stats_entry.
 * @param obj Pointer to an object of type of_table_stats_entry.
 * @param table_id Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_table_stats_entry_table_id_get(
    of_table_stats_entry_t *obj,
    uint8_t *table_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 0;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, table_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set table_id in an object of type of_table_stats_entry.
 * @param obj Pointer to an object of type of_table_stats_entry.
 * @param table_id The value to write into the object
 */
void
of_table_stats_entry_table_id_set(
    of_table_stats_entry_t *obj,
    uint8_t table_id)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        offset = 0;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, table_id);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get active_count from an object of type of_table_stats_entry.
 * @param obj Pointer to an object of type of_table_stats_entry.
 * @param active_count Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_table_stats_entry_active_count_get(
    of_table_stats_entry_t *obj,
    uint32_t *active_count)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 44;
        break;
    case OF_VERSION_1_1:
        offset = 68;
        break;
    case OF_VERSION_1_2:
        offset = 108;
        break;
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, active_count);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set active_count in an object of type of_table_stats_entry.
 * @param obj Pointer to an object of type of_table_stats_entry.
 * @param active_count The value to write into the object
 */
void
of_table_stats_entry_active_count_set(
    of_table_stats_entry_t *obj,
    uint32_t active_count)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 44;
        break;
    case OF_VERSION_1_1:
        offset = 68;
        break;
    case OF_VERSION_1_2:
        offset = 108;
        break;
    case OF_VERSION_1_3:
        offset = 4;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, active_count);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get lookup_count from an object of type of_table_stats_entry.
 * @param obj Pointer to an object of type of_table_stats_entry.
 * @param lookup_count Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_table_stats_entry_lookup_count_get(
    of_table_stats_entry_t *obj,
    uint64_t *lookup_count)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 48;
        break;
    case OF_VERSION_1_1:
        offset = 72;
        break;
    case OF_VERSION_1_2:
        offset = 112;
        break;
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, lookup_count);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set lookup_count in an object of type of_table_stats_entry.
 * @param obj Pointer to an object of type of_table_stats_entry.
 * @param lookup_count The value to write into the object
 */
void
of_table_stats_entry_lookup_count_set(
    of_table_stats_entry_t *obj,
    uint64_t lookup_count)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 48;
        break;
    case OF_VERSION_1_1:
        offset = 72;
        break;
    case OF_VERSION_1_2:
        offset = 112;
        break;
    case OF_VERSION_1_3:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, lookup_count);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get matched_count from an object of type of_table_stats_entry.
 * @param obj Pointer to an object of type of_table_stats_entry.
 * @param matched_count Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_table_stats_entry_matched_count_get(
    of_table_stats_entry_t *obj,
    uint64_t *matched_count)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 56;
        break;
    case OF_VERSION_1_1:
        offset = 80;
        break;
    case OF_VERSION_1_2:
        offset = 120;
        break;
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, matched_count);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set matched_count in an object of type of_table_stats_entry.
 * @param obj Pointer to an object of type of_table_stats_entry.
 * @param matched_count The value to write into the object
 */
void
of_table_stats_entry_matched_count_set(
    of_table_stats_entry_t *obj,
    uint64_t matched_count)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 56;
        break;
    case OF_VERSION_1_1:
        offset = 80;
        break;
    case OF_VERSION_1_2:
        offset = 120;
        break;
    case OF_VERSION_1_3:
        offset = 16;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, matched_count);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get name from an object of type of_table_stats_entry.
 * @param obj Pointer to an object of type of_table_stats_entry.
 * @param name Pointer to the child object of type
 * of_table_name_t to be filled out.
 *
 */
void
of_table_stats_entry_name_get(
    of_table_stats_entry_t *obj,
    of_table_name_t *name)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 4;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_tab_name_get(wbuf, abs_offset, name);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set name in an object of type of_table_stats_entry.
 * @param obj Pointer to an object of type of_table_stats_entry.
 * @param name The value to write into the object
 */
void
of_table_stats_entry_name_set(
    of_table_stats_entry_t *obj,
    of_table_name_t name)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 4;
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
        offset = 8;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_tab_name_set(wbuf, abs_offset, name);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get match from an object of type of_table_stats_entry.
 * @param obj Pointer to an object of type of_table_stats_entry.
 * @param match Pointer to the child object of type
 * of_match_bmap_t to be filled out.
 *
 */
void
of_table_stats_entry_match_get(
    of_table_stats_entry_t *obj,
    of_match_bmap_t *match)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 44;
        break;
    case OF_VERSION_1_2:
        offset = 40;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_match_bmap_get(ver, wbuf, abs_offset, match);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set match in an object of type of_table_stats_entry.
 * @param obj Pointer to an object of type of_table_stats_entry.
 * @param match The value to write into the object
 */
void
of_table_stats_entry_match_set(
    of_table_stats_entry_t *obj,
    of_match_bmap_t match)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 44;
        break;
    case OF_VERSION_1_2:
        offset = 40;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_match_bmap_set(ver, wbuf, abs_offset, match);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get wildcards from an object of type of_table_stats_entry.
 * @param obj Pointer to an object of type of_table_stats_entry.
 * @param wildcards Pointer to the child object of type
 * of_wc_bmap_t to be filled out.
 *
 */
void
of_table_stats_entry_wildcards_get(
    of_table_stats_entry_t *obj,
    of_wc_bmap_t *wildcards)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 36;
        break;
    case OF_VERSION_1_1:
        offset = 40;
        break;
    case OF_VERSION_1_2:
        offset = 48;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_wc_bmap_get(ver, wbuf, abs_offset, wildcards);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set wildcards in an object of type of_table_stats_entry.
 * @param obj Pointer to an object of type of_table_stats_entry.
 * @param wildcards The value to write into the object
 */
void
of_table_stats_entry_wildcards_set(
    of_table_stats_entry_t *obj,
    of_wc_bmap_t wildcards)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 36;
        break;
    case OF_VERSION_1_1:
        offset = 40;
        break;
    case OF_VERSION_1_2:
        offset = 48;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_wc_bmap_set(ver, wbuf, abs_offset, wildcards);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get write_actions from an object of type of_table_stats_entry.
 * @param obj Pointer to an object of type of_table_stats_entry.
 * @param write_actions Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_table_stats_entry_write_actions_get(
    of_table_stats_entry_t *obj,
    uint32_t *write_actions)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 52;
        break;
    case OF_VERSION_1_2:
        offset = 56;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, write_actions);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set write_actions in an object of type of_table_stats_entry.
 * @param obj Pointer to an object of type of_table_stats_entry.
 * @param write_actions The value to write into the object
 */
void
of_table_stats_entry_write_actions_set(
    of_table_stats_entry_t *obj,
    uint32_t write_actions)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 52;
        break;
    case OF_VERSION_1_2:
        offset = 56;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, write_actions);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get apply_actions from an object of type of_table_stats_entry.
 * @param obj Pointer to an object of type of_table_stats_entry.
 * @param apply_actions Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_table_stats_entry_apply_actions_get(
    of_table_stats_entry_t *obj,
    uint32_t *apply_actions)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 56;
        break;
    case OF_VERSION_1_2:
        offset = 60;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, apply_actions);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set apply_actions in an object of type of_table_stats_entry.
 * @param obj Pointer to an object of type of_table_stats_entry.
 * @param apply_actions The value to write into the object
 */
void
of_table_stats_entry_apply_actions_set(
    of_table_stats_entry_t *obj,
    uint32_t apply_actions)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 56;
        break;
    case OF_VERSION_1_2:
        offset = 60;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, apply_actions);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get write_setfields from an object of type of_table_stats_entry.
 * @param obj Pointer to an object of type of_table_stats_entry.
 * @param write_setfields Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_table_stats_entry_write_setfields_get(
    of_table_stats_entry_t *obj,
    uint64_t *write_setfields)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
        offset = 64;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, write_setfields);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set write_setfields in an object of type of_table_stats_entry.
 * @param obj Pointer to an object of type of_table_stats_entry.
 * @param write_setfields The value to write into the object
 */
void
of_table_stats_entry_write_setfields_set(
    of_table_stats_entry_t *obj,
    uint64_t write_setfields)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
        offset = 64;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, write_setfields);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get apply_setfields from an object of type of_table_stats_entry.
 * @param obj Pointer to an object of type of_table_stats_entry.
 * @param apply_setfields Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_table_stats_entry_apply_setfields_get(
    of_table_stats_entry_t *obj,
    uint64_t *apply_setfields)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
        offset = 72;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, apply_setfields);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set apply_setfields in an object of type of_table_stats_entry.
 * @param obj Pointer to an object of type of_table_stats_entry.
 * @param apply_setfields The value to write into the object
 */
void
of_table_stats_entry_apply_setfields_set(
    of_table_stats_entry_t *obj,
    uint64_t apply_setfields)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
        offset = 72;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, apply_setfields);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get metadata_match from an object of type of_table_stats_entry.
 * @param obj Pointer to an object of type of_table_stats_entry.
 * @param metadata_match Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_table_stats_entry_metadata_match_get(
    of_table_stats_entry_t *obj,
    uint64_t *metadata_match)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
        offset = 80;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, metadata_match);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set metadata_match in an object of type of_table_stats_entry.
 * @param obj Pointer to an object of type of_table_stats_entry.
 * @param metadata_match The value to write into the object
 */
void
of_table_stats_entry_metadata_match_set(
    of_table_stats_entry_t *obj,
    uint64_t metadata_match)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
        offset = 80;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, metadata_match);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get metadata_write from an object of type of_table_stats_entry.
 * @param obj Pointer to an object of type of_table_stats_entry.
 * @param metadata_write Pointer to the child object of type
 * uint64_t to be filled out.
 *
 */
void
of_table_stats_entry_metadata_write_get(
    of_table_stats_entry_t *obj,
    uint64_t *metadata_write)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
        offset = 88;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_get(wbuf, abs_offset, metadata_write);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set metadata_write in an object of type of_table_stats_entry.
 * @param obj Pointer to an object of type of_table_stats_entry.
 * @param metadata_write The value to write into the object
 */
void
of_table_stats_entry_metadata_write_set(
    of_table_stats_entry_t *obj,
    uint64_t metadata_write)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_2:
        offset = 88;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u64_set(wbuf, abs_offset, metadata_write);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get instructions from an object of type of_table_stats_entry.
 * @param obj Pointer to an object of type of_table_stats_entry.
 * @param instructions Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_table_stats_entry_instructions_get(
    of_table_stats_entry_t *obj,
    uint32_t *instructions)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 48;
        break;
    case OF_VERSION_1_2:
        offset = 96;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, instructions);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set instructions in an object of type of_table_stats_entry.
 * @param obj Pointer to an object of type of_table_stats_entry.
 * @param instructions The value to write into the object
 */
void
of_table_stats_entry_instructions_set(
    of_table_stats_entry_t *obj,
    uint32_t instructions)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 48;
        break;
    case OF_VERSION_1_2:
        offset = 96;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, instructions);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get config from an object of type of_table_stats_entry.
 * @param obj Pointer to an object of type of_table_stats_entry.
 * @param config Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_table_stats_entry_config_get(
    of_table_stats_entry_t *obj,
    uint32_t *config)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 60;
        break;
    case OF_VERSION_1_2:
        offset = 100;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, config);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set config in an object of type of_table_stats_entry.
 * @param obj Pointer to an object of type of_table_stats_entry.
 * @param config The value to write into the object
 */
void
of_table_stats_entry_config_set(
    of_table_stats_entry_t *obj,
    uint32_t config)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_1:
        offset = 60;
        break;
    case OF_VERSION_1_2:
        offset = 100;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, config);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Get max_entries from an object of type of_table_stats_entry.
 * @param obj Pointer to an object of type of_table_stats_entry.
 * @param max_entries Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_table_stats_entry_max_entries_get(
    of_table_stats_entry_t *obj,
    uint32_t *max_entries)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 40;
        break;
    case OF_VERSION_1_1:
        offset = 64;
        break;
    case OF_VERSION_1_2:
        offset = 104;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, max_entries);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set max_entries in an object of type of_table_stats_entry.
 * @param obj Pointer to an object of type of_table_stats_entry.
 * @param max_entries The value to write into the object
 */
void
of_table_stats_entry_max_entries_set(
    of_table_stats_entry_t *obj,
    uint32_t max_entries)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_TABLE_STATS_ENTRY);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_0:
        offset = 40;
        break;
    case OF_VERSION_1_1:
        offset = 64;
        break;
    case OF_VERSION_1_2:
        offset = 104;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, max_entries);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_uint32 */
/** \ingroup of_uint32 
 * @{ */

/**
 * Get value from an object of type of_uint32.
 * @param obj Pointer to an object of type of_uint32.
 * @param value Pointer to the child object of type
 * uint32_t to be filled out.
 *
 */
void
of_uint32_value_get(
    of_uint32_t *obj,
    uint32_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_UINT32);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 0;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_uint32.
 * @param obj Pointer to an object of type of_uint32.
 * @param value The value to write into the object
 */
void
of_uint32_value_set(
    of_uint32_t *obj,
    uint32_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_UINT32);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 0;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u32_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_uint8 */
/** \ingroup of_uint8 
 * @{ */

/**
 * Get value from an object of type of_uint8.
 * @param obj Pointer to an object of type of_uint8.
 * @param value Pointer to the child object of type
 * uint8_t to be filled out.
 *
 */
void
of_uint8_value_get(
    of_uint8_t *obj,
    uint8_t *value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_UINT8);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 0;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_get(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/**
 * Set value in an object of type of_uint8.
 * @param obj Pointer to an object of type of_uint8.
 * @param value The value to write into the object
 */
void
of_uint8_value_set(
    of_uint8_t *obj,
    uint8_t value)
{
    of_wire_buffer_t *wbuf;
    int offset = 0; /* Offset of value relative to the start obj */
    int abs_offset; /* Offset of value relative to start of wbuf */
    of_version_t ver;

    ASSERT(obj->object_id == OF_UINT8);
    ver = obj->version;
    wbuf = OF_OBJECT_TO_WBUF(obj);
    ASSERT(wbuf != NULL);

    /* By version, determine offset and current length (where needed) */
    switch (ver) {
    case OF_VERSION_1_3:
        offset = 0;
        break;
    default:
        ASSERT(0);
    }

    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, offset);
    ASSERT(abs_offset >= 0);
    of_wire_buffer_u8_set(wbuf, abs_offset, value);

    OF_LENGTH_CHECK_ASSERT(obj);

    return ;
}

/** @} */

/* Unified accessor functions for of_list_action */

/**
 * Associate an iterator with a list
 * @param list The list to iterate over
 * @param obj The list entry iteration pointer
 * @return OF_ERROR_RANGE if the list is empty (end of list)
 *
 * The obj instance is completely initialized.  The caller is responsible
 * for cleaning up any wire buffers associated with obj before this call
 */

int
of_list_action_first(of_list_action_t *list,
    of_action_t *obj)
{
    int rv;

    of_action_header_init((of_action_header_t *)obj,
            list->version, 0, 1);
    if ((rv = of_list_first((of_object_t *)list, (of_object_t *)obj)) < 0) {
        return rv;
    }

    of_object_wire_init((of_object_t *) obj, OF_ACTION,
                        list->length);
    if (obj->header.length == 0) {
        return OF_ERROR_PARSE;
    }

    return rv;
}

/**
 * Advance an iterator to the next element in a list
 * @param list The list being iterated
 * @param obj The list entry iteration pointer
 * @return OF_ERROR_RANGE if already at the last entry on the list
 *
 */

int
of_list_action_next(of_list_action_t *list,
    of_action_t *obj)
{
    int rv;

    if ((rv = of_list_next((of_object_t *)list, (of_object_t *)obj)) < 0) {
        return rv;
    }

    rv = of_object_wire_init((of_object_t *) obj, OF_ACTION,
        list->length);

    if ((rv == OF_ERROR_NONE) && (obj->header.length == 0)) {
        return OF_ERROR_PARSE;
    }

    return rv;
}

/**
 * Set up to append an object of type of_action to an of_list_action.
 * @param list The list that is prepared for append
 * @param obj Pointer to object to hold data to append
 *
 * The obj instance is completely initialized.  The caller is responsible
 * for cleaning up any wire buffers associated with obj before this call.
 *
 * See the generic documentation for of_list_append_bind.
 */

int
of_list_action_append_bind(of_list_action_t *list,
    of_action_t *obj)
{
    return of_list_append_bind((of_object_t *)list, (of_object_t *)obj);
}

/**
 * Append an item to a of_list_action list.
 *
 * This copies data from item and leaves item untouched.
 *
 * See the generic documentation for of_list_append.
 */

int
of_list_action_append(of_list_action_t *list,
    of_action_t *item)
{
    return of_list_append((of_object_t *)list, (of_object_t *)item);
}


/* Unified accessor functions for of_list_action_id */

/**
 * Associate an iterator with a list
 * @param list The list to iterate over
 * @param obj The list entry iteration pointer
 * @return OF_ERROR_RANGE if the list is empty (end of list)
 *
 * The obj instance is completely initialized.  The caller is responsible
 * for cleaning up any wire buffers associated with obj before this call
 */

int
of_list_action_id_first(of_list_action_id_t *list,
    of_action_id_t *obj)
{
    int rv;

    of_action_id_header_init((of_action_id_header_t *)obj,
            list->version, 0, 1);
    if ((rv = of_list_first((of_object_t *)list, (of_object_t *)obj)) < 0) {
        return rv;
    }

    of_object_wire_init((of_object_t *) obj, OF_ACTION_ID,
                        list->length);
    if (obj->header.length == 0) {
        return OF_ERROR_PARSE;
    }

    return rv;
}

/**
 * Advance an iterator to the next element in a list
 * @param list The list being iterated
 * @param obj The list entry iteration pointer
 * @return OF_ERROR_RANGE if already at the last entry on the list
 *
 */

int
of_list_action_id_next(of_list_action_id_t *list,
    of_action_id_t *obj)
{
    int rv;

    if ((rv = of_list_next((of_object_t *)list, (of_object_t *)obj)) < 0) {
        return rv;
    }

    rv = of_object_wire_init((of_object_t *) obj, OF_ACTION_ID,
        list->length);

    if ((rv == OF_ERROR_NONE) && (obj->header.length == 0)) {
        return OF_ERROR_PARSE;
    }

    return rv;
}

/**
 * Set up to append an object of type of_action_id to an of_list_action_id.
 * @param list The list that is prepared for append
 * @param obj Pointer to object to hold data to append
 *
 * The obj instance is completely initialized.  The caller is responsible
 * for cleaning up any wire buffers associated with obj before this call.
 *
 * See the generic documentation for of_list_append_bind.
 */

int
of_list_action_id_append_bind(of_list_action_id_t *list,
    of_action_id_t *obj)
{
    return of_list_append_bind((of_object_t *)list, (of_object_t *)obj);
}

/**
 * Append an item to a of_list_action_id list.
 *
 * This copies data from item and leaves item untouched.
 *
 * See the generic documentation for of_list_append.
 */

int
of_list_action_id_append(of_list_action_id_t *list,
    of_action_id_t *item)
{
    return of_list_append((of_object_t *)list, (of_object_t *)item);
}


/* Unified accessor functions for of_list_bsn_interface */

/**
 * Associate an iterator with a list
 * @param list The list to iterate over
 * @param obj The list entry iteration pointer
 * @return OF_ERROR_RANGE if the list is empty (end of list)
 *
 * The obj instance is completely initialized.  The caller is responsible
 * for cleaning up any wire buffers associated with obj before this call
 */

int
of_list_bsn_interface_first(of_list_bsn_interface_t *list,
    of_bsn_interface_t *obj)
{
    int rv;

    of_bsn_interface_init(obj,
            list->version, 0, 1);
    if ((rv = of_list_first((of_object_t *)list, (of_object_t *)obj)) < 0) {
        return rv;
    }

    of_object_wire_init((of_object_t *) obj, OF_BSN_INTERFACE,
                        list->length);
    if (obj->length == 0) {
        return OF_ERROR_PARSE;
    }

    return rv;
}

/**
 * Advance an iterator to the next element in a list
 * @param list The list being iterated
 * @param obj The list entry iteration pointer
 * @return OF_ERROR_RANGE if already at the last entry on the list
 *
 */

int
of_list_bsn_interface_next(of_list_bsn_interface_t *list,
    of_bsn_interface_t *obj)
{
    int rv;

    if ((rv = of_list_next((of_object_t *)list, (of_object_t *)obj)) < 0) {
        return rv;
    }

    rv = of_object_wire_init((of_object_t *) obj, OF_BSN_INTERFACE,
        list->length);

    if ((rv == OF_ERROR_NONE) && (obj->length == 0)) {
        return OF_ERROR_PARSE;
    }

    return rv;
}

/**
 * Set up to append an object of type of_bsn_interface to an of_list_bsn_interface.
 * @param list The list that is prepared for append
 * @param obj Pointer to object to hold data to append
 *
 * The obj instance is completely initialized.  The caller is responsible
 * for cleaning up any wire buffers associated with obj before this call.
 *
 * See the generic documentation for of_list_append_bind.
 */

int
of_list_bsn_interface_append_bind(of_list_bsn_interface_t *list,
    of_bsn_interface_t *obj)
{
    return of_list_append_bind((of_object_t *)list, (of_object_t *)obj);
}

/**
 * Append an item to a of_list_bsn_interface list.
 *
 * This copies data from item and leaves item untouched.
 *
 * See the generic documentation for of_list_append.
 */

int
of_list_bsn_interface_append(of_list_bsn_interface_t *list,
    of_bsn_interface_t *item)
{
    return of_list_append((of_object_t *)list, (of_object_t *)item);
}


/* Unified accessor functions for of_list_bucket */

/**
 * Associate an iterator with a list
 * @param list The list to iterate over
 * @param obj The list entry iteration pointer
 * @return OF_ERROR_RANGE if the list is empty (end of list)
 *
 * The obj instance is completely initialized.  The caller is responsible
 * for cleaning up any wire buffers associated with obj before this call
 */

int
of_list_bucket_first(of_list_bucket_t *list,
    of_bucket_t *obj)
{
    int rv;

    of_bucket_init(obj,
            list->version, 0, 1);
    if ((rv = of_list_first((of_object_t *)list, (of_object_t *)obj)) < 0) {
        return rv;
    }

    of_object_wire_init((of_object_t *) obj, OF_BUCKET,
                        list->length);
    if (obj->length == 0) {
        return OF_ERROR_PARSE;
    }

    return rv;
}

/**
 * Advance an iterator to the next element in a list
 * @param list The list being iterated
 * @param obj The list entry iteration pointer
 * @return OF_ERROR_RANGE if already at the last entry on the list
 *
 */

int
of_list_bucket_next(of_list_bucket_t *list,
    of_bucket_t *obj)
{
    int rv;

    if ((rv = of_list_next((of_object_t *)list, (of_object_t *)obj)) < 0) {
        return rv;
    }

    rv = of_object_wire_init((of_object_t *) obj, OF_BUCKET,
        list->length);

    if ((rv == OF_ERROR_NONE) && (obj->length == 0)) {
        return OF_ERROR_PARSE;
    }

    return rv;
}

/**
 * Set up to append an object of type of_bucket to an of_list_bucket.
 * @param list The list that is prepared for append
 * @param obj Pointer to object to hold data to append
 *
 * The obj instance is completely initialized.  The caller is responsible
 * for cleaning up any wire buffers associated with obj before this call.
 *
 * See the generic documentation for of_list_append_bind.
 */

int
of_list_bucket_append_bind(of_list_bucket_t *list,
    of_bucket_t *obj)
{
    return of_list_append_bind((of_object_t *)list, (of_object_t *)obj);
}

/**
 * Append an item to a of_list_bucket list.
 *
 * This copies data from item and leaves item untouched.
 *
 * See the generic documentation for of_list_append.
 */

int
of_list_bucket_append(of_list_bucket_t *list,
    of_bucket_t *item)
{
    return of_list_append((of_object_t *)list, (of_object_t *)item);
}


/* Unified accessor functions for of_list_bucket_counter */

/**
 * Associate an iterator with a list
 * @param list The list to iterate over
 * @param obj The list entry iteration pointer
 * @return OF_ERROR_RANGE if the list is empty (end of list)
 *
 * The obj instance is completely initialized.  The caller is responsible
 * for cleaning up any wire buffers associated with obj before this call
 */

int
of_list_bucket_counter_first(of_list_bucket_counter_t *list,
    of_bucket_counter_t *obj)
{
    int rv;

    of_bucket_counter_init(obj,
            list->version, 0, 1);
    if ((rv = of_list_first((of_object_t *)list, (of_object_t *)obj)) < 0) {
        return rv;
    }

    of_object_wire_init((of_object_t *) obj, OF_BUCKET_COUNTER,
                        list->length);
    if (obj->length == 0) {
        return OF_ERROR_PARSE;
    }

    return rv;
}

/**
 * Advance an iterator to the next element in a list
 * @param list The list being iterated
 * @param obj The list entry iteration pointer
 * @return OF_ERROR_RANGE if already at the last entry on the list
 *
 */

int
of_list_bucket_counter_next(of_list_bucket_counter_t *list,
    of_bucket_counter_t *obj)
{
    int rv;

    if ((rv = of_list_next((of_object_t *)list, (of_object_t *)obj)) < 0) {
        return rv;
    }

    rv = of_object_wire_init((of_object_t *) obj, OF_BUCKET_COUNTER,
        list->length);

    if ((rv == OF_ERROR_NONE) && (obj->length == 0)) {
        return OF_ERROR_PARSE;
    }

    return rv;
}

/**
 * Set up to append an object of type of_bucket_counter to an of_list_bucket_counter.
 * @param list The list that is prepared for append
 * @param obj Pointer to object to hold data to append
 *
 * The obj instance is completely initialized.  The caller is responsible
 * for cleaning up any wire buffers associated with obj before this call.
 *
 * See the generic documentation for of_list_append_bind.
 */

int
of_list_bucket_counter_append_bind(of_list_bucket_counter_t *list,
    of_bucket_counter_t *obj)
{
    return of_list_append_bind((of_object_t *)list, (of_object_t *)obj);
}

/**
 * Append an item to a of_list_bucket_counter list.
 *
 * This copies data from item and leaves item untouched.
 *
 * See the generic documentation for of_list_append.
 */

int
of_list_bucket_counter_append(of_list_bucket_counter_t *list,
    of_bucket_counter_t *item)
{
    return of_list_append((of_object_t *)list, (of_object_t *)item);
}


/* Unified accessor functions for of_list_flow_stats_entry */

/**
 * Associate an iterator with a list
 * @param list The list to iterate over
 * @param obj The list entry iteration pointer
 * @return OF_ERROR_RANGE if the list is empty (end of list)
 *
 * The obj instance is completely initialized.  The caller is responsible
 * for cleaning up any wire buffers associated with obj before this call
 */

int
of_list_flow_stats_entry_first(of_list_flow_stats_entry_t *list,
    of_flow_stats_entry_t *obj)
{
    int rv;

    of_flow_stats_entry_init(obj,
            list->version, 0, 1);
    if ((rv = of_list_first((of_object_t *)list, (of_object_t *)obj)) < 0) {
        return rv;
    }

    of_object_wire_init((of_object_t *) obj, OF_FLOW_STATS_ENTRY,
                        list->length);
    if (obj->length == 0) {
        return OF_ERROR_PARSE;
    }

    return rv;
}

/**
 * Advance an iterator to the next element in a list
 * @param list The list being iterated
 * @param obj The list entry iteration pointer
 * @return OF_ERROR_RANGE if already at the last entry on the list
 *
 */

int
of_list_flow_stats_entry_next(of_list_flow_stats_entry_t *list,
    of_flow_stats_entry_t *obj)
{
    int rv;

    if ((rv = of_list_next((of_object_t *)list, (of_object_t *)obj)) < 0) {
        return rv;
    }

    rv = of_object_wire_init((of_object_t *) obj, OF_FLOW_STATS_ENTRY,
        list->length);

    if ((rv == OF_ERROR_NONE) && (obj->length == 0)) {
        return OF_ERROR_PARSE;
    }

    return rv;
}

/**
 * Set up to append an object of type of_flow_stats_entry to an of_list_flow_stats_entry.
 * @param list The list that is prepared for append
 * @param obj Pointer to object to hold data to append
 *
 * The obj instance is completely initialized.  The caller is responsible
 * for cleaning up any wire buffers associated with obj before this call.
 *
 * See the generic documentation for of_list_append_bind.
 */

int
of_list_flow_stats_entry_append_bind(of_list_flow_stats_entry_t *list,
    of_flow_stats_entry_t *obj)
{
    return of_list_append_bind((of_object_t *)list, (of_object_t *)obj);
}

/**
 * Append an item to a of_list_flow_stats_entry list.
 *
 * This copies data from item and leaves item untouched.
 *
 * See the generic documentation for of_list_append.
 */

int
of_list_flow_stats_entry_append(of_list_flow_stats_entry_t *list,
    of_flow_stats_entry_t *item)
{
    return of_list_append((of_object_t *)list, (of_object_t *)item);
}


/* Unified accessor functions for of_list_group_desc_stats_entry */

/**
 * Associate an iterator with a list
 * @param list The list to iterate over
 * @param obj The list entry iteration pointer
 * @return OF_ERROR_RANGE if the list is empty (end of list)
 *
 * The obj instance is completely initialized.  The caller is responsible
 * for cleaning up any wire buffers associated with obj before this call
 */

int
of_list_group_desc_stats_entry_first(of_list_group_desc_stats_entry_t *list,
    of_group_desc_stats_entry_t *obj)
{
    int rv;

    of_group_desc_stats_entry_init(obj,
            list->version, 0, 1);
    if ((rv = of_list_first((of_object_t *)list, (of_object_t *)obj)) < 0) {
        return rv;
    }

    of_object_wire_init((of_object_t *) obj, OF_GROUP_DESC_STATS_ENTRY,
                        list->length);
    if (obj->length == 0) {
        return OF_ERROR_PARSE;
    }

    return rv;
}

/**
 * Advance an iterator to the next element in a list
 * @param list The list being iterated
 * @param obj The list entry iteration pointer
 * @return OF_ERROR_RANGE if already at the last entry on the list
 *
 */

int
of_list_group_desc_stats_entry_next(of_list_group_desc_stats_entry_t *list,
    of_group_desc_stats_entry_t *obj)
{
    int rv;

    if ((rv = of_list_next((of_object_t *)list, (of_object_t *)obj)) < 0) {
        return rv;
    }

    rv = of_object_wire_init((of_object_t *) obj, OF_GROUP_DESC_STATS_ENTRY,
        list->length);

    if ((rv == OF_ERROR_NONE) && (obj->length == 0)) {
        return OF_ERROR_PARSE;
    }

    return rv;
}

/**
 * Set up to append an object of type of_group_desc_stats_entry to an of_list_group_desc_stats_entry.
 * @param list The list that is prepared for append
 * @param obj Pointer to object to hold data to append
 *
 * The obj instance is completely initialized.  The caller is responsible
 * for cleaning up any wire buffers associated with obj before this call.
 *
 * See the generic documentation for of_list_append_bind.
 */

int
of_list_group_desc_stats_entry_append_bind(of_list_group_desc_stats_entry_t *list,
    of_group_desc_stats_entry_t *obj)
{
    return of_list_append_bind((of_object_t *)list, (of_object_t *)obj);
}

/**
 * Append an item to a of_list_group_desc_stats_entry list.
 *
 * This copies data from item and leaves item untouched.
 *
 * See the generic documentation for of_list_append.
 */

int
of_list_group_desc_stats_entry_append(of_list_group_desc_stats_entry_t *list,
    of_group_desc_stats_entry_t *item)
{
    return of_list_append((of_object_t *)list, (of_object_t *)item);
}


/* Unified accessor functions for of_list_group_stats_entry */

/**
 * Associate an iterator with a list
 * @param list The list to iterate over
 * @param obj The list entry iteration pointer
 * @return OF_ERROR_RANGE if the list is empty (end of list)
 *
 * The obj instance is completely initialized.  The caller is responsible
 * for cleaning up any wire buffers associated with obj before this call
 */

int
of_list_group_stats_entry_first(of_list_group_stats_entry_t *list,
    of_group_stats_entry_t *obj)
{
    int rv;

    of_group_stats_entry_init(obj,
            list->version, 0, 1);
    if ((rv = of_list_first((of_object_t *)list, (of_object_t *)obj)) < 0) {
        return rv;
    }

    of_object_wire_init((of_object_t *) obj, OF_GROUP_STATS_ENTRY,
                        list->length);
    if (obj->length == 0) {
        return OF_ERROR_PARSE;
    }

    return rv;
}

/**
 * Advance an iterator to the next element in a list
 * @param list The list being iterated
 * @param obj The list entry iteration pointer
 * @return OF_ERROR_RANGE if already at the last entry on the list
 *
 */

int
of_list_group_stats_entry_next(of_list_group_stats_entry_t *list,
    of_group_stats_entry_t *obj)
{
    int rv;

    if ((rv = of_list_next((of_object_t *)list, (of_object_t *)obj)) < 0) {
        return rv;
    }

    rv = of_object_wire_init((of_object_t *) obj, OF_GROUP_STATS_ENTRY,
        list->length);

    if ((rv == OF_ERROR_NONE) && (obj->length == 0)) {
        return OF_ERROR_PARSE;
    }

    return rv;
}

/**
 * Set up to append an object of type of_group_stats_entry to an of_list_group_stats_entry.
 * @param list The list that is prepared for append
 * @param obj Pointer to object to hold data to append
 *
 * The obj instance is completely initialized.  The caller is responsible
 * for cleaning up any wire buffers associated with obj before this call.
 *
 * See the generic documentation for of_list_append_bind.
 */

int
of_list_group_stats_entry_append_bind(of_list_group_stats_entry_t *list,
    of_group_stats_entry_t *obj)
{
    return of_list_append_bind((of_object_t *)list, (of_object_t *)obj);
}

/**
 * Append an item to a of_list_group_stats_entry list.
 *
 * This copies data from item and leaves item untouched.
 *
 * See the generic documentation for of_list_append.
 */

int
of_list_group_stats_entry_append(of_list_group_stats_entry_t *list,
    of_group_stats_entry_t *item)
{
    return of_list_append((of_object_t *)list, (of_object_t *)item);
}


/* Unified accessor functions for of_list_hello_elem */

/**
 * Associate an iterator with a list
 * @param list The list to iterate over
 * @param obj The list entry iteration pointer
 * @return OF_ERROR_RANGE if the list is empty (end of list)
 *
 * The obj instance is completely initialized.  The caller is responsible
 * for cleaning up any wire buffers associated with obj before this call
 */

int
of_list_hello_elem_first(of_list_hello_elem_t *list,
    of_hello_elem_t *obj)
{
    int rv;

    of_hello_elem_header_init((of_hello_elem_header_t *)obj,
            list->version, 0, 1);
    if ((rv = of_list_first((of_object_t *)list, (of_object_t *)obj)) < 0) {
        return rv;
    }

    of_object_wire_init((of_object_t *) obj, OF_HELLO_ELEM,
                        list->length);
    if (obj->header.length == 0) {
        return OF_ERROR_PARSE;
    }

    return rv;
}

/**
 * Advance an iterator to the next element in a list
 * @param list The list being iterated
 * @param obj The list entry iteration pointer
 * @return OF_ERROR_RANGE if already at the last entry on the list
 *
 */

int
of_list_hello_elem_next(of_list_hello_elem_t *list,
    of_hello_elem_t *obj)
{
    int rv;

    if ((rv = of_list_next((of_object_t *)list, (of_object_t *)obj)) < 0) {
        return rv;
    }

    rv = of_object_wire_init((of_object_t *) obj, OF_HELLO_ELEM,
        list->length);

    if ((rv == OF_ERROR_NONE) && (obj->header.length == 0)) {
        return OF_ERROR_PARSE;
    }

    return rv;
}

/**
 * Set up to append an object of type of_hello_elem to an of_list_hello_elem.
 * @param list The list that is prepared for append
 * @param obj Pointer to object to hold data to append
 *
 * The obj instance is completely initialized.  The caller is responsible
 * for cleaning up any wire buffers associated with obj before this call.
 *
 * See the generic documentation for of_list_append_bind.
 */

int
of_list_hello_elem_append_bind(of_list_hello_elem_t *list,
    of_hello_elem_t *obj)
{
    return of_list_append_bind((of_object_t *)list, (of_object_t *)obj);
}

/**
 * Append an item to a of_list_hello_elem list.
 *
 * This copies data from item and leaves item untouched.
 *
 * See the generic documentation for of_list_append.
 */

int
of_list_hello_elem_append(of_list_hello_elem_t *list,
    of_hello_elem_t *item)
{
    return of_list_append((of_object_t *)list, (of_object_t *)item);
}


/* Unified accessor functions for of_list_instruction */

/**
 * Associate an iterator with a list
 * @param list The list to iterate over
 * @param obj The list entry iteration pointer
 * @return OF_ERROR_RANGE if the list is empty (end of list)
 *
 * The obj instance is completely initialized.  The caller is responsible
 * for cleaning up any wire buffers associated with obj before this call
 */

int
of_list_instruction_first(of_list_instruction_t *list,
    of_instruction_t *obj)
{
    int rv;

    of_instruction_header_init((of_instruction_header_t *)obj,
            list->version, 0, 1);
    if ((rv = of_list_first((of_object_t *)list, (of_object_t *)obj)) < 0) {
        return rv;
    }

    of_object_wire_init((of_object_t *) obj, OF_INSTRUCTION,
                        list->length);
    if (obj->header.length == 0) {
        return OF_ERROR_PARSE;
    }

    return rv;
}

/**
 * Advance an iterator to the next element in a list
 * @param list The list being iterated
 * @param obj The list entry iteration pointer
 * @return OF_ERROR_RANGE if already at the last entry on the list
 *
 */

int
of_list_instruction_next(of_list_instruction_t *list,
    of_instruction_t *obj)
{
    int rv;

    if ((rv = of_list_next((of_object_t *)list, (of_object_t *)obj)) < 0) {
        return rv;
    }

    rv = of_object_wire_init((of_object_t *) obj, OF_INSTRUCTION,
        list->length);

    if ((rv == OF_ERROR_NONE) && (obj->header.length == 0)) {
        return OF_ERROR_PARSE;
    }

    return rv;
}

/**
 * Set up to append an object of type of_instruction to an of_list_instruction.
 * @param list The list that is prepared for append
 * @param obj Pointer to object to hold data to append
 *
 * The obj instance is completely initialized.  The caller is responsible
 * for cleaning up any wire buffers associated with obj before this call.
 *
 * See the generic documentation for of_list_append_bind.
 */

int
of_list_instruction_append_bind(of_list_instruction_t *list,
    of_instruction_t *obj)
{
    return of_list_append_bind((of_object_t *)list, (of_object_t *)obj);
}

/**
 * Append an item to a of_list_instruction list.
 *
 * This copies data from item and leaves item untouched.
 *
 * See the generic documentation for of_list_append.
 */

int
of_list_instruction_append(of_list_instruction_t *list,
    of_instruction_t *item)
{
    return of_list_append((of_object_t *)list, (of_object_t *)item);
}


/* Unified accessor functions for of_list_meter_band */

/**
 * Associate an iterator with a list
 * @param list The list to iterate over
 * @param obj The list entry iteration pointer
 * @return OF_ERROR_RANGE if the list is empty (end of list)
 *
 * The obj instance is completely initialized.  The caller is responsible
 * for cleaning up any wire buffers associated with obj before this call
 */

int
of_list_meter_band_first(of_list_meter_band_t *list,
    of_meter_band_t *obj)
{
    int rv;

    of_meter_band_header_init((of_meter_band_header_t *)obj,
            list->version, 0, 1);
    if ((rv = of_list_first((of_object_t *)list, (of_object_t *)obj)) < 0) {
        return rv;
    }

    of_object_wire_init((of_object_t *) obj, OF_METER_BAND,
                        list->length);
    if (obj->header.length == 0) {
        return OF_ERROR_PARSE;
    }

    return rv;
}

/**
 * Advance an iterator to the next element in a list
 * @param list The list being iterated
 * @param obj The list entry iteration pointer
 * @return OF_ERROR_RANGE if already at the last entry on the list
 *
 */

int
of_list_meter_band_next(of_list_meter_band_t *list,
    of_meter_band_t *obj)
{
    int rv;

    if ((rv = of_list_next((of_object_t *)list, (of_object_t *)obj)) < 0) {
        return rv;
    }

    rv = of_object_wire_init((of_object_t *) obj, OF_METER_BAND,
        list->length);

    if ((rv == OF_ERROR_NONE) && (obj->header.length == 0)) {
        return OF_ERROR_PARSE;
    }

    return rv;
}

/**
 * Set up to append an object of type of_meter_band to an of_list_meter_band.
 * @param list The list that is prepared for append
 * @param obj Pointer to object to hold data to append
 *
 * The obj instance is completely initialized.  The caller is responsible
 * for cleaning up any wire buffers associated with obj before this call.
 *
 * See the generic documentation for of_list_append_bind.
 */

int
of_list_meter_band_append_bind(of_list_meter_band_t *list,
    of_meter_band_t *obj)
{
    return of_list_append_bind((of_object_t *)list, (of_object_t *)obj);
}

/**
 * Append an item to a of_list_meter_band list.
 *
 * This copies data from item and leaves item untouched.
 *
 * See the generic documentation for of_list_append.
 */

int
of_list_meter_band_append(of_list_meter_band_t *list,
    of_meter_band_t *item)
{
    return of_list_append((of_object_t *)list, (of_object_t *)item);
}


/* Unified accessor functions for of_list_meter_band_stats */

/**
 * Associate an iterator with a list
 * @param list The list to iterate over
 * @param obj The list entry iteration pointer
 * @return OF_ERROR_RANGE if the list is empty (end of list)
 *
 * The obj instance is completely initialized.  The caller is responsible
 * for cleaning up any wire buffers associated with obj before this call
 */

int
of_list_meter_band_stats_first(of_list_meter_band_stats_t *list,
    of_meter_band_stats_t *obj)
{
    int rv;

    of_meter_band_stats_init(obj,
            list->version, 0, 1);
    if ((rv = of_list_first((of_object_t *)list, (of_object_t *)obj)) < 0) {
        return rv;
    }

    of_object_wire_init((of_object_t *) obj, OF_METER_BAND_STATS,
                        list->length);
    if (obj->length == 0) {
        return OF_ERROR_PARSE;
    }

    return rv;
}

/**
 * Advance an iterator to the next element in a list
 * @param list The list being iterated
 * @param obj The list entry iteration pointer
 * @return OF_ERROR_RANGE if already at the last entry on the list
 *
 */

int
of_list_meter_band_stats_next(of_list_meter_band_stats_t *list,
    of_meter_band_stats_t *obj)
{
    int rv;

    if ((rv = of_list_next((of_object_t *)list, (of_object_t *)obj)) < 0) {
        return rv;
    }

    rv = of_object_wire_init((of_object_t *) obj, OF_METER_BAND_STATS,
        list->length);

    if ((rv == OF_ERROR_NONE) && (obj->length == 0)) {
        return OF_ERROR_PARSE;
    }

    return rv;
}

/**
 * Set up to append an object of type of_meter_band_stats to an of_list_meter_band_stats.
 * @param list The list that is prepared for append
 * @param obj Pointer to object to hold data to append
 *
 * The obj instance is completely initialized.  The caller is responsible
 * for cleaning up any wire buffers associated with obj before this call.
 *
 * See the generic documentation for of_list_append_bind.
 */

int
of_list_meter_band_stats_append_bind(of_list_meter_band_stats_t *list,
    of_meter_band_stats_t *obj)
{
    return of_list_append_bind((of_object_t *)list, (of_object_t *)obj);
}

/**
 * Append an item to a of_list_meter_band_stats list.
 *
 * This copies data from item and leaves item untouched.
 *
 * See the generic documentation for of_list_append.
 */

int
of_list_meter_band_stats_append(of_list_meter_band_stats_t *list,
    of_meter_band_stats_t *item)
{
    return of_list_append((of_object_t *)list, (of_object_t *)item);
}


/* Unified accessor functions for of_list_meter_stats */

/**
 * Associate an iterator with a list
 * @param list The list to iterate over
 * @param obj The list entry iteration pointer
 * @return OF_ERROR_RANGE if the list is empty (end of list)
 *
 * The obj instance is completely initialized.  The caller is responsible
 * for cleaning up any wire buffers associated with obj before this call
 */

int
of_list_meter_stats_first(of_list_meter_stats_t *list,
    of_meter_stats_t *obj)
{
    int rv;

    of_meter_stats_init(obj,
            list->version, 0, 1);
    if ((rv = of_list_first((of_object_t *)list, (of_object_t *)obj)) < 0) {
        return rv;
    }

    of_object_wire_init((of_object_t *) obj, OF_METER_STATS,
                        list->length);
    if (obj->length == 0) {
        return OF_ERROR_PARSE;
    }

    return rv;
}

/**
 * Advance an iterator to the next element in a list
 * @param list The list being iterated
 * @param obj The list entry iteration pointer
 * @return OF_ERROR_RANGE if already at the last entry on the list
 *
 */

int
of_list_meter_stats_next(of_list_meter_stats_t *list,
    of_meter_stats_t *obj)
{
    int rv;

    if ((rv = of_list_next((of_object_t *)list, (of_object_t *)obj)) < 0) {
        return rv;
    }

    rv = of_object_wire_init((of_object_t *) obj, OF_METER_STATS,
        list->length);

    if ((rv == OF_ERROR_NONE) && (obj->length == 0)) {
        return OF_ERROR_PARSE;
    }

    return rv;
}

/**
 * Set up to append an object of type of_meter_stats to an of_list_meter_stats.
 * @param list The list that is prepared for append
 * @param obj Pointer to object to hold data to append
 *
 * The obj instance is completely initialized.  The caller is responsible
 * for cleaning up any wire buffers associated with obj before this call.
 *
 * See the generic documentation for of_list_append_bind.
 */

int
of_list_meter_stats_append_bind(of_list_meter_stats_t *list,
    of_meter_stats_t *obj)
{
    return of_list_append_bind((of_object_t *)list, (of_object_t *)obj);
}

/**
 * Append an item to a of_list_meter_stats list.
 *
 * This copies data from item and leaves item untouched.
 *
 * See the generic documentation for of_list_append.
 */

int
of_list_meter_stats_append(of_list_meter_stats_t *list,
    of_meter_stats_t *item)
{
    return of_list_append((of_object_t *)list, (of_object_t *)item);
}


/* Unified accessor functions for of_list_oxm */

/**
 * Associate an iterator with a list
 * @param list The list to iterate over
 * @param obj The list entry iteration pointer
 * @return OF_ERROR_RANGE if the list is empty (end of list)
 *
 * The obj instance is completely initialized.  The caller is responsible
 * for cleaning up any wire buffers associated with obj before this call
 */

int
of_list_oxm_first(of_list_oxm_t *list,
    of_oxm_t *obj)
{
    int rv;

    of_oxm_header_init((of_oxm_header_t *)obj,
            list->version, 0, 1);
    if ((rv = of_list_first((of_object_t *)list, (of_object_t *)obj)) < 0) {
        return rv;
    }

    of_object_wire_init((of_object_t *) obj, OF_OXM,
                        list->length);
    if (obj->header.length == 0) {
        return OF_ERROR_PARSE;
    }

    return rv;
}

/**
 * Advance an iterator to the next element in a list
 * @param list The list being iterated
 * @param obj The list entry iteration pointer
 * @return OF_ERROR_RANGE if already at the last entry on the list
 *
 */

int
of_list_oxm_next(of_list_oxm_t *list,
    of_oxm_t *obj)
{
    int rv;

    if ((rv = of_list_next((of_object_t *)list, (of_object_t *)obj)) < 0) {
        return rv;
    }

    rv = of_object_wire_init((of_object_t *) obj, OF_OXM,
        list->length);

    if ((rv == OF_ERROR_NONE) && (obj->header.length == 0)) {
        return OF_ERROR_PARSE;
    }

    return rv;
}

/**
 * Set up to append an object of type of_oxm to an of_list_oxm.
 * @param list The list that is prepared for append
 * @param obj Pointer to object to hold data to append
 *
 * The obj instance is completely initialized.  The caller is responsible
 * for cleaning up any wire buffers associated with obj before this call.
 *
 * See the generic documentation for of_list_append_bind.
 */

int
of_list_oxm_append_bind(of_list_oxm_t *list,
    of_oxm_t *obj)
{
    return of_list_append_bind((of_object_t *)list, (of_object_t *)obj);
}

/**
 * Append an item to a of_list_oxm list.
 *
 * This copies data from item and leaves item untouched.
 *
 * See the generic documentation for of_list_append.
 */

int
of_list_oxm_append(of_list_oxm_t *list,
    of_oxm_t *item)
{
    return of_list_append((of_object_t *)list, (of_object_t *)item);
}


/* Unified accessor functions for of_list_packet_queue */

/**
 * Associate an iterator with a list
 * @param list The list to iterate over
 * @param obj The list entry iteration pointer
 * @return OF_ERROR_RANGE if the list is empty (end of list)
 *
 * The obj instance is completely initialized.  The caller is responsible
 * for cleaning up any wire buffers associated with obj before this call
 */

int
of_list_packet_queue_first(of_list_packet_queue_t *list,
    of_packet_queue_t *obj)
{
    int rv;

    of_packet_queue_init(obj,
            list->version, 0, 1);
    if ((rv = of_list_first((of_object_t *)list, (of_object_t *)obj)) < 0) {
        return rv;
    }

    of_object_wire_init((of_object_t *) obj, OF_PACKET_QUEUE,
                        list->length);
    if (obj->length == 0) {
        return OF_ERROR_PARSE;
    }

    return rv;
}

/**
 * Advance an iterator to the next element in a list
 * @param list The list being iterated
 * @param obj The list entry iteration pointer
 * @return OF_ERROR_RANGE if already at the last entry on the list
 *
 */

int
of_list_packet_queue_next(of_list_packet_queue_t *list,
    of_packet_queue_t *obj)
{
    int rv;

    if ((rv = of_list_next((of_object_t *)list, (of_object_t *)obj)) < 0) {
        return rv;
    }

    rv = of_object_wire_init((of_object_t *) obj, OF_PACKET_QUEUE,
        list->length);

    if ((rv == OF_ERROR_NONE) && (obj->length == 0)) {
        return OF_ERROR_PARSE;
    }

    return rv;
}

/**
 * Set up to append an object of type of_packet_queue to an of_list_packet_queue.
 * @param list The list that is prepared for append
 * @param obj Pointer to object to hold data to append
 *
 * The obj instance is completely initialized.  The caller is responsible
 * for cleaning up any wire buffers associated with obj before this call.
 *
 * See the generic documentation for of_list_append_bind.
 */

int
of_list_packet_queue_append_bind(of_list_packet_queue_t *list,
    of_packet_queue_t *obj)
{
    return of_list_append_bind((of_object_t *)list, (of_object_t *)obj);
}

/**
 * Append an item to a of_list_packet_queue list.
 *
 * This copies data from item and leaves item untouched.
 *
 * See the generic documentation for of_list_append.
 */

int
of_list_packet_queue_append(of_list_packet_queue_t *list,
    of_packet_queue_t *item)
{
    return of_list_append((of_object_t *)list, (of_object_t *)item);
}


/* Unified accessor functions for of_list_port_desc */

/**
 * Associate an iterator with a list
 * @param list The list to iterate over
 * @param obj The list entry iteration pointer
 * @return OF_ERROR_RANGE if the list is empty (end of list)
 *
 * The obj instance is completely initialized.  The caller is responsible
 * for cleaning up any wire buffers associated with obj before this call
 */

int
of_list_port_desc_first(of_list_port_desc_t *list,
    of_port_desc_t *obj)
{
    int rv;

    of_port_desc_init(obj,
            list->version, 0, 1);
    if ((rv = of_list_first((of_object_t *)list, (of_object_t *)obj)) < 0) {
        return rv;
    }

    of_object_wire_init((of_object_t *) obj, OF_PORT_DESC,
                        list->length);
    if (obj->length == 0) {
        return OF_ERROR_PARSE;
    }

    return rv;
}

/**
 * Advance an iterator to the next element in a list
 * @param list The list being iterated
 * @param obj The list entry iteration pointer
 * @return OF_ERROR_RANGE if already at the last entry on the list
 *
 */

int
of_list_port_desc_next(of_list_port_desc_t *list,
    of_port_desc_t *obj)
{
    int rv;

    if ((rv = of_list_next((of_object_t *)list, (of_object_t *)obj)) < 0) {
        return rv;
    }

    rv = of_object_wire_init((of_object_t *) obj, OF_PORT_DESC,
        list->length);

    if ((rv == OF_ERROR_NONE) && (obj->length == 0)) {
        return OF_ERROR_PARSE;
    }

    return rv;
}

/**
 * Set up to append an object of type of_port_desc to an of_list_port_desc.
 * @param list The list that is prepared for append
 * @param obj Pointer to object to hold data to append
 *
 * The obj instance is completely initialized.  The caller is responsible
 * for cleaning up any wire buffers associated with obj before this call.
 *
 * See the generic documentation for of_list_append_bind.
 */

int
of_list_port_desc_append_bind(of_list_port_desc_t *list,
    of_port_desc_t *obj)
{
    return of_list_append_bind((of_object_t *)list, (of_object_t *)obj);
}

/**
 * Append an item to a of_list_port_desc list.
 *
 * This copies data from item and leaves item untouched.
 *
 * See the generic documentation for of_list_append.
 */

int
of_list_port_desc_append(of_list_port_desc_t *list,
    of_port_desc_t *item)
{
    return of_list_append((of_object_t *)list, (of_object_t *)item);
}


/* Unified accessor functions for of_list_port_stats_entry */

/**
 * Associate an iterator with a list
 * @param list The list to iterate over
 * @param obj The list entry iteration pointer
 * @return OF_ERROR_RANGE if the list is empty (end of list)
 *
 * The obj instance is completely initialized.  The caller is responsible
 * for cleaning up any wire buffers associated with obj before this call
 */

int
of_list_port_stats_entry_first(of_list_port_stats_entry_t *list,
    of_port_stats_entry_t *obj)
{
    int rv;

    of_port_stats_entry_init(obj,
            list->version, 0, 1);
    if ((rv = of_list_first((of_object_t *)list, (of_object_t *)obj)) < 0) {
        return rv;
    }

    of_object_wire_init((of_object_t *) obj, OF_PORT_STATS_ENTRY,
                        list->length);
    if (obj->length == 0) {
        return OF_ERROR_PARSE;
    }

    return rv;
}

/**
 * Advance an iterator to the next element in a list
 * @param list The list being iterated
 * @param obj The list entry iteration pointer
 * @return OF_ERROR_RANGE if already at the last entry on the list
 *
 */

int
of_list_port_stats_entry_next(of_list_port_stats_entry_t *list,
    of_port_stats_entry_t *obj)
{
    int rv;

    if ((rv = of_list_next((of_object_t *)list, (of_object_t *)obj)) < 0) {
        return rv;
    }

    rv = of_object_wire_init((of_object_t *) obj, OF_PORT_STATS_ENTRY,
        list->length);

    if ((rv == OF_ERROR_NONE) && (obj->length == 0)) {
        return OF_ERROR_PARSE;
    }

    return rv;
}

/**
 * Set up to append an object of type of_port_stats_entry to an of_list_port_stats_entry.
 * @param list The list that is prepared for append
 * @param obj Pointer to object to hold data to append
 *
 * The obj instance is completely initialized.  The caller is responsible
 * for cleaning up any wire buffers associated with obj before this call.
 *
 * See the generic documentation for of_list_append_bind.
 */

int
of_list_port_stats_entry_append_bind(of_list_port_stats_entry_t *list,
    of_port_stats_entry_t *obj)
{
    return of_list_append_bind((of_object_t *)list, (of_object_t *)obj);
}

/**
 * Append an item to a of_list_port_stats_entry list.
 *
 * This copies data from item and leaves item untouched.
 *
 * See the generic documentation for of_list_append.
 */

int
of_list_port_stats_entry_append(of_list_port_stats_entry_t *list,
    of_port_stats_entry_t *item)
{
    return of_list_append((of_object_t *)list, (of_object_t *)item);
}


/* Unified accessor functions for of_list_queue_prop */

/**
 * Associate an iterator with a list
 * @param list The list to iterate over
 * @param obj The list entry iteration pointer
 * @return OF_ERROR_RANGE if the list is empty (end of list)
 *
 * The obj instance is completely initialized.  The caller is responsible
 * for cleaning up any wire buffers associated with obj before this call
 */

int
of_list_queue_prop_first(of_list_queue_prop_t *list,
    of_queue_prop_t *obj)
{
    int rv;

    of_queue_prop_header_init((of_queue_prop_header_t *)obj,
            list->version, 0, 1);
    if ((rv = of_list_first((of_object_t *)list, (of_object_t *)obj)) < 0) {
        return rv;
    }

    of_object_wire_init((of_object_t *) obj, OF_QUEUE_PROP,
                        list->length);
    if (obj->header.length == 0) {
        return OF_ERROR_PARSE;
    }

    return rv;
}

/**
 * Advance an iterator to the next element in a list
 * @param list The list being iterated
 * @param obj The list entry iteration pointer
 * @return OF_ERROR_RANGE if already at the last entry on the list
 *
 */

int
of_list_queue_prop_next(of_list_queue_prop_t *list,
    of_queue_prop_t *obj)
{
    int rv;

    if ((rv = of_list_next((of_object_t *)list, (of_object_t *)obj)) < 0) {
        return rv;
    }

    rv = of_object_wire_init((of_object_t *) obj, OF_QUEUE_PROP,
        list->length);

    if ((rv == OF_ERROR_NONE) && (obj->header.length == 0)) {
        return OF_ERROR_PARSE;
    }

    return rv;
}

/**
 * Set up to append an object of type of_queue_prop to an of_list_queue_prop.
 * @param list The list that is prepared for append
 * @param obj Pointer to object to hold data to append
 *
 * The obj instance is completely initialized.  The caller is responsible
 * for cleaning up any wire buffers associated with obj before this call.
 *
 * See the generic documentation for of_list_append_bind.
 */

int
of_list_queue_prop_append_bind(of_list_queue_prop_t *list,
    of_queue_prop_t *obj)
{
    return of_list_append_bind((of_object_t *)list, (of_object_t *)obj);
}

/**
 * Append an item to a of_list_queue_prop list.
 *
 * This copies data from item and leaves item untouched.
 *
 * See the generic documentation for of_list_append.
 */

int
of_list_queue_prop_append(of_list_queue_prop_t *list,
    of_queue_prop_t *item)
{
    return of_list_append((of_object_t *)list, (of_object_t *)item);
}


/* Unified accessor functions for of_list_queue_stats_entry */

/**
 * Associate an iterator with a list
 * @param list The list to iterate over
 * @param obj The list entry iteration pointer
 * @return OF_ERROR_RANGE if the list is empty (end of list)
 *
 * The obj instance is completely initialized.  The caller is responsible
 * for cleaning up any wire buffers associated with obj before this call
 */

int
of_list_queue_stats_entry_first(of_list_queue_stats_entry_t *list,
    of_queue_stats_entry_t *obj)
{
    int rv;

    of_queue_stats_entry_init(obj,
            list->version, 0, 1);
    if ((rv = of_list_first((of_object_t *)list, (of_object_t *)obj)) < 0) {
        return rv;
    }

    of_object_wire_init((of_object_t *) obj, OF_QUEUE_STATS_ENTRY,
                        list->length);
    if (obj->length == 0) {
        return OF_ERROR_PARSE;
    }

    return rv;
}

/**
 * Advance an iterator to the next element in a list
 * @param list The list being iterated
 * @param obj The list entry iteration pointer
 * @return OF_ERROR_RANGE if already at the last entry on the list
 *
 */

int
of_list_queue_stats_entry_next(of_list_queue_stats_entry_t *list,
    of_queue_stats_entry_t *obj)
{
    int rv;

    if ((rv = of_list_next((of_object_t *)list, (of_object_t *)obj)) < 0) {
        return rv;
    }

    rv = of_object_wire_init((of_object_t *) obj, OF_QUEUE_STATS_ENTRY,
        list->length);

    if ((rv == OF_ERROR_NONE) && (obj->length == 0)) {
        return OF_ERROR_PARSE;
    }

    return rv;
}

/**
 * Set up to append an object of type of_queue_stats_entry to an of_list_queue_stats_entry.
 * @param list The list that is prepared for append
 * @param obj Pointer to object to hold data to append
 *
 * The obj instance is completely initialized.  The caller is responsible
 * for cleaning up any wire buffers associated with obj before this call.
 *
 * See the generic documentation for of_list_append_bind.
 */

int
of_list_queue_stats_entry_append_bind(of_list_queue_stats_entry_t *list,
    of_queue_stats_entry_t *obj)
{
    return of_list_append_bind((of_object_t *)list, (of_object_t *)obj);
}

/**
 * Append an item to a of_list_queue_stats_entry list.
 *
 * This copies data from item and leaves item untouched.
 *
 * See the generic documentation for of_list_append.
 */

int
of_list_queue_stats_entry_append(of_list_queue_stats_entry_t *list,
    of_queue_stats_entry_t *item)
{
    return of_list_append((of_object_t *)list, (of_object_t *)item);
}


/* Unified accessor functions for of_list_table_feature_prop */

/**
 * Associate an iterator with a list
 * @param list The list to iterate over
 * @param obj The list entry iteration pointer
 * @return OF_ERROR_RANGE if the list is empty (end of list)
 *
 * The obj instance is completely initialized.  The caller is responsible
 * for cleaning up any wire buffers associated with obj before this call
 */

int
of_list_table_feature_prop_first(of_list_table_feature_prop_t *list,
    of_table_feature_prop_t *obj)
{
    int rv;

    of_table_feature_prop_header_init((of_table_feature_prop_header_t *)obj,
            list->version, 0, 1);
    if ((rv = of_list_first((of_object_t *)list, (of_object_t *)obj)) < 0) {
        return rv;
    }

    of_object_wire_init((of_object_t *) obj, OF_TABLE_FEATURE_PROP,
                        list->length);
    if (obj->header.length == 0) {
        return OF_ERROR_PARSE;
    }

    return rv;
}

/**
 * Advance an iterator to the next element in a list
 * @param list The list being iterated
 * @param obj The list entry iteration pointer
 * @return OF_ERROR_RANGE if already at the last entry on the list
 *
 */

int
of_list_table_feature_prop_next(of_list_table_feature_prop_t *list,
    of_table_feature_prop_t *obj)
{
    int rv;

    if ((rv = of_list_next((of_object_t *)list, (of_object_t *)obj)) < 0) {
        return rv;
    }

    rv = of_object_wire_init((of_object_t *) obj, OF_TABLE_FEATURE_PROP,
        list->length);

    if ((rv == OF_ERROR_NONE) && (obj->header.length == 0)) {
        return OF_ERROR_PARSE;
    }

    return rv;
}

/**
 * Set up to append an object of type of_table_feature_prop to an of_list_table_feature_prop.
 * @param list The list that is prepared for append
 * @param obj Pointer to object to hold data to append
 *
 * The obj instance is completely initialized.  The caller is responsible
 * for cleaning up any wire buffers associated with obj before this call.
 *
 * See the generic documentation for of_list_append_bind.
 */

int
of_list_table_feature_prop_append_bind(of_list_table_feature_prop_t *list,
    of_table_feature_prop_t *obj)
{
    return of_list_append_bind((of_object_t *)list, (of_object_t *)obj);
}

/**
 * Append an item to a of_list_table_feature_prop list.
 *
 * This copies data from item and leaves item untouched.
 *
 * See the generic documentation for of_list_append.
 */

int
of_list_table_feature_prop_append(of_list_table_feature_prop_t *list,
    of_table_feature_prop_t *item)
{
    return of_list_append((of_object_t *)list, (of_object_t *)item);
}


/* Unified accessor functions for of_list_table_features */

/**
 * Associate an iterator with a list
 * @param list The list to iterate over
 * @param obj The list entry iteration pointer
 * @return OF_ERROR_RANGE if the list is empty (end of list)
 *
 * The obj instance is completely initialized.  The caller is responsible
 * for cleaning up any wire buffers associated with obj before this call
 */

int
of_list_table_features_first(of_list_table_features_t *list,
    of_table_features_t *obj)
{
    int rv;

    of_table_features_init(obj,
            list->version, 0, 1);
    if ((rv = of_list_first((of_object_t *)list, (of_object_t *)obj)) < 0) {
        return rv;
    }

    of_object_wire_init((of_object_t *) obj, OF_TABLE_FEATURES,
                        list->length);
    if (obj->length == 0) {
        return OF_ERROR_PARSE;
    }

    return rv;
}

/**
 * Advance an iterator to the next element in a list
 * @param list The list being iterated
 * @param obj The list entry iteration pointer
 * @return OF_ERROR_RANGE if already at the last entry on the list
 *
 */

int
of_list_table_features_next(of_list_table_features_t *list,
    of_table_features_t *obj)
{
    int rv;

    if ((rv = of_list_next((of_object_t *)list, (of_object_t *)obj)) < 0) {
        return rv;
    }

    rv = of_object_wire_init((of_object_t *) obj, OF_TABLE_FEATURES,
        list->length);

    if ((rv == OF_ERROR_NONE) && (obj->length == 0)) {
        return OF_ERROR_PARSE;
    }

    return rv;
}

/**
 * Set up to append an object of type of_table_features to an of_list_table_features.
 * @param list The list that is prepared for append
 * @param obj Pointer to object to hold data to append
 *
 * The obj instance is completely initialized.  The caller is responsible
 * for cleaning up any wire buffers associated with obj before this call.
 *
 * See the generic documentation for of_list_append_bind.
 */

int
of_list_table_features_append_bind(of_list_table_features_t *list,
    of_table_features_t *obj)
{
    return of_list_append_bind((of_object_t *)list, (of_object_t *)obj);
}

/**
 * Append an item to a of_list_table_features list.
 *
 * This copies data from item and leaves item untouched.
 *
 * See the generic documentation for of_list_append.
 */

int
of_list_table_features_append(of_list_table_features_t *list,
    of_table_features_t *item)
{
    return of_list_append((of_object_t *)list, (of_object_t *)item);
}


/* Unified accessor functions for of_list_table_stats_entry */

/**
 * Associate an iterator with a list
 * @param list The list to iterate over
 * @param obj The list entry iteration pointer
 * @return OF_ERROR_RANGE if the list is empty (end of list)
 *
 * The obj instance is completely initialized.  The caller is responsible
 * for cleaning up any wire buffers associated with obj before this call
 */

int
of_list_table_stats_entry_first(of_list_table_stats_entry_t *list,
    of_table_stats_entry_t *obj)
{
    int rv;

    of_table_stats_entry_init(obj,
            list->version, 0, 1);
    if ((rv = of_list_first((of_object_t *)list, (of_object_t *)obj)) < 0) {
        return rv;
    }

    of_object_wire_init((of_object_t *) obj, OF_TABLE_STATS_ENTRY,
                        list->length);
    if (obj->length == 0) {
        return OF_ERROR_PARSE;
    }

    return rv;
}

/**
 * Advance an iterator to the next element in a list
 * @param list The list being iterated
 * @param obj The list entry iteration pointer
 * @return OF_ERROR_RANGE if already at the last entry on the list
 *
 */

int
of_list_table_stats_entry_next(of_list_table_stats_entry_t *list,
    of_table_stats_entry_t *obj)
{
    int rv;

    if ((rv = of_list_next((of_object_t *)list, (of_object_t *)obj)) < 0) {
        return rv;
    }

    rv = of_object_wire_init((of_object_t *) obj, OF_TABLE_STATS_ENTRY,
        list->length);

    if ((rv == OF_ERROR_NONE) && (obj->length == 0)) {
        return OF_ERROR_PARSE;
    }

    return rv;
}

/**
 * Set up to append an object of type of_table_stats_entry to an of_list_table_stats_entry.
 * @param list The list that is prepared for append
 * @param obj Pointer to object to hold data to append
 *
 * The obj instance is completely initialized.  The caller is responsible
 * for cleaning up any wire buffers associated with obj before this call.
 *
 * See the generic documentation for of_list_append_bind.
 */

int
of_list_table_stats_entry_append_bind(of_list_table_stats_entry_t *list,
    of_table_stats_entry_t *obj)
{
    return of_list_append_bind((of_object_t *)list, (of_object_t *)obj);
}

/**
 * Append an item to a of_list_table_stats_entry list.
 *
 * This copies data from item and leaves item untouched.
 *
 * See the generic documentation for of_list_append.
 */

int
of_list_table_stats_entry_append(of_list_table_stats_entry_t *list,
    of_table_stats_entry_t *item)
{
    return of_list_append((of_object_t *)list, (of_object_t *)item);
}


/* Unified accessor functions for of_list_uint32 */

/**
 * Associate an iterator with a list
 * @param list The list to iterate over
 * @param obj The list entry iteration pointer
 * @return OF_ERROR_RANGE if the list is empty (end of list)
 *
 * The obj instance is completely initialized.  The caller is responsible
 * for cleaning up any wire buffers associated with obj before this call
 */

int
of_list_uint32_first(of_list_uint32_t *list,
    of_uint32_t *obj)
{
    int rv;

    of_uint32_init(obj,
            list->version, 0, 1);
    if ((rv = of_list_first((of_object_t *)list, (of_object_t *)obj)) < 0) {
        return rv;
    }

    of_object_wire_init((of_object_t *) obj, OF_UINT32,
                        list->length);
    if (obj->length == 0) {
        return OF_ERROR_PARSE;
    }

    return rv;
}

/**
 * Advance an iterator to the next element in a list
 * @param list The list being iterated
 * @param obj The list entry iteration pointer
 * @return OF_ERROR_RANGE if already at the last entry on the list
 *
 */

int
of_list_uint32_next(of_list_uint32_t *list,
    of_uint32_t *obj)
{
    int rv;

    if ((rv = of_list_next((of_object_t *)list, (of_object_t *)obj)) < 0) {
        return rv;
    }

    rv = of_object_wire_init((of_object_t *) obj, OF_UINT32,
        list->length);

    if ((rv == OF_ERROR_NONE) && (obj->length == 0)) {
        return OF_ERROR_PARSE;
    }

    return rv;
}

/**
 * Set up to append an object of type of_uint32 to an of_list_uint32.
 * @param list The list that is prepared for append
 * @param obj Pointer to object to hold data to append
 *
 * The obj instance is completely initialized.  The caller is responsible
 * for cleaning up any wire buffers associated with obj before this call.
 *
 * See the generic documentation for of_list_append_bind.
 */

int
of_list_uint32_append_bind(of_list_uint32_t *list,
    of_uint32_t *obj)
{
    return of_list_append_bind((of_object_t *)list, (of_object_t *)obj);
}

/**
 * Append an item to a of_list_uint32 list.
 *
 * This copies data from item and leaves item untouched.
 *
 * See the generic documentation for of_list_append.
 */

int
of_list_uint32_append(of_list_uint32_t *list,
    of_uint32_t *item)
{
    return of_list_append((of_object_t *)list, (of_object_t *)item);
}


/* Unified accessor functions for of_list_uint8 */

/**
 * Associate an iterator with a list
 * @param list The list to iterate over
 * @param obj The list entry iteration pointer
 * @return OF_ERROR_RANGE if the list is empty (end of list)
 *
 * The obj instance is completely initialized.  The caller is responsible
 * for cleaning up any wire buffers associated with obj before this call
 */

int
of_list_uint8_first(of_list_uint8_t *list,
    of_uint8_t *obj)
{
    int rv;

    of_uint8_init(obj,
            list->version, 0, 1);
    if ((rv = of_list_first((of_object_t *)list, (of_object_t *)obj)) < 0) {
        return rv;
    }

    of_object_wire_init((of_object_t *) obj, OF_UINT8,
                        list->length);
    if (obj->length == 0) {
        return OF_ERROR_PARSE;
    }

    return rv;
}

/**
 * Advance an iterator to the next element in a list
 * @param list The list being iterated
 * @param obj The list entry iteration pointer
 * @return OF_ERROR_RANGE if already at the last entry on the list
 *
 */

int
of_list_uint8_next(of_list_uint8_t *list,
    of_uint8_t *obj)
{
    int rv;

    if ((rv = of_list_next((of_object_t *)list, (of_object_t *)obj)) < 0) {
        return rv;
    }

    rv = of_object_wire_init((of_object_t *) obj, OF_UINT8,
        list->length);

    if ((rv == OF_ERROR_NONE) && (obj->length == 0)) {
        return OF_ERROR_PARSE;
    }

    return rv;
}

/**
 * Set up to append an object of type of_uint8 to an of_list_uint8.
 * @param list The list that is prepared for append
 * @param obj Pointer to object to hold data to append
 *
 * The obj instance is completely initialized.  The caller is responsible
 * for cleaning up any wire buffers associated with obj before this call.
 *
 * See the generic documentation for of_list_append_bind.
 */

int
of_list_uint8_append_bind(of_list_uint8_t *list,
    of_uint8_t *obj)
{
    return of_list_append_bind((of_object_t *)list, (of_object_t *)obj);
}

/**
 * Append an item to a of_list_uint8 list.
 *
 * This copies data from item and leaves item untouched.
 *
 * See the generic documentation for of_list_append.
 */

int
of_list_uint8_append(of_list_uint8_t *list,
    of_uint8_t *item)
{
    return of_list_append((of_object_t *)list, (of_object_t *)item);
}


/* New operators for each message class */

/* New operators for of_aggregate_stats_reply */

/**
 * \defgroup of_aggregate_stats_reply of_aggregate_stats_reply
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_aggregate_stats_reply_push_wire_values(of_aggregate_stats_reply_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_AGGREGATE_STATS_REPLY));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_aggregate_stats_reply object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_aggregate_stats_reply
 */

of_aggregate_stats_reply_t *
of_aggregate_stats_reply_new_(of_version_t version)
{
    of_aggregate_stats_reply_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_AGGREGATE_STATS_REPLY] + of_object_extra_len[version][OF_AGGREGATE_STATS_REPLY];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_aggregate_stats_reply_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_aggregate_stats_reply_init(obj, version, bytes, 0);

    if (of_aggregate_stats_reply_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_aggregate_stats_reply_t *
of_aggregate_stats_reply_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_aggregate_stats_reply_t *obj;

    obj = of_aggregate_stats_reply_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_aggregate_stats_reply.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_aggregate_stats_reply_init(of_aggregate_stats_reply_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_AGGREGATE_STATS_REPLY] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_AGGREGATE_STATS_REPLY] + of_object_extra_len[version][OF_AGGREGATE_STATS_REPLY];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_AGGREGATE_STATS_REPLY;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_aggregate_stats_reply object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_aggregate_stats_reply
 */

of_aggregate_stats_reply_t *
of_aggregate_stats_reply_new_from_message_(of_message_t msg)
{
    of_aggregate_stats_reply_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_aggregate_stats_reply_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_aggregate_stats_reply_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_aggregate_stats_reply_t *
of_aggregate_stats_reply_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_aggregate_stats_reply_t *obj;

    obj = of_aggregate_stats_reply_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_aggregate_stats_request */

/**
 * \defgroup of_aggregate_stats_request of_aggregate_stats_request
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_aggregate_stats_request_push_wire_values(of_aggregate_stats_request_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_AGGREGATE_STATS_REQUEST));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_aggregate_stats_request object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_aggregate_stats_request
 */

of_aggregate_stats_request_t *
of_aggregate_stats_request_new_(of_version_t version)
{
    of_aggregate_stats_request_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_AGGREGATE_STATS_REQUEST] + of_object_extra_len[version][OF_AGGREGATE_STATS_REQUEST];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_aggregate_stats_request_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_aggregate_stats_request_init(obj, version, bytes, 0);

    if (of_aggregate_stats_request_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    /* Initialize match TLV for 1.2 */
    /* FIXME: Check 1.3 below */
    if ((version == OF_VERSION_1_2) || (version == OF_VERSION_1_3)) {
        of_object_u16_set((of_object_t *)obj, 48 + 2, 4);
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_aggregate_stats_request_t *
of_aggregate_stats_request_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_aggregate_stats_request_t *obj;

    obj = of_aggregate_stats_request_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_aggregate_stats_request.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_aggregate_stats_request_init(of_aggregate_stats_request_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_AGGREGATE_STATS_REQUEST] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_AGGREGATE_STATS_REQUEST] + of_object_extra_len[version][OF_AGGREGATE_STATS_REQUEST];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_AGGREGATE_STATS_REQUEST;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_aggregate_stats_request object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_aggregate_stats_request
 */

of_aggregate_stats_request_t *
of_aggregate_stats_request_new_from_message_(of_message_t msg)
{
    of_aggregate_stats_request_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_aggregate_stats_request_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_aggregate_stats_request_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_aggregate_stats_request_t *
of_aggregate_stats_request_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_aggregate_stats_request_t *obj;

    obj = of_aggregate_stats_request_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_async_get_reply */

/**
 * \defgroup of_async_get_reply of_async_get_reply
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_async_get_reply_push_wire_values(of_async_get_reply_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_ASYNC_GET_REPLY));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_async_get_reply object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_async_get_reply
 */

of_async_get_reply_t *
of_async_get_reply_new_(of_version_t version)
{
    of_async_get_reply_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ASYNC_GET_REPLY] + of_object_extra_len[version][OF_ASYNC_GET_REPLY];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_async_get_reply_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_async_get_reply_init(obj, version, bytes, 0);

    if (of_async_get_reply_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_async_get_reply_t *
of_async_get_reply_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_async_get_reply_t *obj;

    obj = of_async_get_reply_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_async_get_reply.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_async_get_reply_init(of_async_get_reply_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ASYNC_GET_REPLY] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ASYNC_GET_REPLY] + of_object_extra_len[version][OF_ASYNC_GET_REPLY];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ASYNC_GET_REPLY;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_async_get_reply object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_async_get_reply
 */

of_async_get_reply_t *
of_async_get_reply_new_from_message_(of_message_t msg)
{
    of_async_get_reply_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_async_get_reply_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_async_get_reply_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_async_get_reply_t *
of_async_get_reply_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_async_get_reply_t *obj;

    obj = of_async_get_reply_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_async_get_request */

/**
 * \defgroup of_async_get_request of_async_get_request
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_async_get_request_push_wire_values(of_async_get_request_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_ASYNC_GET_REQUEST));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_async_get_request object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_async_get_request
 */

of_async_get_request_t *
of_async_get_request_new_(of_version_t version)
{
    of_async_get_request_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ASYNC_GET_REQUEST] + of_object_extra_len[version][OF_ASYNC_GET_REQUEST];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_async_get_request_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_async_get_request_init(obj, version, bytes, 0);

    if (of_async_get_request_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_async_get_request_t *
of_async_get_request_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_async_get_request_t *obj;

    obj = of_async_get_request_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_async_get_request.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_async_get_request_init(of_async_get_request_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ASYNC_GET_REQUEST] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ASYNC_GET_REQUEST] + of_object_extra_len[version][OF_ASYNC_GET_REQUEST];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ASYNC_GET_REQUEST;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_async_get_request object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_async_get_request
 */

of_async_get_request_t *
of_async_get_request_new_from_message_(of_message_t msg)
{
    of_async_get_request_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_async_get_request_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_async_get_request_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_async_get_request_t *
of_async_get_request_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_async_get_request_t *obj;

    obj = of_async_get_request_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_async_set */

/**
 * \defgroup of_async_set of_async_set
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_async_set_push_wire_values(of_async_set_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_ASYNC_SET));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_async_set object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_async_set
 */

of_async_set_t *
of_async_set_new_(of_version_t version)
{
    of_async_set_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ASYNC_SET] + of_object_extra_len[version][OF_ASYNC_SET];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_async_set_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_async_set_init(obj, version, bytes, 0);

    if (of_async_set_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_async_set_t *
of_async_set_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_async_set_t *obj;

    obj = of_async_set_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_async_set.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_async_set_init(of_async_set_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ASYNC_SET] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ASYNC_SET] + of_object_extra_len[version][OF_ASYNC_SET];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ASYNC_SET;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_async_set object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_async_set
 */

of_async_set_t *
of_async_set_new_from_message_(of_message_t msg)
{
    of_async_set_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_async_set_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_async_set_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_async_set_t *
of_async_set_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_async_set_t *obj;

    obj = of_async_set_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_barrier_reply */

/**
 * \defgroup of_barrier_reply of_barrier_reply
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_barrier_reply_push_wire_values(of_barrier_reply_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_BARRIER_REPLY));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_barrier_reply object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_barrier_reply
 */

of_barrier_reply_t *
of_barrier_reply_new_(of_version_t version)
{
    of_barrier_reply_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_BARRIER_REPLY] + of_object_extra_len[version][OF_BARRIER_REPLY];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_barrier_reply_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_barrier_reply_init(obj, version, bytes, 0);

    if (of_barrier_reply_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_barrier_reply_t *
of_barrier_reply_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_barrier_reply_t *obj;

    obj = of_barrier_reply_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_barrier_reply.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_barrier_reply_init(of_barrier_reply_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_BARRIER_REPLY] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_BARRIER_REPLY] + of_object_extra_len[version][OF_BARRIER_REPLY];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_BARRIER_REPLY;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_barrier_reply object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_barrier_reply
 */

of_barrier_reply_t *
of_barrier_reply_new_from_message_(of_message_t msg)
{
    of_barrier_reply_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_barrier_reply_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_barrier_reply_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_barrier_reply_t *
of_barrier_reply_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_barrier_reply_t *obj;

    obj = of_barrier_reply_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_barrier_request */

/**
 * \defgroup of_barrier_request of_barrier_request
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_barrier_request_push_wire_values(of_barrier_request_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_BARRIER_REQUEST));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_barrier_request object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_barrier_request
 */

of_barrier_request_t *
of_barrier_request_new_(of_version_t version)
{
    of_barrier_request_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_BARRIER_REQUEST] + of_object_extra_len[version][OF_BARRIER_REQUEST];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_barrier_request_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_barrier_request_init(obj, version, bytes, 0);

    if (of_barrier_request_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_barrier_request_t *
of_barrier_request_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_barrier_request_t *obj;

    obj = of_barrier_request_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_barrier_request.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_barrier_request_init(of_barrier_request_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_BARRIER_REQUEST] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_BARRIER_REQUEST] + of_object_extra_len[version][OF_BARRIER_REQUEST];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_BARRIER_REQUEST;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_barrier_request object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_barrier_request
 */

of_barrier_request_t *
of_barrier_request_new_from_message_(of_message_t msg)
{
    of_barrier_request_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_barrier_request_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_barrier_request_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_barrier_request_t *
of_barrier_request_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_barrier_request_t *obj;

    obj = of_barrier_request_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_bsn_bw_clear_data_reply */

/**
 * \defgroup of_bsn_bw_clear_data_reply of_bsn_bw_clear_data_reply
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_bsn_bw_clear_data_reply_push_wire_values(of_bsn_bw_clear_data_reply_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_BSN_BW_CLEAR_DATA_REPLY));
    }

    if (obj->version == OF_VERSION_1_0) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            22);
    }

    if (obj->version == OF_VERSION_1_1) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            22);
    }

    if (obj->version == OF_VERSION_1_2) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            22);
    }

    if (obj->version == OF_VERSION_1_3) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            22);
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_bsn_bw_clear_data_reply object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_bsn_bw_clear_data_reply
 */

of_bsn_bw_clear_data_reply_t *
of_bsn_bw_clear_data_reply_new_(of_version_t version)
{
    of_bsn_bw_clear_data_reply_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_BSN_BW_CLEAR_DATA_REPLY] + of_object_extra_len[version][OF_BSN_BW_CLEAR_DATA_REPLY];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_bsn_bw_clear_data_reply_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_bsn_bw_clear_data_reply_init(obj, version, bytes, 0);

    if (of_bsn_bw_clear_data_reply_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_bw_clear_data_reply_t *
of_bsn_bw_clear_data_reply_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_bsn_bw_clear_data_reply_t *obj;

    obj = of_bsn_bw_clear_data_reply_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_bsn_bw_clear_data_reply.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_bsn_bw_clear_data_reply_init(of_bsn_bw_clear_data_reply_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_BSN_BW_CLEAR_DATA_REPLY] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_BSN_BW_CLEAR_DATA_REPLY] + of_object_extra_len[version][OF_BSN_BW_CLEAR_DATA_REPLY];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_BSN_BW_CLEAR_DATA_REPLY;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_bsn_bw_clear_data_reply object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_bsn_bw_clear_data_reply
 */

of_bsn_bw_clear_data_reply_t *
of_bsn_bw_clear_data_reply_new_from_message_(of_message_t msg)
{
    of_bsn_bw_clear_data_reply_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_bsn_bw_clear_data_reply_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_bsn_bw_clear_data_reply_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_bw_clear_data_reply_t *
of_bsn_bw_clear_data_reply_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_bsn_bw_clear_data_reply_t *obj;

    obj = of_bsn_bw_clear_data_reply_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_bsn_bw_clear_data_request */

/**
 * \defgroup of_bsn_bw_clear_data_request of_bsn_bw_clear_data_request
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_bsn_bw_clear_data_request_push_wire_values(of_bsn_bw_clear_data_request_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_BSN_BW_CLEAR_DATA_REQUEST));
    }

    if (obj->version == OF_VERSION_1_0) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            21);
    }

    if (obj->version == OF_VERSION_1_1) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            21);
    }

    if (obj->version == OF_VERSION_1_2) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            21);
    }

    if (obj->version == OF_VERSION_1_3) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            21);
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_bsn_bw_clear_data_request object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_bsn_bw_clear_data_request
 */

of_bsn_bw_clear_data_request_t *
of_bsn_bw_clear_data_request_new_(of_version_t version)
{
    of_bsn_bw_clear_data_request_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_BSN_BW_CLEAR_DATA_REQUEST] + of_object_extra_len[version][OF_BSN_BW_CLEAR_DATA_REQUEST];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_bsn_bw_clear_data_request_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_bsn_bw_clear_data_request_init(obj, version, bytes, 0);

    if (of_bsn_bw_clear_data_request_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_bw_clear_data_request_t *
of_bsn_bw_clear_data_request_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_bsn_bw_clear_data_request_t *obj;

    obj = of_bsn_bw_clear_data_request_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_bsn_bw_clear_data_request.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_bsn_bw_clear_data_request_init(of_bsn_bw_clear_data_request_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_BSN_BW_CLEAR_DATA_REQUEST] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_BSN_BW_CLEAR_DATA_REQUEST] + of_object_extra_len[version][OF_BSN_BW_CLEAR_DATA_REQUEST];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_BSN_BW_CLEAR_DATA_REQUEST;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_bsn_bw_clear_data_request object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_bsn_bw_clear_data_request
 */

of_bsn_bw_clear_data_request_t *
of_bsn_bw_clear_data_request_new_from_message_(of_message_t msg)
{
    of_bsn_bw_clear_data_request_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_bsn_bw_clear_data_request_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_bsn_bw_clear_data_request_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_bw_clear_data_request_t *
of_bsn_bw_clear_data_request_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_bsn_bw_clear_data_request_t *obj;

    obj = of_bsn_bw_clear_data_request_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_bsn_bw_enable_get_reply */

/**
 * \defgroup of_bsn_bw_enable_get_reply of_bsn_bw_enable_get_reply
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_bsn_bw_enable_get_reply_push_wire_values(of_bsn_bw_enable_get_reply_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_BSN_BW_ENABLE_GET_REPLY));
    }

    if (obj->version == OF_VERSION_1_0) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            20);
    }

    if (obj->version == OF_VERSION_1_1) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            20);
    }

    if (obj->version == OF_VERSION_1_2) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            20);
    }

    if (obj->version == OF_VERSION_1_3) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            20);
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_bsn_bw_enable_get_reply object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_bsn_bw_enable_get_reply
 */

of_bsn_bw_enable_get_reply_t *
of_bsn_bw_enable_get_reply_new_(of_version_t version)
{
    of_bsn_bw_enable_get_reply_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_BSN_BW_ENABLE_GET_REPLY] + of_object_extra_len[version][OF_BSN_BW_ENABLE_GET_REPLY];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_bsn_bw_enable_get_reply_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_bsn_bw_enable_get_reply_init(obj, version, bytes, 0);

    if (of_bsn_bw_enable_get_reply_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_bw_enable_get_reply_t *
of_bsn_bw_enable_get_reply_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_bsn_bw_enable_get_reply_t *obj;

    obj = of_bsn_bw_enable_get_reply_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_bsn_bw_enable_get_reply.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_bsn_bw_enable_get_reply_init(of_bsn_bw_enable_get_reply_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_BSN_BW_ENABLE_GET_REPLY] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_BSN_BW_ENABLE_GET_REPLY] + of_object_extra_len[version][OF_BSN_BW_ENABLE_GET_REPLY];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_BSN_BW_ENABLE_GET_REPLY;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_bsn_bw_enable_get_reply object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_bsn_bw_enable_get_reply
 */

of_bsn_bw_enable_get_reply_t *
of_bsn_bw_enable_get_reply_new_from_message_(of_message_t msg)
{
    of_bsn_bw_enable_get_reply_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_bsn_bw_enable_get_reply_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_bsn_bw_enable_get_reply_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_bw_enable_get_reply_t *
of_bsn_bw_enable_get_reply_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_bsn_bw_enable_get_reply_t *obj;

    obj = of_bsn_bw_enable_get_reply_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_bsn_bw_enable_get_request */

/**
 * \defgroup of_bsn_bw_enable_get_request of_bsn_bw_enable_get_request
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_bsn_bw_enable_get_request_push_wire_values(of_bsn_bw_enable_get_request_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_BSN_BW_ENABLE_GET_REQUEST));
    }

    if (obj->version == OF_VERSION_1_0) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            19);
    }

    if (obj->version == OF_VERSION_1_1) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            19);
    }

    if (obj->version == OF_VERSION_1_2) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            19);
    }

    if (obj->version == OF_VERSION_1_3) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            19);
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_bsn_bw_enable_get_request object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_bsn_bw_enable_get_request
 */

of_bsn_bw_enable_get_request_t *
of_bsn_bw_enable_get_request_new_(of_version_t version)
{
    of_bsn_bw_enable_get_request_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_BSN_BW_ENABLE_GET_REQUEST] + of_object_extra_len[version][OF_BSN_BW_ENABLE_GET_REQUEST];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_bsn_bw_enable_get_request_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_bsn_bw_enable_get_request_init(obj, version, bytes, 0);

    if (of_bsn_bw_enable_get_request_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_bw_enable_get_request_t *
of_bsn_bw_enable_get_request_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_bsn_bw_enable_get_request_t *obj;

    obj = of_bsn_bw_enable_get_request_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_bsn_bw_enable_get_request.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_bsn_bw_enable_get_request_init(of_bsn_bw_enable_get_request_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_BSN_BW_ENABLE_GET_REQUEST] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_BSN_BW_ENABLE_GET_REQUEST] + of_object_extra_len[version][OF_BSN_BW_ENABLE_GET_REQUEST];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_BSN_BW_ENABLE_GET_REQUEST;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_bsn_bw_enable_get_request object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_bsn_bw_enable_get_request
 */

of_bsn_bw_enable_get_request_t *
of_bsn_bw_enable_get_request_new_from_message_(of_message_t msg)
{
    of_bsn_bw_enable_get_request_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_bsn_bw_enable_get_request_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_bsn_bw_enable_get_request_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_bw_enable_get_request_t *
of_bsn_bw_enable_get_request_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_bsn_bw_enable_get_request_t *obj;

    obj = of_bsn_bw_enable_get_request_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_bsn_bw_enable_set_reply */

/**
 * \defgroup of_bsn_bw_enable_set_reply of_bsn_bw_enable_set_reply
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_bsn_bw_enable_set_reply_push_wire_values(of_bsn_bw_enable_set_reply_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_BSN_BW_ENABLE_SET_REPLY));
    }

    if (obj->version == OF_VERSION_1_0) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            23);
    }

    if (obj->version == OF_VERSION_1_1) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            23);
    }

    if (obj->version == OF_VERSION_1_2) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            23);
    }

    if (obj->version == OF_VERSION_1_3) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            23);
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_bsn_bw_enable_set_reply object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_bsn_bw_enable_set_reply
 */

of_bsn_bw_enable_set_reply_t *
of_bsn_bw_enable_set_reply_new_(of_version_t version)
{
    of_bsn_bw_enable_set_reply_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_BSN_BW_ENABLE_SET_REPLY] + of_object_extra_len[version][OF_BSN_BW_ENABLE_SET_REPLY];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_bsn_bw_enable_set_reply_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_bsn_bw_enable_set_reply_init(obj, version, bytes, 0);

    if (of_bsn_bw_enable_set_reply_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_bw_enable_set_reply_t *
of_bsn_bw_enable_set_reply_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_bsn_bw_enable_set_reply_t *obj;

    obj = of_bsn_bw_enable_set_reply_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_bsn_bw_enable_set_reply.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_bsn_bw_enable_set_reply_init(of_bsn_bw_enable_set_reply_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_BSN_BW_ENABLE_SET_REPLY] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_BSN_BW_ENABLE_SET_REPLY] + of_object_extra_len[version][OF_BSN_BW_ENABLE_SET_REPLY];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_BSN_BW_ENABLE_SET_REPLY;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_bsn_bw_enable_set_reply object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_bsn_bw_enable_set_reply
 */

of_bsn_bw_enable_set_reply_t *
of_bsn_bw_enable_set_reply_new_from_message_(of_message_t msg)
{
    of_bsn_bw_enable_set_reply_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_bsn_bw_enable_set_reply_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_bsn_bw_enable_set_reply_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_bw_enable_set_reply_t *
of_bsn_bw_enable_set_reply_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_bsn_bw_enable_set_reply_t *obj;

    obj = of_bsn_bw_enable_set_reply_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_bsn_bw_enable_set_request */

/**
 * \defgroup of_bsn_bw_enable_set_request of_bsn_bw_enable_set_request
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_bsn_bw_enable_set_request_push_wire_values(of_bsn_bw_enable_set_request_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_BSN_BW_ENABLE_SET_REQUEST));
    }

    if (obj->version == OF_VERSION_1_0) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            18);
    }

    if (obj->version == OF_VERSION_1_1) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            18);
    }

    if (obj->version == OF_VERSION_1_2) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            18);
    }

    if (obj->version == OF_VERSION_1_3) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            18);
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_bsn_bw_enable_set_request object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_bsn_bw_enable_set_request
 */

of_bsn_bw_enable_set_request_t *
of_bsn_bw_enable_set_request_new_(of_version_t version)
{
    of_bsn_bw_enable_set_request_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_BSN_BW_ENABLE_SET_REQUEST] + of_object_extra_len[version][OF_BSN_BW_ENABLE_SET_REQUEST];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_bsn_bw_enable_set_request_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_bsn_bw_enable_set_request_init(obj, version, bytes, 0);

    if (of_bsn_bw_enable_set_request_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_bw_enable_set_request_t *
of_bsn_bw_enable_set_request_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_bsn_bw_enable_set_request_t *obj;

    obj = of_bsn_bw_enable_set_request_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_bsn_bw_enable_set_request.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_bsn_bw_enable_set_request_init(of_bsn_bw_enable_set_request_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_BSN_BW_ENABLE_SET_REQUEST] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_BSN_BW_ENABLE_SET_REQUEST] + of_object_extra_len[version][OF_BSN_BW_ENABLE_SET_REQUEST];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_BSN_BW_ENABLE_SET_REQUEST;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_bsn_bw_enable_set_request object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_bsn_bw_enable_set_request
 */

of_bsn_bw_enable_set_request_t *
of_bsn_bw_enable_set_request_new_from_message_(of_message_t msg)
{
    of_bsn_bw_enable_set_request_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_bsn_bw_enable_set_request_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_bsn_bw_enable_set_request_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_bw_enable_set_request_t *
of_bsn_bw_enable_set_request_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_bsn_bw_enable_set_request_t *obj;

    obj = of_bsn_bw_enable_set_request_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_bsn_get_interfaces_reply */

/**
 * \defgroup of_bsn_get_interfaces_reply of_bsn_get_interfaces_reply
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_bsn_get_interfaces_reply_push_wire_values(of_bsn_get_interfaces_reply_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_BSN_GET_INTERFACES_REPLY));
    }

    if (obj->version == OF_VERSION_1_0) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            10);
    }

    if (obj->version == OF_VERSION_1_1) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            10);
    }

    if (obj->version == OF_VERSION_1_2) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            10);
    }

    if (obj->version == OF_VERSION_1_3) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            10);
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_bsn_get_interfaces_reply object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_bsn_get_interfaces_reply
 */

of_bsn_get_interfaces_reply_t *
of_bsn_get_interfaces_reply_new_(of_version_t version)
{
    of_bsn_get_interfaces_reply_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_BSN_GET_INTERFACES_REPLY] + of_object_extra_len[version][OF_BSN_GET_INTERFACES_REPLY];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_bsn_get_interfaces_reply_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_bsn_get_interfaces_reply_init(obj, version, bytes, 0);

    if (of_bsn_get_interfaces_reply_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_get_interfaces_reply_t *
of_bsn_get_interfaces_reply_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_bsn_get_interfaces_reply_t *obj;

    obj = of_bsn_get_interfaces_reply_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_bsn_get_interfaces_reply.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_bsn_get_interfaces_reply_init(of_bsn_get_interfaces_reply_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_BSN_GET_INTERFACES_REPLY] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_BSN_GET_INTERFACES_REPLY] + of_object_extra_len[version][OF_BSN_GET_INTERFACES_REPLY];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_BSN_GET_INTERFACES_REPLY;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_bsn_get_interfaces_reply object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_bsn_get_interfaces_reply
 */

of_bsn_get_interfaces_reply_t *
of_bsn_get_interfaces_reply_new_from_message_(of_message_t msg)
{
    of_bsn_get_interfaces_reply_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_bsn_get_interfaces_reply_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_bsn_get_interfaces_reply_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_get_interfaces_reply_t *
of_bsn_get_interfaces_reply_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_bsn_get_interfaces_reply_t *obj;

    obj = of_bsn_get_interfaces_reply_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_bsn_get_interfaces_request */

/**
 * \defgroup of_bsn_get_interfaces_request of_bsn_get_interfaces_request
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_bsn_get_interfaces_request_push_wire_values(of_bsn_get_interfaces_request_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_BSN_GET_INTERFACES_REQUEST));
    }

    if (obj->version == OF_VERSION_1_0) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            9);
    }

    if (obj->version == OF_VERSION_1_1) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            9);
    }

    if (obj->version == OF_VERSION_1_2) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            9);
    }

    if (obj->version == OF_VERSION_1_3) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            9);
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_bsn_get_interfaces_request object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_bsn_get_interfaces_request
 */

of_bsn_get_interfaces_request_t *
of_bsn_get_interfaces_request_new_(of_version_t version)
{
    of_bsn_get_interfaces_request_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_BSN_GET_INTERFACES_REQUEST] + of_object_extra_len[version][OF_BSN_GET_INTERFACES_REQUEST];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_bsn_get_interfaces_request_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_bsn_get_interfaces_request_init(obj, version, bytes, 0);

    if (of_bsn_get_interfaces_request_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_get_interfaces_request_t *
of_bsn_get_interfaces_request_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_bsn_get_interfaces_request_t *obj;

    obj = of_bsn_get_interfaces_request_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_bsn_get_interfaces_request.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_bsn_get_interfaces_request_init(of_bsn_get_interfaces_request_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_BSN_GET_INTERFACES_REQUEST] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_BSN_GET_INTERFACES_REQUEST] + of_object_extra_len[version][OF_BSN_GET_INTERFACES_REQUEST];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_BSN_GET_INTERFACES_REQUEST;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_bsn_get_interfaces_request object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_bsn_get_interfaces_request
 */

of_bsn_get_interfaces_request_t *
of_bsn_get_interfaces_request_new_from_message_(of_message_t msg)
{
    of_bsn_get_interfaces_request_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_bsn_get_interfaces_request_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_bsn_get_interfaces_request_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_get_interfaces_request_t *
of_bsn_get_interfaces_request_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_bsn_get_interfaces_request_t *obj;

    obj = of_bsn_get_interfaces_request_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_bsn_get_ip_mask_reply */

/**
 * \defgroup of_bsn_get_ip_mask_reply of_bsn_get_ip_mask_reply
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_bsn_get_ip_mask_reply_push_wire_values(of_bsn_get_ip_mask_reply_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_BSN_GET_IP_MASK_REPLY));
    }

    if (obj->version == OF_VERSION_1_0) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            2);
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_bsn_get_ip_mask_reply object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_bsn_get_ip_mask_reply
 */

of_bsn_get_ip_mask_reply_t *
of_bsn_get_ip_mask_reply_new_(of_version_t version)
{
    of_bsn_get_ip_mask_reply_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_BSN_GET_IP_MASK_REPLY] + of_object_extra_len[version][OF_BSN_GET_IP_MASK_REPLY];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_bsn_get_ip_mask_reply_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_bsn_get_ip_mask_reply_init(obj, version, bytes, 0);

    if (of_bsn_get_ip_mask_reply_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_get_ip_mask_reply_t *
of_bsn_get_ip_mask_reply_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_bsn_get_ip_mask_reply_t *obj;

    obj = of_bsn_get_ip_mask_reply_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_bsn_get_ip_mask_reply.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_bsn_get_ip_mask_reply_init(of_bsn_get_ip_mask_reply_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_BSN_GET_IP_MASK_REPLY] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_BSN_GET_IP_MASK_REPLY] + of_object_extra_len[version][OF_BSN_GET_IP_MASK_REPLY];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_BSN_GET_IP_MASK_REPLY;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_bsn_get_ip_mask_reply object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_bsn_get_ip_mask_reply
 */

of_bsn_get_ip_mask_reply_t *
of_bsn_get_ip_mask_reply_new_from_message_(of_message_t msg)
{
    of_bsn_get_ip_mask_reply_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_bsn_get_ip_mask_reply_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_bsn_get_ip_mask_reply_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_get_ip_mask_reply_t *
of_bsn_get_ip_mask_reply_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_bsn_get_ip_mask_reply_t *obj;

    obj = of_bsn_get_ip_mask_reply_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_bsn_get_ip_mask_request */

/**
 * \defgroup of_bsn_get_ip_mask_request of_bsn_get_ip_mask_request
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_bsn_get_ip_mask_request_push_wire_values(of_bsn_get_ip_mask_request_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_BSN_GET_IP_MASK_REQUEST));
    }

    if (obj->version == OF_VERSION_1_0) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            1);
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_bsn_get_ip_mask_request object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_bsn_get_ip_mask_request
 */

of_bsn_get_ip_mask_request_t *
of_bsn_get_ip_mask_request_new_(of_version_t version)
{
    of_bsn_get_ip_mask_request_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_BSN_GET_IP_MASK_REQUEST] + of_object_extra_len[version][OF_BSN_GET_IP_MASK_REQUEST];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_bsn_get_ip_mask_request_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_bsn_get_ip_mask_request_init(obj, version, bytes, 0);

    if (of_bsn_get_ip_mask_request_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_get_ip_mask_request_t *
of_bsn_get_ip_mask_request_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_bsn_get_ip_mask_request_t *obj;

    obj = of_bsn_get_ip_mask_request_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_bsn_get_ip_mask_request.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_bsn_get_ip_mask_request_init(of_bsn_get_ip_mask_request_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_BSN_GET_IP_MASK_REQUEST] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_BSN_GET_IP_MASK_REQUEST] + of_object_extra_len[version][OF_BSN_GET_IP_MASK_REQUEST];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_BSN_GET_IP_MASK_REQUEST;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_bsn_get_ip_mask_request object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_bsn_get_ip_mask_request
 */

of_bsn_get_ip_mask_request_t *
of_bsn_get_ip_mask_request_new_from_message_(of_message_t msg)
{
    of_bsn_get_ip_mask_request_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_bsn_get_ip_mask_request_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_bsn_get_ip_mask_request_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_get_ip_mask_request_t *
of_bsn_get_ip_mask_request_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_bsn_get_ip_mask_request_t *obj;

    obj = of_bsn_get_ip_mask_request_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_bsn_get_l2_table_reply */

/**
 * \defgroup of_bsn_get_l2_table_reply of_bsn_get_l2_table_reply
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_bsn_get_l2_table_reply_push_wire_values(of_bsn_get_l2_table_reply_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_BSN_GET_L2_TABLE_REPLY));
    }

    if (obj->version == OF_VERSION_1_0) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            14);
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_bsn_get_l2_table_reply object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_bsn_get_l2_table_reply
 */

of_bsn_get_l2_table_reply_t *
of_bsn_get_l2_table_reply_new_(of_version_t version)
{
    of_bsn_get_l2_table_reply_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_BSN_GET_L2_TABLE_REPLY] + of_object_extra_len[version][OF_BSN_GET_L2_TABLE_REPLY];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_bsn_get_l2_table_reply_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_bsn_get_l2_table_reply_init(obj, version, bytes, 0);

    if (of_bsn_get_l2_table_reply_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_get_l2_table_reply_t *
of_bsn_get_l2_table_reply_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_bsn_get_l2_table_reply_t *obj;

    obj = of_bsn_get_l2_table_reply_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_bsn_get_l2_table_reply.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_bsn_get_l2_table_reply_init(of_bsn_get_l2_table_reply_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_BSN_GET_L2_TABLE_REPLY] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_BSN_GET_L2_TABLE_REPLY] + of_object_extra_len[version][OF_BSN_GET_L2_TABLE_REPLY];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_BSN_GET_L2_TABLE_REPLY;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_bsn_get_l2_table_reply object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_bsn_get_l2_table_reply
 */

of_bsn_get_l2_table_reply_t *
of_bsn_get_l2_table_reply_new_from_message_(of_message_t msg)
{
    of_bsn_get_l2_table_reply_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_bsn_get_l2_table_reply_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_bsn_get_l2_table_reply_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_get_l2_table_reply_t *
of_bsn_get_l2_table_reply_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_bsn_get_l2_table_reply_t *obj;

    obj = of_bsn_get_l2_table_reply_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_bsn_get_l2_table_request */

/**
 * \defgroup of_bsn_get_l2_table_request of_bsn_get_l2_table_request
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_bsn_get_l2_table_request_push_wire_values(of_bsn_get_l2_table_request_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_BSN_GET_L2_TABLE_REQUEST));
    }

    if (obj->version == OF_VERSION_1_0) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            13);
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_bsn_get_l2_table_request object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_bsn_get_l2_table_request
 */

of_bsn_get_l2_table_request_t *
of_bsn_get_l2_table_request_new_(of_version_t version)
{
    of_bsn_get_l2_table_request_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_BSN_GET_L2_TABLE_REQUEST] + of_object_extra_len[version][OF_BSN_GET_L2_TABLE_REQUEST];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_bsn_get_l2_table_request_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_bsn_get_l2_table_request_init(obj, version, bytes, 0);

    if (of_bsn_get_l2_table_request_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_get_l2_table_request_t *
of_bsn_get_l2_table_request_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_bsn_get_l2_table_request_t *obj;

    obj = of_bsn_get_l2_table_request_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_bsn_get_l2_table_request.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_bsn_get_l2_table_request_init(of_bsn_get_l2_table_request_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_BSN_GET_L2_TABLE_REQUEST] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_BSN_GET_L2_TABLE_REQUEST] + of_object_extra_len[version][OF_BSN_GET_L2_TABLE_REQUEST];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_BSN_GET_L2_TABLE_REQUEST;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_bsn_get_l2_table_request object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_bsn_get_l2_table_request
 */

of_bsn_get_l2_table_request_t *
of_bsn_get_l2_table_request_new_from_message_(of_message_t msg)
{
    of_bsn_get_l2_table_request_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_bsn_get_l2_table_request_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_bsn_get_l2_table_request_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_get_l2_table_request_t *
of_bsn_get_l2_table_request_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_bsn_get_l2_table_request_t *obj;

    obj = of_bsn_get_l2_table_request_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_bsn_get_mirroring_reply */

/**
 * \defgroup of_bsn_get_mirroring_reply of_bsn_get_mirroring_reply
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_bsn_get_mirroring_reply_push_wire_values(of_bsn_get_mirroring_reply_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_BSN_GET_MIRRORING_REPLY));
    }

    if (obj->version == OF_VERSION_1_0) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            5);
    }

    if (obj->version == OF_VERSION_1_1) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            5);
    }

    if (obj->version == OF_VERSION_1_2) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            5);
    }

    if (obj->version == OF_VERSION_1_3) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            5);
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_bsn_get_mirroring_reply object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_bsn_get_mirroring_reply
 */

of_bsn_get_mirroring_reply_t *
of_bsn_get_mirroring_reply_new_(of_version_t version)
{
    of_bsn_get_mirroring_reply_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_BSN_GET_MIRRORING_REPLY] + of_object_extra_len[version][OF_BSN_GET_MIRRORING_REPLY];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_bsn_get_mirroring_reply_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_bsn_get_mirroring_reply_init(obj, version, bytes, 0);

    if (of_bsn_get_mirroring_reply_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_get_mirroring_reply_t *
of_bsn_get_mirroring_reply_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_bsn_get_mirroring_reply_t *obj;

    obj = of_bsn_get_mirroring_reply_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_bsn_get_mirroring_reply.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_bsn_get_mirroring_reply_init(of_bsn_get_mirroring_reply_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_BSN_GET_MIRRORING_REPLY] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_BSN_GET_MIRRORING_REPLY] + of_object_extra_len[version][OF_BSN_GET_MIRRORING_REPLY];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_BSN_GET_MIRRORING_REPLY;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_bsn_get_mirroring_reply object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_bsn_get_mirroring_reply
 */

of_bsn_get_mirroring_reply_t *
of_bsn_get_mirroring_reply_new_from_message_(of_message_t msg)
{
    of_bsn_get_mirroring_reply_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_bsn_get_mirroring_reply_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_bsn_get_mirroring_reply_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_get_mirroring_reply_t *
of_bsn_get_mirroring_reply_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_bsn_get_mirroring_reply_t *obj;

    obj = of_bsn_get_mirroring_reply_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_bsn_get_mirroring_request */

/**
 * \defgroup of_bsn_get_mirroring_request of_bsn_get_mirroring_request
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_bsn_get_mirroring_request_push_wire_values(of_bsn_get_mirroring_request_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_BSN_GET_MIRRORING_REQUEST));
    }

    if (obj->version == OF_VERSION_1_0) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            4);
    }

    if (obj->version == OF_VERSION_1_1) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            4);
    }

    if (obj->version == OF_VERSION_1_2) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            4);
    }

    if (obj->version == OF_VERSION_1_3) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            4);
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_bsn_get_mirroring_request object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_bsn_get_mirroring_request
 */

of_bsn_get_mirroring_request_t *
of_bsn_get_mirroring_request_new_(of_version_t version)
{
    of_bsn_get_mirroring_request_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_BSN_GET_MIRRORING_REQUEST] + of_object_extra_len[version][OF_BSN_GET_MIRRORING_REQUEST];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_bsn_get_mirroring_request_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_bsn_get_mirroring_request_init(obj, version, bytes, 0);

    if (of_bsn_get_mirroring_request_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_get_mirroring_request_t *
of_bsn_get_mirroring_request_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_bsn_get_mirroring_request_t *obj;

    obj = of_bsn_get_mirroring_request_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_bsn_get_mirroring_request.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_bsn_get_mirroring_request_init(of_bsn_get_mirroring_request_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_BSN_GET_MIRRORING_REQUEST] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_BSN_GET_MIRRORING_REQUEST] + of_object_extra_len[version][OF_BSN_GET_MIRRORING_REQUEST];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_BSN_GET_MIRRORING_REQUEST;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_bsn_get_mirroring_request object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_bsn_get_mirroring_request
 */

of_bsn_get_mirroring_request_t *
of_bsn_get_mirroring_request_new_from_message_(of_message_t msg)
{
    of_bsn_get_mirroring_request_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_bsn_get_mirroring_request_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_bsn_get_mirroring_request_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_get_mirroring_request_t *
of_bsn_get_mirroring_request_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_bsn_get_mirroring_request_t *obj;

    obj = of_bsn_get_mirroring_request_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_bsn_set_ip_mask */

/**
 * \defgroup of_bsn_set_ip_mask of_bsn_set_ip_mask
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_bsn_set_ip_mask_push_wire_values(of_bsn_set_ip_mask_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_BSN_SET_IP_MASK));
    }

    if (obj->version == OF_VERSION_1_0) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            0);
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_bsn_set_ip_mask object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_bsn_set_ip_mask
 */

of_bsn_set_ip_mask_t *
of_bsn_set_ip_mask_new_(of_version_t version)
{
    of_bsn_set_ip_mask_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_BSN_SET_IP_MASK] + of_object_extra_len[version][OF_BSN_SET_IP_MASK];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_bsn_set_ip_mask_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_bsn_set_ip_mask_init(obj, version, bytes, 0);

    if (of_bsn_set_ip_mask_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_set_ip_mask_t *
of_bsn_set_ip_mask_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_bsn_set_ip_mask_t *obj;

    obj = of_bsn_set_ip_mask_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_bsn_set_ip_mask.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_bsn_set_ip_mask_init(of_bsn_set_ip_mask_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_BSN_SET_IP_MASK] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_BSN_SET_IP_MASK] + of_object_extra_len[version][OF_BSN_SET_IP_MASK];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_BSN_SET_IP_MASK;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_bsn_set_ip_mask object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_bsn_set_ip_mask
 */

of_bsn_set_ip_mask_t *
of_bsn_set_ip_mask_new_from_message_(of_message_t msg)
{
    of_bsn_set_ip_mask_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_bsn_set_ip_mask_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_bsn_set_ip_mask_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_set_ip_mask_t *
of_bsn_set_ip_mask_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_bsn_set_ip_mask_t *obj;

    obj = of_bsn_set_ip_mask_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_bsn_set_l2_table_reply */

/**
 * \defgroup of_bsn_set_l2_table_reply of_bsn_set_l2_table_reply
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_bsn_set_l2_table_reply_push_wire_values(of_bsn_set_l2_table_reply_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_BSN_SET_L2_TABLE_REPLY));
    }

    if (obj->version == OF_VERSION_1_0) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            24);
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_bsn_set_l2_table_reply object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_bsn_set_l2_table_reply
 */

of_bsn_set_l2_table_reply_t *
of_bsn_set_l2_table_reply_new_(of_version_t version)
{
    of_bsn_set_l2_table_reply_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_BSN_SET_L2_TABLE_REPLY] + of_object_extra_len[version][OF_BSN_SET_L2_TABLE_REPLY];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_bsn_set_l2_table_reply_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_bsn_set_l2_table_reply_init(obj, version, bytes, 0);

    if (of_bsn_set_l2_table_reply_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_set_l2_table_reply_t *
of_bsn_set_l2_table_reply_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_bsn_set_l2_table_reply_t *obj;

    obj = of_bsn_set_l2_table_reply_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_bsn_set_l2_table_reply.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_bsn_set_l2_table_reply_init(of_bsn_set_l2_table_reply_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_BSN_SET_L2_TABLE_REPLY] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_BSN_SET_L2_TABLE_REPLY] + of_object_extra_len[version][OF_BSN_SET_L2_TABLE_REPLY];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_BSN_SET_L2_TABLE_REPLY;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_bsn_set_l2_table_reply object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_bsn_set_l2_table_reply
 */

of_bsn_set_l2_table_reply_t *
of_bsn_set_l2_table_reply_new_from_message_(of_message_t msg)
{
    of_bsn_set_l2_table_reply_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_bsn_set_l2_table_reply_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_bsn_set_l2_table_reply_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_set_l2_table_reply_t *
of_bsn_set_l2_table_reply_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_bsn_set_l2_table_reply_t *obj;

    obj = of_bsn_set_l2_table_reply_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_bsn_set_l2_table_request */

/**
 * \defgroup of_bsn_set_l2_table_request of_bsn_set_l2_table_request
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_bsn_set_l2_table_request_push_wire_values(of_bsn_set_l2_table_request_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_BSN_SET_L2_TABLE_REQUEST));
    }

    if (obj->version == OF_VERSION_1_0) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            12);
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_bsn_set_l2_table_request object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_bsn_set_l2_table_request
 */

of_bsn_set_l2_table_request_t *
of_bsn_set_l2_table_request_new_(of_version_t version)
{
    of_bsn_set_l2_table_request_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_BSN_SET_L2_TABLE_REQUEST] + of_object_extra_len[version][OF_BSN_SET_L2_TABLE_REQUEST];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_bsn_set_l2_table_request_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_bsn_set_l2_table_request_init(obj, version, bytes, 0);

    if (of_bsn_set_l2_table_request_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_set_l2_table_request_t *
of_bsn_set_l2_table_request_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_bsn_set_l2_table_request_t *obj;

    obj = of_bsn_set_l2_table_request_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_bsn_set_l2_table_request.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_bsn_set_l2_table_request_init(of_bsn_set_l2_table_request_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_BSN_SET_L2_TABLE_REQUEST] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_BSN_SET_L2_TABLE_REQUEST] + of_object_extra_len[version][OF_BSN_SET_L2_TABLE_REQUEST];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_BSN_SET_L2_TABLE_REQUEST;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_bsn_set_l2_table_request object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_bsn_set_l2_table_request
 */

of_bsn_set_l2_table_request_t *
of_bsn_set_l2_table_request_new_from_message_(of_message_t msg)
{
    of_bsn_set_l2_table_request_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_bsn_set_l2_table_request_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_bsn_set_l2_table_request_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_set_l2_table_request_t *
of_bsn_set_l2_table_request_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_bsn_set_l2_table_request_t *obj;

    obj = of_bsn_set_l2_table_request_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_bsn_set_mirroring */

/**
 * \defgroup of_bsn_set_mirroring of_bsn_set_mirroring
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_bsn_set_mirroring_push_wire_values(of_bsn_set_mirroring_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_BSN_SET_MIRRORING));
    }

    if (obj->version == OF_VERSION_1_0) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            3);
    }

    if (obj->version == OF_VERSION_1_1) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            3);
    }

    if (obj->version == OF_VERSION_1_2) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            3);
    }

    if (obj->version == OF_VERSION_1_3) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            3);
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_bsn_set_mirroring object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_bsn_set_mirroring
 */

of_bsn_set_mirroring_t *
of_bsn_set_mirroring_new_(of_version_t version)
{
    of_bsn_set_mirroring_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_BSN_SET_MIRRORING] + of_object_extra_len[version][OF_BSN_SET_MIRRORING];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_bsn_set_mirroring_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_bsn_set_mirroring_init(obj, version, bytes, 0);

    if (of_bsn_set_mirroring_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_set_mirroring_t *
of_bsn_set_mirroring_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_bsn_set_mirroring_t *obj;

    obj = of_bsn_set_mirroring_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_bsn_set_mirroring.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_bsn_set_mirroring_init(of_bsn_set_mirroring_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_BSN_SET_MIRRORING] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_BSN_SET_MIRRORING] + of_object_extra_len[version][OF_BSN_SET_MIRRORING];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_BSN_SET_MIRRORING;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_bsn_set_mirroring object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_bsn_set_mirroring
 */

of_bsn_set_mirroring_t *
of_bsn_set_mirroring_new_from_message_(of_message_t msg)
{
    of_bsn_set_mirroring_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_bsn_set_mirroring_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_bsn_set_mirroring_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_set_mirroring_t *
of_bsn_set_mirroring_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_bsn_set_mirroring_t *obj;

    obj = of_bsn_set_mirroring_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_bsn_set_pktin_suppression_reply */

/**
 * \defgroup of_bsn_set_pktin_suppression_reply of_bsn_set_pktin_suppression_reply
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_bsn_set_pktin_suppression_reply_push_wire_values(of_bsn_set_pktin_suppression_reply_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_BSN_SET_PKTIN_SUPPRESSION_REPLY));
    }

    if (obj->version == OF_VERSION_1_0) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            25);
    }

    if (obj->version == OF_VERSION_1_1) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            25);
    }

    if (obj->version == OF_VERSION_1_2) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            25);
    }

    if (obj->version == OF_VERSION_1_3) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            25);
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_bsn_set_pktin_suppression_reply object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_bsn_set_pktin_suppression_reply
 */

of_bsn_set_pktin_suppression_reply_t *
of_bsn_set_pktin_suppression_reply_new_(of_version_t version)
{
    of_bsn_set_pktin_suppression_reply_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_BSN_SET_PKTIN_SUPPRESSION_REPLY] + of_object_extra_len[version][OF_BSN_SET_PKTIN_SUPPRESSION_REPLY];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_bsn_set_pktin_suppression_reply_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_bsn_set_pktin_suppression_reply_init(obj, version, bytes, 0);

    if (of_bsn_set_pktin_suppression_reply_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_set_pktin_suppression_reply_t *
of_bsn_set_pktin_suppression_reply_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_bsn_set_pktin_suppression_reply_t *obj;

    obj = of_bsn_set_pktin_suppression_reply_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_bsn_set_pktin_suppression_reply.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_bsn_set_pktin_suppression_reply_init(of_bsn_set_pktin_suppression_reply_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_BSN_SET_PKTIN_SUPPRESSION_REPLY] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_BSN_SET_PKTIN_SUPPRESSION_REPLY] + of_object_extra_len[version][OF_BSN_SET_PKTIN_SUPPRESSION_REPLY];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_BSN_SET_PKTIN_SUPPRESSION_REPLY;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_bsn_set_pktin_suppression_reply object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_bsn_set_pktin_suppression_reply
 */

of_bsn_set_pktin_suppression_reply_t *
of_bsn_set_pktin_suppression_reply_new_from_message_(of_message_t msg)
{
    of_bsn_set_pktin_suppression_reply_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_bsn_set_pktin_suppression_reply_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_bsn_set_pktin_suppression_reply_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_set_pktin_suppression_reply_t *
of_bsn_set_pktin_suppression_reply_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_bsn_set_pktin_suppression_reply_t *obj;

    obj = of_bsn_set_pktin_suppression_reply_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_bsn_set_pktin_suppression_request */

/**
 * \defgroup of_bsn_set_pktin_suppression_request of_bsn_set_pktin_suppression_request
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_bsn_set_pktin_suppression_request_push_wire_values(of_bsn_set_pktin_suppression_request_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_BSN_SET_PKTIN_SUPPRESSION_REQUEST));
    }

    if (obj->version == OF_VERSION_1_0) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            11);
    }

    if (obj->version == OF_VERSION_1_1) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            11);
    }

    if (obj->version == OF_VERSION_1_2) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            11);
    }

    if (obj->version == OF_VERSION_1_3) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            11);
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_bsn_set_pktin_suppression_request object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_bsn_set_pktin_suppression_request
 */

of_bsn_set_pktin_suppression_request_t *
of_bsn_set_pktin_suppression_request_new_(of_version_t version)
{
    of_bsn_set_pktin_suppression_request_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_BSN_SET_PKTIN_SUPPRESSION_REQUEST] + of_object_extra_len[version][OF_BSN_SET_PKTIN_SUPPRESSION_REQUEST];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_bsn_set_pktin_suppression_request_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_bsn_set_pktin_suppression_request_init(obj, version, bytes, 0);

    if (of_bsn_set_pktin_suppression_request_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_set_pktin_suppression_request_t *
of_bsn_set_pktin_suppression_request_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_bsn_set_pktin_suppression_request_t *obj;

    obj = of_bsn_set_pktin_suppression_request_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_bsn_set_pktin_suppression_request.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_bsn_set_pktin_suppression_request_init(of_bsn_set_pktin_suppression_request_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_BSN_SET_PKTIN_SUPPRESSION_REQUEST] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_BSN_SET_PKTIN_SUPPRESSION_REQUEST] + of_object_extra_len[version][OF_BSN_SET_PKTIN_SUPPRESSION_REQUEST];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_BSN_SET_PKTIN_SUPPRESSION_REQUEST;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_bsn_set_pktin_suppression_request object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_bsn_set_pktin_suppression_request
 */

of_bsn_set_pktin_suppression_request_t *
of_bsn_set_pktin_suppression_request_new_from_message_(of_message_t msg)
{
    of_bsn_set_pktin_suppression_request_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_bsn_set_pktin_suppression_request_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_bsn_set_pktin_suppression_request_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_set_pktin_suppression_request_t *
of_bsn_set_pktin_suppression_request_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_bsn_set_pktin_suppression_request_t *obj;

    obj = of_bsn_set_pktin_suppression_request_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_bsn_shell_command */

/**
 * \defgroup of_bsn_shell_command of_bsn_shell_command
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_bsn_shell_command_push_wire_values(of_bsn_shell_command_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_BSN_SHELL_COMMAND));
    }

    if (obj->version == OF_VERSION_1_0) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            6);
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_bsn_shell_command object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_bsn_shell_command
 */

of_bsn_shell_command_t *
of_bsn_shell_command_new_(of_version_t version)
{
    of_bsn_shell_command_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_BSN_SHELL_COMMAND] + of_object_extra_len[version][OF_BSN_SHELL_COMMAND];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_bsn_shell_command_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_bsn_shell_command_init(obj, version, bytes, 0);

    if (of_bsn_shell_command_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_shell_command_t *
of_bsn_shell_command_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_bsn_shell_command_t *obj;

    obj = of_bsn_shell_command_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_bsn_shell_command.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_bsn_shell_command_init(of_bsn_shell_command_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_BSN_SHELL_COMMAND] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_BSN_SHELL_COMMAND] + of_object_extra_len[version][OF_BSN_SHELL_COMMAND];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_BSN_SHELL_COMMAND;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_bsn_shell_command object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_bsn_shell_command
 */

of_bsn_shell_command_t *
of_bsn_shell_command_new_from_message_(of_message_t msg)
{
    of_bsn_shell_command_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_bsn_shell_command_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_bsn_shell_command_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_shell_command_t *
of_bsn_shell_command_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_bsn_shell_command_t *obj;

    obj = of_bsn_shell_command_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_bsn_shell_output */

/**
 * \defgroup of_bsn_shell_output of_bsn_shell_output
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_bsn_shell_output_push_wire_values(of_bsn_shell_output_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_BSN_SHELL_OUTPUT));
    }

    if (obj->version == OF_VERSION_1_0) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            7);
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_bsn_shell_output object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_bsn_shell_output
 */

of_bsn_shell_output_t *
of_bsn_shell_output_new_(of_version_t version)
{
    of_bsn_shell_output_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_BSN_SHELL_OUTPUT] + of_object_extra_len[version][OF_BSN_SHELL_OUTPUT];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_bsn_shell_output_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_bsn_shell_output_init(obj, version, bytes, 0);

    if (of_bsn_shell_output_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_shell_output_t *
of_bsn_shell_output_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_bsn_shell_output_t *obj;

    obj = of_bsn_shell_output_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_bsn_shell_output.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_bsn_shell_output_init(of_bsn_shell_output_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_BSN_SHELL_OUTPUT] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_BSN_SHELL_OUTPUT] + of_object_extra_len[version][OF_BSN_SHELL_OUTPUT];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_BSN_SHELL_OUTPUT;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_bsn_shell_output object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_bsn_shell_output
 */

of_bsn_shell_output_t *
of_bsn_shell_output_new_from_message_(of_message_t msg)
{
    of_bsn_shell_output_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_bsn_shell_output_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_bsn_shell_output_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_shell_output_t *
of_bsn_shell_output_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_bsn_shell_output_t *obj;

    obj = of_bsn_shell_output_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_bsn_shell_status */

/**
 * \defgroup of_bsn_shell_status of_bsn_shell_status
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_bsn_shell_status_push_wire_values(of_bsn_shell_status_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_BSN_SHELL_STATUS));
    }

    if (obj->version == OF_VERSION_1_0) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            8);
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_bsn_shell_status object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_bsn_shell_status
 */

of_bsn_shell_status_t *
of_bsn_shell_status_new_(of_version_t version)
{
    of_bsn_shell_status_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_BSN_SHELL_STATUS] + of_object_extra_len[version][OF_BSN_SHELL_STATUS];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_bsn_shell_status_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_bsn_shell_status_init(obj, version, bytes, 0);

    if (of_bsn_shell_status_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_shell_status_t *
of_bsn_shell_status_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_bsn_shell_status_t *obj;

    obj = of_bsn_shell_status_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_bsn_shell_status.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_bsn_shell_status_init(of_bsn_shell_status_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_BSN_SHELL_STATUS] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_BSN_SHELL_STATUS] + of_object_extra_len[version][OF_BSN_SHELL_STATUS];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_BSN_SHELL_STATUS;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_bsn_shell_status object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_bsn_shell_status
 */

of_bsn_shell_status_t *
of_bsn_shell_status_new_from_message_(of_message_t msg)
{
    of_bsn_shell_status_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_bsn_shell_status_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_bsn_shell_status_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_shell_status_t *
of_bsn_shell_status_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_bsn_shell_status_t *obj;

    obj = of_bsn_shell_status_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_bsn_virtual_port_create_reply */

/**
 * \defgroup of_bsn_virtual_port_create_reply of_bsn_virtual_port_create_reply
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_bsn_virtual_port_create_reply_push_wire_values(of_bsn_virtual_port_create_reply_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_BSN_VIRTUAL_PORT_CREATE_REPLY));
    }

    if (obj->version == OF_VERSION_1_0) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            16);
    }

    if (obj->version == OF_VERSION_1_1) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            16);
    }

    if (obj->version == OF_VERSION_1_2) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            16);
    }

    if (obj->version == OF_VERSION_1_3) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            16);
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_bsn_virtual_port_create_reply object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_bsn_virtual_port_create_reply
 */

of_bsn_virtual_port_create_reply_t *
of_bsn_virtual_port_create_reply_new_(of_version_t version)
{
    of_bsn_virtual_port_create_reply_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_BSN_VIRTUAL_PORT_CREATE_REPLY] + of_object_extra_len[version][OF_BSN_VIRTUAL_PORT_CREATE_REPLY];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_bsn_virtual_port_create_reply_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_bsn_virtual_port_create_reply_init(obj, version, bytes, 0);

    if (of_bsn_virtual_port_create_reply_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_virtual_port_create_reply_t *
of_bsn_virtual_port_create_reply_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_bsn_virtual_port_create_reply_t *obj;

    obj = of_bsn_virtual_port_create_reply_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_bsn_virtual_port_create_reply.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_bsn_virtual_port_create_reply_init(of_bsn_virtual_port_create_reply_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_BSN_VIRTUAL_PORT_CREATE_REPLY] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_BSN_VIRTUAL_PORT_CREATE_REPLY] + of_object_extra_len[version][OF_BSN_VIRTUAL_PORT_CREATE_REPLY];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_BSN_VIRTUAL_PORT_CREATE_REPLY;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_bsn_virtual_port_create_reply object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_bsn_virtual_port_create_reply
 */

of_bsn_virtual_port_create_reply_t *
of_bsn_virtual_port_create_reply_new_from_message_(of_message_t msg)
{
    of_bsn_virtual_port_create_reply_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_bsn_virtual_port_create_reply_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_bsn_virtual_port_create_reply_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_virtual_port_create_reply_t *
of_bsn_virtual_port_create_reply_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_bsn_virtual_port_create_reply_t *obj;

    obj = of_bsn_virtual_port_create_reply_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_bsn_virtual_port_create_request */

/**
 * \defgroup of_bsn_virtual_port_create_request of_bsn_virtual_port_create_request
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_bsn_virtual_port_create_request_push_wire_values(of_bsn_virtual_port_create_request_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_BSN_VIRTUAL_PORT_CREATE_REQUEST));
    }

    if (obj->version == OF_VERSION_1_0) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            15);
    }

    if (obj->version == OF_VERSION_1_1) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            15);
    }

    if (obj->version == OF_VERSION_1_2) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            15);
    }

    if (obj->version == OF_VERSION_1_3) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            15);
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_bsn_virtual_port_create_request object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_bsn_virtual_port_create_request
 */

of_bsn_virtual_port_create_request_t *
of_bsn_virtual_port_create_request_new_(of_version_t version)
{
    of_bsn_virtual_port_create_request_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_BSN_VIRTUAL_PORT_CREATE_REQUEST] + of_object_extra_len[version][OF_BSN_VIRTUAL_PORT_CREATE_REQUEST];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_bsn_virtual_port_create_request_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_bsn_virtual_port_create_request_init(obj, version, bytes, 0);

    if (of_bsn_virtual_port_create_request_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_virtual_port_create_request_t *
of_bsn_virtual_port_create_request_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_bsn_virtual_port_create_request_t *obj;

    obj = of_bsn_virtual_port_create_request_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_bsn_virtual_port_create_request.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_bsn_virtual_port_create_request_init(of_bsn_virtual_port_create_request_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_BSN_VIRTUAL_PORT_CREATE_REQUEST] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_BSN_VIRTUAL_PORT_CREATE_REQUEST] + of_object_extra_len[version][OF_BSN_VIRTUAL_PORT_CREATE_REQUEST];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_BSN_VIRTUAL_PORT_CREATE_REQUEST;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_bsn_virtual_port_create_request object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_bsn_virtual_port_create_request
 */

of_bsn_virtual_port_create_request_t *
of_bsn_virtual_port_create_request_new_from_message_(of_message_t msg)
{
    of_bsn_virtual_port_create_request_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_bsn_virtual_port_create_request_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_bsn_virtual_port_create_request_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_virtual_port_create_request_t *
of_bsn_virtual_port_create_request_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_bsn_virtual_port_create_request_t *obj;

    obj = of_bsn_virtual_port_create_request_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_bsn_virtual_port_remove_reply */

/**
 * \defgroup of_bsn_virtual_port_remove_reply of_bsn_virtual_port_remove_reply
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_bsn_virtual_port_remove_reply_push_wire_values(of_bsn_virtual_port_remove_reply_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_BSN_VIRTUAL_PORT_REMOVE_REPLY));
    }

    if (obj->version == OF_VERSION_1_0) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            26);
    }

    if (obj->version == OF_VERSION_1_1) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            26);
    }

    if (obj->version == OF_VERSION_1_2) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            26);
    }

    if (obj->version == OF_VERSION_1_3) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            26);
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_bsn_virtual_port_remove_reply object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_bsn_virtual_port_remove_reply
 */

of_bsn_virtual_port_remove_reply_t *
of_bsn_virtual_port_remove_reply_new_(of_version_t version)
{
    of_bsn_virtual_port_remove_reply_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_BSN_VIRTUAL_PORT_REMOVE_REPLY] + of_object_extra_len[version][OF_BSN_VIRTUAL_PORT_REMOVE_REPLY];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_bsn_virtual_port_remove_reply_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_bsn_virtual_port_remove_reply_init(obj, version, bytes, 0);

    if (of_bsn_virtual_port_remove_reply_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_virtual_port_remove_reply_t *
of_bsn_virtual_port_remove_reply_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_bsn_virtual_port_remove_reply_t *obj;

    obj = of_bsn_virtual_port_remove_reply_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_bsn_virtual_port_remove_reply.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_bsn_virtual_port_remove_reply_init(of_bsn_virtual_port_remove_reply_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_BSN_VIRTUAL_PORT_REMOVE_REPLY] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_BSN_VIRTUAL_PORT_REMOVE_REPLY] + of_object_extra_len[version][OF_BSN_VIRTUAL_PORT_REMOVE_REPLY];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_BSN_VIRTUAL_PORT_REMOVE_REPLY;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_bsn_virtual_port_remove_reply object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_bsn_virtual_port_remove_reply
 */

of_bsn_virtual_port_remove_reply_t *
of_bsn_virtual_port_remove_reply_new_from_message_(of_message_t msg)
{
    of_bsn_virtual_port_remove_reply_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_bsn_virtual_port_remove_reply_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_bsn_virtual_port_remove_reply_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_virtual_port_remove_reply_t *
of_bsn_virtual_port_remove_reply_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_bsn_virtual_port_remove_reply_t *obj;

    obj = of_bsn_virtual_port_remove_reply_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_bsn_virtual_port_remove_request */

/**
 * \defgroup of_bsn_virtual_port_remove_request of_bsn_virtual_port_remove_request
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_bsn_virtual_port_remove_request_push_wire_values(of_bsn_virtual_port_remove_request_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_BSN_VIRTUAL_PORT_REMOVE_REQUEST));
    }

    if (obj->version == OF_VERSION_1_0) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            17);
    }

    if (obj->version == OF_VERSION_1_1) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            17);
    }

    if (obj->version == OF_VERSION_1_2) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            17);
    }

    if (obj->version == OF_VERSION_1_3) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_BSN);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            17);
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_bsn_virtual_port_remove_request object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_bsn_virtual_port_remove_request
 */

of_bsn_virtual_port_remove_request_t *
of_bsn_virtual_port_remove_request_new_(of_version_t version)
{
    of_bsn_virtual_port_remove_request_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_BSN_VIRTUAL_PORT_REMOVE_REQUEST] + of_object_extra_len[version][OF_BSN_VIRTUAL_PORT_REMOVE_REQUEST];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_bsn_virtual_port_remove_request_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_bsn_virtual_port_remove_request_init(obj, version, bytes, 0);

    if (of_bsn_virtual_port_remove_request_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_virtual_port_remove_request_t *
of_bsn_virtual_port_remove_request_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_bsn_virtual_port_remove_request_t *obj;

    obj = of_bsn_virtual_port_remove_request_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_bsn_virtual_port_remove_request.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_bsn_virtual_port_remove_request_init(of_bsn_virtual_port_remove_request_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_BSN_VIRTUAL_PORT_REMOVE_REQUEST] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_BSN_VIRTUAL_PORT_REMOVE_REQUEST] + of_object_extra_len[version][OF_BSN_VIRTUAL_PORT_REMOVE_REQUEST];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_BSN_VIRTUAL_PORT_REMOVE_REQUEST;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_bsn_virtual_port_remove_request object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_bsn_virtual_port_remove_request
 */

of_bsn_virtual_port_remove_request_t *
of_bsn_virtual_port_remove_request_new_from_message_(of_message_t msg)
{
    of_bsn_virtual_port_remove_request_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_bsn_virtual_port_remove_request_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_bsn_virtual_port_remove_request_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_virtual_port_remove_request_t *
of_bsn_virtual_port_remove_request_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_bsn_virtual_port_remove_request_t *obj;

    obj = of_bsn_virtual_port_remove_request_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_desc_stats_reply */

/**
 * \defgroup of_desc_stats_reply of_desc_stats_reply
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_desc_stats_reply_push_wire_values(of_desc_stats_reply_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_DESC_STATS_REPLY));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_desc_stats_reply object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_desc_stats_reply
 */

of_desc_stats_reply_t *
of_desc_stats_reply_new_(of_version_t version)
{
    of_desc_stats_reply_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_DESC_STATS_REPLY] + of_object_extra_len[version][OF_DESC_STATS_REPLY];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_desc_stats_reply_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_desc_stats_reply_init(obj, version, bytes, 0);

    if (of_desc_stats_reply_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_desc_stats_reply_t *
of_desc_stats_reply_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_desc_stats_reply_t *obj;

    obj = of_desc_stats_reply_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_desc_stats_reply.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_desc_stats_reply_init(of_desc_stats_reply_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_DESC_STATS_REPLY] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_DESC_STATS_REPLY] + of_object_extra_len[version][OF_DESC_STATS_REPLY];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_DESC_STATS_REPLY;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_desc_stats_reply object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_desc_stats_reply
 */

of_desc_stats_reply_t *
of_desc_stats_reply_new_from_message_(of_message_t msg)
{
    of_desc_stats_reply_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_desc_stats_reply_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_desc_stats_reply_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_desc_stats_reply_t *
of_desc_stats_reply_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_desc_stats_reply_t *obj;

    obj = of_desc_stats_reply_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_desc_stats_request */

/**
 * \defgroup of_desc_stats_request of_desc_stats_request
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_desc_stats_request_push_wire_values(of_desc_stats_request_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_DESC_STATS_REQUEST));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_desc_stats_request object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_desc_stats_request
 */

of_desc_stats_request_t *
of_desc_stats_request_new_(of_version_t version)
{
    of_desc_stats_request_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_DESC_STATS_REQUEST] + of_object_extra_len[version][OF_DESC_STATS_REQUEST];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_desc_stats_request_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_desc_stats_request_init(obj, version, bytes, 0);

    if (of_desc_stats_request_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_desc_stats_request_t *
of_desc_stats_request_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_desc_stats_request_t *obj;

    obj = of_desc_stats_request_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_desc_stats_request.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_desc_stats_request_init(of_desc_stats_request_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_DESC_STATS_REQUEST] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_DESC_STATS_REQUEST] + of_object_extra_len[version][OF_DESC_STATS_REQUEST];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_DESC_STATS_REQUEST;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_desc_stats_request object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_desc_stats_request
 */

of_desc_stats_request_t *
of_desc_stats_request_new_from_message_(of_message_t msg)
{
    of_desc_stats_request_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_desc_stats_request_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_desc_stats_request_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_desc_stats_request_t *
of_desc_stats_request_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_desc_stats_request_t *obj;

    obj = of_desc_stats_request_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_echo_reply */

/**
 * \defgroup of_echo_reply of_echo_reply
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_echo_reply_push_wire_values(of_echo_reply_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_ECHO_REPLY));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_echo_reply object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_echo_reply
 */

of_echo_reply_t *
of_echo_reply_new_(of_version_t version)
{
    of_echo_reply_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ECHO_REPLY] + of_object_extra_len[version][OF_ECHO_REPLY];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_echo_reply_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_echo_reply_init(obj, version, bytes, 0);

    if (of_echo_reply_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_echo_reply_t *
of_echo_reply_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_echo_reply_t *obj;

    obj = of_echo_reply_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_echo_reply.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_echo_reply_init(of_echo_reply_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ECHO_REPLY] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ECHO_REPLY] + of_object_extra_len[version][OF_ECHO_REPLY];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ECHO_REPLY;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_echo_reply object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_echo_reply
 */

of_echo_reply_t *
of_echo_reply_new_from_message_(of_message_t msg)
{
    of_echo_reply_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_echo_reply_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_echo_reply_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_echo_reply_t *
of_echo_reply_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_echo_reply_t *obj;

    obj = of_echo_reply_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_echo_request */

/**
 * \defgroup of_echo_request of_echo_request
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_echo_request_push_wire_values(of_echo_request_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_ECHO_REQUEST));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_echo_request object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_echo_request
 */

of_echo_request_t *
of_echo_request_new_(of_version_t version)
{
    of_echo_request_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ECHO_REQUEST] + of_object_extra_len[version][OF_ECHO_REQUEST];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_echo_request_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_echo_request_init(obj, version, bytes, 0);

    if (of_echo_request_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_echo_request_t *
of_echo_request_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_echo_request_t *obj;

    obj = of_echo_request_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_echo_request.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_echo_request_init(of_echo_request_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ECHO_REQUEST] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ECHO_REQUEST] + of_object_extra_len[version][OF_ECHO_REQUEST];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ECHO_REQUEST;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_echo_request object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_echo_request
 */

of_echo_request_t *
of_echo_request_new_from_message_(of_message_t msg)
{
    of_echo_request_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_echo_request_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_echo_request_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_echo_request_t *
of_echo_request_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_echo_request_t *obj;

    obj = of_echo_request_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_error_msg */

/**
 * \defgroup of_error_msg of_error_msg
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_error_msg_push_wire_values(of_error_msg_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_ERROR_MSG));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_error_msg object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_error_msg
 */

of_error_msg_t *
of_error_msg_new_(of_version_t version)
{
    of_error_msg_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ERROR_MSG] + of_object_extra_len[version][OF_ERROR_MSG];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_error_msg_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_error_msg_init(obj, version, bytes, 0);

    if (of_error_msg_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_error_msg_t *
of_error_msg_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_error_msg_t *obj;

    obj = of_error_msg_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_error_msg.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_error_msg_init(of_error_msg_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ERROR_MSG] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ERROR_MSG] + of_object_extra_len[version][OF_ERROR_MSG];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ERROR_MSG;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_error_msg object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_error_msg
 */

of_error_msg_t *
of_error_msg_new_from_message_(of_message_t msg)
{
    of_error_msg_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_error_msg_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_error_msg_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_error_msg_t *
of_error_msg_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_error_msg_t *obj;

    obj = of_error_msg_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_experimenter */

/**
 * \defgroup of_experimenter of_experimenter
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_experimenter_push_wire_values(of_experimenter_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_EXPERIMENTER));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_experimenter object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_experimenter
 */

of_experimenter_t *
of_experimenter_new_(of_version_t version)
{
    of_experimenter_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_EXPERIMENTER] + of_object_extra_len[version][OF_EXPERIMENTER];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_experimenter_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_experimenter_init(obj, version, bytes, 0);

    if (of_experimenter_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_experimenter_t *
of_experimenter_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_experimenter_t *obj;

    obj = of_experimenter_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_experimenter.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_experimenter_init(of_experimenter_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_EXPERIMENTER] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_EXPERIMENTER] + of_object_extra_len[version][OF_EXPERIMENTER];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_EXPERIMENTER;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_experimenter object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_experimenter
 */

of_experimenter_t *
of_experimenter_new_from_message_(of_message_t msg)
{
    of_experimenter_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_experimenter_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_experimenter_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_experimenter_t *
of_experimenter_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_experimenter_t *obj;

    obj = of_experimenter_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_experimenter_stats_reply */

/**
 * \defgroup of_experimenter_stats_reply of_experimenter_stats_reply
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_experimenter_stats_reply_push_wire_values(of_experimenter_stats_reply_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_EXPERIMENTER_STATS_REPLY));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_experimenter_stats_reply object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_experimenter_stats_reply
 */

of_experimenter_stats_reply_t *
of_experimenter_stats_reply_new_(of_version_t version)
{
    of_experimenter_stats_reply_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_EXPERIMENTER_STATS_REPLY] + of_object_extra_len[version][OF_EXPERIMENTER_STATS_REPLY];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_experimenter_stats_reply_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_experimenter_stats_reply_init(obj, version, bytes, 0);

    if (of_experimenter_stats_reply_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_experimenter_stats_reply_t *
of_experimenter_stats_reply_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_experimenter_stats_reply_t *obj;

    obj = of_experimenter_stats_reply_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_experimenter_stats_reply.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_experimenter_stats_reply_init(of_experimenter_stats_reply_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_EXPERIMENTER_STATS_REPLY] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_EXPERIMENTER_STATS_REPLY] + of_object_extra_len[version][OF_EXPERIMENTER_STATS_REPLY];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_EXPERIMENTER_STATS_REPLY;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_experimenter_stats_reply object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_experimenter_stats_reply
 */

of_experimenter_stats_reply_t *
of_experimenter_stats_reply_new_from_message_(of_message_t msg)
{
    of_experimenter_stats_reply_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_experimenter_stats_reply_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_experimenter_stats_reply_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_experimenter_stats_reply_t *
of_experimenter_stats_reply_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_experimenter_stats_reply_t *obj;

    obj = of_experimenter_stats_reply_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_experimenter_stats_request */

/**
 * \defgroup of_experimenter_stats_request of_experimenter_stats_request
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_experimenter_stats_request_push_wire_values(of_experimenter_stats_request_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_EXPERIMENTER_STATS_REQUEST));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_experimenter_stats_request object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_experimenter_stats_request
 */

of_experimenter_stats_request_t *
of_experimenter_stats_request_new_(of_version_t version)
{
    of_experimenter_stats_request_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_EXPERIMENTER_STATS_REQUEST] + of_object_extra_len[version][OF_EXPERIMENTER_STATS_REQUEST];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_experimenter_stats_request_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_experimenter_stats_request_init(obj, version, bytes, 0);

    if (of_experimenter_stats_request_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_experimenter_stats_request_t *
of_experimenter_stats_request_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_experimenter_stats_request_t *obj;

    obj = of_experimenter_stats_request_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_experimenter_stats_request.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_experimenter_stats_request_init(of_experimenter_stats_request_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_EXPERIMENTER_STATS_REQUEST] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_EXPERIMENTER_STATS_REQUEST] + of_object_extra_len[version][OF_EXPERIMENTER_STATS_REQUEST];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_EXPERIMENTER_STATS_REQUEST;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_experimenter_stats_request object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_experimenter_stats_request
 */

of_experimenter_stats_request_t *
of_experimenter_stats_request_new_from_message_(of_message_t msg)
{
    of_experimenter_stats_request_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_experimenter_stats_request_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_experimenter_stats_request_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_experimenter_stats_request_t *
of_experimenter_stats_request_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_experimenter_stats_request_t *obj;

    obj = of_experimenter_stats_request_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_features_reply */

/**
 * \defgroup of_features_reply of_features_reply
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_features_reply_push_wire_values(of_features_reply_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_FEATURES_REPLY));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_features_reply object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_features_reply
 */

of_features_reply_t *
of_features_reply_new_(of_version_t version)
{
    of_features_reply_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_FEATURES_REPLY] + of_object_extra_len[version][OF_FEATURES_REPLY];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_features_reply_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_features_reply_init(obj, version, bytes, 0);

    if (of_features_reply_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_features_reply_t *
of_features_reply_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_features_reply_t *obj;

    obj = of_features_reply_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_features_reply.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_features_reply_init(of_features_reply_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_FEATURES_REPLY] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_FEATURES_REPLY] + of_object_extra_len[version][OF_FEATURES_REPLY];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_FEATURES_REPLY;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_features_reply object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_features_reply
 */

of_features_reply_t *
of_features_reply_new_from_message_(of_message_t msg)
{
    of_features_reply_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_features_reply_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_features_reply_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_features_reply_t *
of_features_reply_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_features_reply_t *obj;

    obj = of_features_reply_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_features_request */

/**
 * \defgroup of_features_request of_features_request
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_features_request_push_wire_values(of_features_request_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_FEATURES_REQUEST));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_features_request object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_features_request
 */

of_features_request_t *
of_features_request_new_(of_version_t version)
{
    of_features_request_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_FEATURES_REQUEST] + of_object_extra_len[version][OF_FEATURES_REQUEST];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_features_request_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_features_request_init(obj, version, bytes, 0);

    if (of_features_request_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_features_request_t *
of_features_request_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_features_request_t *obj;

    obj = of_features_request_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_features_request.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_features_request_init(of_features_request_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_FEATURES_REQUEST] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_FEATURES_REQUEST] + of_object_extra_len[version][OF_FEATURES_REQUEST];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_FEATURES_REQUEST;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_features_request object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_features_request
 */

of_features_request_t *
of_features_request_new_from_message_(of_message_t msg)
{
    of_features_request_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_features_request_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_features_request_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_features_request_t *
of_features_request_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_features_request_t *obj;

    obj = of_features_request_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_flow_add */

/**
 * \defgroup of_flow_add of_flow_add
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_flow_add_push_wire_values(of_flow_add_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_FLOW_ADD));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_flow_add object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_flow_add
 */

of_flow_add_t *
of_flow_add_new_(of_version_t version)
{
    of_flow_add_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_FLOW_ADD] + of_object_extra_len[version][OF_FLOW_ADD];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_flow_add_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_flow_add_init(obj, version, bytes, 0);

    if (of_flow_add_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    /* Initialize match TLV for 1.2 */
    /* FIXME: Check 1.3 below */
    if ((version == OF_VERSION_1_2) || (version == OF_VERSION_1_3)) {
        of_object_u16_set((of_object_t *)obj, 48 + 2, 4);
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_flow_add_t *
of_flow_add_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_flow_add_t *obj;

    obj = of_flow_add_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_flow_add.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_flow_add_init(of_flow_add_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_FLOW_ADD] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_FLOW_ADD] + of_object_extra_len[version][OF_FLOW_ADD];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_FLOW_ADD;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_flow_add object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_flow_add
 */

of_flow_add_t *
of_flow_add_new_from_message_(of_message_t msg)
{
    of_flow_add_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_flow_add_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_flow_add_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_flow_add_t *
of_flow_add_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_flow_add_t *obj;

    obj = of_flow_add_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_flow_delete */

/**
 * \defgroup of_flow_delete of_flow_delete
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_flow_delete_push_wire_values(of_flow_delete_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_FLOW_DELETE));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_flow_delete object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_flow_delete
 */

of_flow_delete_t *
of_flow_delete_new_(of_version_t version)
{
    of_flow_delete_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_FLOW_DELETE] + of_object_extra_len[version][OF_FLOW_DELETE];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_flow_delete_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_flow_delete_init(obj, version, bytes, 0);

    if (of_flow_delete_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    /* Initialize match TLV for 1.2 */
    /* FIXME: Check 1.3 below */
    if ((version == OF_VERSION_1_2) || (version == OF_VERSION_1_3)) {
        of_object_u16_set((of_object_t *)obj, 48 + 2, 4);
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_flow_delete_t *
of_flow_delete_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_flow_delete_t *obj;

    obj = of_flow_delete_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_flow_delete.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_flow_delete_init(of_flow_delete_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_FLOW_DELETE] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_FLOW_DELETE] + of_object_extra_len[version][OF_FLOW_DELETE];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_FLOW_DELETE;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_flow_delete object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_flow_delete
 */

of_flow_delete_t *
of_flow_delete_new_from_message_(of_message_t msg)
{
    of_flow_delete_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_flow_delete_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_flow_delete_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_flow_delete_t *
of_flow_delete_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_flow_delete_t *obj;

    obj = of_flow_delete_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_flow_delete_strict */

/**
 * \defgroup of_flow_delete_strict of_flow_delete_strict
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_flow_delete_strict_push_wire_values(of_flow_delete_strict_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_FLOW_DELETE_STRICT));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_flow_delete_strict object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_flow_delete_strict
 */

of_flow_delete_strict_t *
of_flow_delete_strict_new_(of_version_t version)
{
    of_flow_delete_strict_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_FLOW_DELETE_STRICT] + of_object_extra_len[version][OF_FLOW_DELETE_STRICT];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_flow_delete_strict_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_flow_delete_strict_init(obj, version, bytes, 0);

    if (of_flow_delete_strict_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    /* Initialize match TLV for 1.2 */
    /* FIXME: Check 1.3 below */
    if ((version == OF_VERSION_1_2) || (version == OF_VERSION_1_3)) {
        of_object_u16_set((of_object_t *)obj, 48 + 2, 4);
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_flow_delete_strict_t *
of_flow_delete_strict_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_flow_delete_strict_t *obj;

    obj = of_flow_delete_strict_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_flow_delete_strict.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_flow_delete_strict_init(of_flow_delete_strict_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_FLOW_DELETE_STRICT] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_FLOW_DELETE_STRICT] + of_object_extra_len[version][OF_FLOW_DELETE_STRICT];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_FLOW_DELETE_STRICT;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_flow_delete_strict object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_flow_delete_strict
 */

of_flow_delete_strict_t *
of_flow_delete_strict_new_from_message_(of_message_t msg)
{
    of_flow_delete_strict_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_flow_delete_strict_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_flow_delete_strict_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_flow_delete_strict_t *
of_flow_delete_strict_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_flow_delete_strict_t *obj;

    obj = of_flow_delete_strict_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_flow_modify */

/**
 * \defgroup of_flow_modify of_flow_modify
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_flow_modify_push_wire_values(of_flow_modify_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_FLOW_MODIFY));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_flow_modify object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_flow_modify
 */

of_flow_modify_t *
of_flow_modify_new_(of_version_t version)
{
    of_flow_modify_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_FLOW_MODIFY] + of_object_extra_len[version][OF_FLOW_MODIFY];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_flow_modify_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_flow_modify_init(obj, version, bytes, 0);

    if (of_flow_modify_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    /* Initialize match TLV for 1.2 */
    /* FIXME: Check 1.3 below */
    if ((version == OF_VERSION_1_2) || (version == OF_VERSION_1_3)) {
        of_object_u16_set((of_object_t *)obj, 48 + 2, 4);
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_flow_modify_t *
of_flow_modify_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_flow_modify_t *obj;

    obj = of_flow_modify_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_flow_modify.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_flow_modify_init(of_flow_modify_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_FLOW_MODIFY] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_FLOW_MODIFY] + of_object_extra_len[version][OF_FLOW_MODIFY];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_FLOW_MODIFY;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_flow_modify object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_flow_modify
 */

of_flow_modify_t *
of_flow_modify_new_from_message_(of_message_t msg)
{
    of_flow_modify_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_flow_modify_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_flow_modify_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_flow_modify_t *
of_flow_modify_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_flow_modify_t *obj;

    obj = of_flow_modify_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_flow_modify_strict */

/**
 * \defgroup of_flow_modify_strict of_flow_modify_strict
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_flow_modify_strict_push_wire_values(of_flow_modify_strict_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_FLOW_MODIFY_STRICT));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_flow_modify_strict object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_flow_modify_strict
 */

of_flow_modify_strict_t *
of_flow_modify_strict_new_(of_version_t version)
{
    of_flow_modify_strict_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_FLOW_MODIFY_STRICT] + of_object_extra_len[version][OF_FLOW_MODIFY_STRICT];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_flow_modify_strict_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_flow_modify_strict_init(obj, version, bytes, 0);

    if (of_flow_modify_strict_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    /* Initialize match TLV for 1.2 */
    /* FIXME: Check 1.3 below */
    if ((version == OF_VERSION_1_2) || (version == OF_VERSION_1_3)) {
        of_object_u16_set((of_object_t *)obj, 48 + 2, 4);
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_flow_modify_strict_t *
of_flow_modify_strict_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_flow_modify_strict_t *obj;

    obj = of_flow_modify_strict_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_flow_modify_strict.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_flow_modify_strict_init(of_flow_modify_strict_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_FLOW_MODIFY_STRICT] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_FLOW_MODIFY_STRICT] + of_object_extra_len[version][OF_FLOW_MODIFY_STRICT];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_FLOW_MODIFY_STRICT;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_flow_modify_strict object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_flow_modify_strict
 */

of_flow_modify_strict_t *
of_flow_modify_strict_new_from_message_(of_message_t msg)
{
    of_flow_modify_strict_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_flow_modify_strict_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_flow_modify_strict_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_flow_modify_strict_t *
of_flow_modify_strict_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_flow_modify_strict_t *obj;

    obj = of_flow_modify_strict_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_flow_removed */

/**
 * \defgroup of_flow_removed of_flow_removed
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_flow_removed_push_wire_values(of_flow_removed_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_FLOW_REMOVED));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_flow_removed object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_flow_removed
 */

of_flow_removed_t *
of_flow_removed_new_(of_version_t version)
{
    of_flow_removed_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_FLOW_REMOVED] + of_object_extra_len[version][OF_FLOW_REMOVED];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_flow_removed_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_flow_removed_init(obj, version, bytes, 0);

    if (of_flow_removed_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    /* Initialize match TLV for 1.2 */
    /* FIXME: Check 1.3 below */
    if ((version == OF_VERSION_1_2) || (version == OF_VERSION_1_3)) {
        of_object_u16_set((of_object_t *)obj, 48 + 2, 4);
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_flow_removed_t *
of_flow_removed_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_flow_removed_t *obj;

    obj = of_flow_removed_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_flow_removed.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_flow_removed_init(of_flow_removed_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_FLOW_REMOVED] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_FLOW_REMOVED] + of_object_extra_len[version][OF_FLOW_REMOVED];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_FLOW_REMOVED;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_flow_removed object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_flow_removed
 */

of_flow_removed_t *
of_flow_removed_new_from_message_(of_message_t msg)
{
    of_flow_removed_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_flow_removed_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_flow_removed_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_flow_removed_t *
of_flow_removed_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_flow_removed_t *obj;

    obj = of_flow_removed_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_flow_stats_reply */

/**
 * \defgroup of_flow_stats_reply of_flow_stats_reply
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_flow_stats_reply_push_wire_values(of_flow_stats_reply_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_FLOW_STATS_REPLY));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_flow_stats_reply object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_flow_stats_reply
 */

of_flow_stats_reply_t *
of_flow_stats_reply_new_(of_version_t version)
{
    of_flow_stats_reply_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_FLOW_STATS_REPLY] + of_object_extra_len[version][OF_FLOW_STATS_REPLY];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_flow_stats_reply_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_flow_stats_reply_init(obj, version, bytes, 0);

    if (of_flow_stats_reply_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_flow_stats_reply_t *
of_flow_stats_reply_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_flow_stats_reply_t *obj;

    obj = of_flow_stats_reply_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_flow_stats_reply.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_flow_stats_reply_init(of_flow_stats_reply_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_FLOW_STATS_REPLY] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_FLOW_STATS_REPLY] + of_object_extra_len[version][OF_FLOW_STATS_REPLY];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_FLOW_STATS_REPLY;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_flow_stats_reply object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_flow_stats_reply
 */

of_flow_stats_reply_t *
of_flow_stats_reply_new_from_message_(of_message_t msg)
{
    of_flow_stats_reply_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_flow_stats_reply_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_flow_stats_reply_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_flow_stats_reply_t *
of_flow_stats_reply_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_flow_stats_reply_t *obj;

    obj = of_flow_stats_reply_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_flow_stats_request */

/**
 * \defgroup of_flow_stats_request of_flow_stats_request
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_flow_stats_request_push_wire_values(of_flow_stats_request_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_FLOW_STATS_REQUEST));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_flow_stats_request object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_flow_stats_request
 */

of_flow_stats_request_t *
of_flow_stats_request_new_(of_version_t version)
{
    of_flow_stats_request_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_FLOW_STATS_REQUEST] + of_object_extra_len[version][OF_FLOW_STATS_REQUEST];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_flow_stats_request_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_flow_stats_request_init(obj, version, bytes, 0);

    if (of_flow_stats_request_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    /* Initialize match TLV for 1.2 */
    /* FIXME: Check 1.3 below */
    if ((version == OF_VERSION_1_2) || (version == OF_VERSION_1_3)) {
        of_object_u16_set((of_object_t *)obj, 48 + 2, 4);
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_flow_stats_request_t *
of_flow_stats_request_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_flow_stats_request_t *obj;

    obj = of_flow_stats_request_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_flow_stats_request.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_flow_stats_request_init(of_flow_stats_request_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_FLOW_STATS_REQUEST] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_FLOW_STATS_REQUEST] + of_object_extra_len[version][OF_FLOW_STATS_REQUEST];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_FLOW_STATS_REQUEST;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_flow_stats_request object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_flow_stats_request
 */

of_flow_stats_request_t *
of_flow_stats_request_new_from_message_(of_message_t msg)
{
    of_flow_stats_request_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_flow_stats_request_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_flow_stats_request_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_flow_stats_request_t *
of_flow_stats_request_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_flow_stats_request_t *obj;

    obj = of_flow_stats_request_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_get_config_reply */

/**
 * \defgroup of_get_config_reply of_get_config_reply
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_get_config_reply_push_wire_values(of_get_config_reply_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_GET_CONFIG_REPLY));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_get_config_reply object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_get_config_reply
 */

of_get_config_reply_t *
of_get_config_reply_new_(of_version_t version)
{
    of_get_config_reply_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_GET_CONFIG_REPLY] + of_object_extra_len[version][OF_GET_CONFIG_REPLY];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_get_config_reply_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_get_config_reply_init(obj, version, bytes, 0);

    if (of_get_config_reply_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_get_config_reply_t *
of_get_config_reply_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_get_config_reply_t *obj;

    obj = of_get_config_reply_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_get_config_reply.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_get_config_reply_init(of_get_config_reply_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_GET_CONFIG_REPLY] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_GET_CONFIG_REPLY] + of_object_extra_len[version][OF_GET_CONFIG_REPLY];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_GET_CONFIG_REPLY;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_get_config_reply object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_get_config_reply
 */

of_get_config_reply_t *
of_get_config_reply_new_from_message_(of_message_t msg)
{
    of_get_config_reply_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_get_config_reply_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_get_config_reply_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_get_config_reply_t *
of_get_config_reply_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_get_config_reply_t *obj;

    obj = of_get_config_reply_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_get_config_request */

/**
 * \defgroup of_get_config_request of_get_config_request
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_get_config_request_push_wire_values(of_get_config_request_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_GET_CONFIG_REQUEST));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_get_config_request object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_get_config_request
 */

of_get_config_request_t *
of_get_config_request_new_(of_version_t version)
{
    of_get_config_request_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_GET_CONFIG_REQUEST] + of_object_extra_len[version][OF_GET_CONFIG_REQUEST];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_get_config_request_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_get_config_request_init(obj, version, bytes, 0);

    if (of_get_config_request_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_get_config_request_t *
of_get_config_request_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_get_config_request_t *obj;

    obj = of_get_config_request_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_get_config_request.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_get_config_request_init(of_get_config_request_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_GET_CONFIG_REQUEST] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_GET_CONFIG_REQUEST] + of_object_extra_len[version][OF_GET_CONFIG_REQUEST];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_GET_CONFIG_REQUEST;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_get_config_request object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_get_config_request
 */

of_get_config_request_t *
of_get_config_request_new_from_message_(of_message_t msg)
{
    of_get_config_request_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_get_config_request_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_get_config_request_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_get_config_request_t *
of_get_config_request_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_get_config_request_t *obj;

    obj = of_get_config_request_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_group_desc_stats_reply */

/**
 * \defgroup of_group_desc_stats_reply of_group_desc_stats_reply
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_group_desc_stats_reply_push_wire_values(of_group_desc_stats_reply_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_GROUP_DESC_STATS_REPLY));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_group_desc_stats_reply object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_group_desc_stats_reply
 */

of_group_desc_stats_reply_t *
of_group_desc_stats_reply_new_(of_version_t version)
{
    of_group_desc_stats_reply_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_GROUP_DESC_STATS_REPLY] + of_object_extra_len[version][OF_GROUP_DESC_STATS_REPLY];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_group_desc_stats_reply_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_group_desc_stats_reply_init(obj, version, bytes, 0);

    if (of_group_desc_stats_reply_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_group_desc_stats_reply_t *
of_group_desc_stats_reply_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_group_desc_stats_reply_t *obj;

    obj = of_group_desc_stats_reply_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_group_desc_stats_reply.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_group_desc_stats_reply_init(of_group_desc_stats_reply_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_GROUP_DESC_STATS_REPLY] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_GROUP_DESC_STATS_REPLY] + of_object_extra_len[version][OF_GROUP_DESC_STATS_REPLY];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_GROUP_DESC_STATS_REPLY;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_group_desc_stats_reply object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_group_desc_stats_reply
 */

of_group_desc_stats_reply_t *
of_group_desc_stats_reply_new_from_message_(of_message_t msg)
{
    of_group_desc_stats_reply_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_group_desc_stats_reply_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_group_desc_stats_reply_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_group_desc_stats_reply_t *
of_group_desc_stats_reply_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_group_desc_stats_reply_t *obj;

    obj = of_group_desc_stats_reply_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_group_desc_stats_request */

/**
 * \defgroup of_group_desc_stats_request of_group_desc_stats_request
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_group_desc_stats_request_push_wire_values(of_group_desc_stats_request_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_GROUP_DESC_STATS_REQUEST));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_group_desc_stats_request object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_group_desc_stats_request
 */

of_group_desc_stats_request_t *
of_group_desc_stats_request_new_(of_version_t version)
{
    of_group_desc_stats_request_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_GROUP_DESC_STATS_REQUEST] + of_object_extra_len[version][OF_GROUP_DESC_STATS_REQUEST];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_group_desc_stats_request_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_group_desc_stats_request_init(obj, version, bytes, 0);

    if (of_group_desc_stats_request_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_group_desc_stats_request_t *
of_group_desc_stats_request_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_group_desc_stats_request_t *obj;

    obj = of_group_desc_stats_request_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_group_desc_stats_request.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_group_desc_stats_request_init(of_group_desc_stats_request_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_GROUP_DESC_STATS_REQUEST] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_GROUP_DESC_STATS_REQUEST] + of_object_extra_len[version][OF_GROUP_DESC_STATS_REQUEST];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_GROUP_DESC_STATS_REQUEST;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_group_desc_stats_request object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_group_desc_stats_request
 */

of_group_desc_stats_request_t *
of_group_desc_stats_request_new_from_message_(of_message_t msg)
{
    of_group_desc_stats_request_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_group_desc_stats_request_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_group_desc_stats_request_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_group_desc_stats_request_t *
of_group_desc_stats_request_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_group_desc_stats_request_t *obj;

    obj = of_group_desc_stats_request_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_group_features_stats_reply */

/**
 * \defgroup of_group_features_stats_reply of_group_features_stats_reply
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_group_features_stats_reply_push_wire_values(of_group_features_stats_reply_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_GROUP_FEATURES_STATS_REPLY));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_group_features_stats_reply object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_group_features_stats_reply
 */

of_group_features_stats_reply_t *
of_group_features_stats_reply_new_(of_version_t version)
{
    of_group_features_stats_reply_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_GROUP_FEATURES_STATS_REPLY] + of_object_extra_len[version][OF_GROUP_FEATURES_STATS_REPLY];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_group_features_stats_reply_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_group_features_stats_reply_init(obj, version, bytes, 0);

    if (of_group_features_stats_reply_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_group_features_stats_reply_t *
of_group_features_stats_reply_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_group_features_stats_reply_t *obj;

    obj = of_group_features_stats_reply_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_group_features_stats_reply.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_group_features_stats_reply_init(of_group_features_stats_reply_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_GROUP_FEATURES_STATS_REPLY] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_GROUP_FEATURES_STATS_REPLY] + of_object_extra_len[version][OF_GROUP_FEATURES_STATS_REPLY];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_GROUP_FEATURES_STATS_REPLY;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_group_features_stats_reply object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_group_features_stats_reply
 */

of_group_features_stats_reply_t *
of_group_features_stats_reply_new_from_message_(of_message_t msg)
{
    of_group_features_stats_reply_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_group_features_stats_reply_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_group_features_stats_reply_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_group_features_stats_reply_t *
of_group_features_stats_reply_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_group_features_stats_reply_t *obj;

    obj = of_group_features_stats_reply_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_group_features_stats_request */

/**
 * \defgroup of_group_features_stats_request of_group_features_stats_request
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_group_features_stats_request_push_wire_values(of_group_features_stats_request_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_GROUP_FEATURES_STATS_REQUEST));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_group_features_stats_request object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_group_features_stats_request
 */

of_group_features_stats_request_t *
of_group_features_stats_request_new_(of_version_t version)
{
    of_group_features_stats_request_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_GROUP_FEATURES_STATS_REQUEST] + of_object_extra_len[version][OF_GROUP_FEATURES_STATS_REQUEST];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_group_features_stats_request_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_group_features_stats_request_init(obj, version, bytes, 0);

    if (of_group_features_stats_request_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_group_features_stats_request_t *
of_group_features_stats_request_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_group_features_stats_request_t *obj;

    obj = of_group_features_stats_request_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_group_features_stats_request.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_group_features_stats_request_init(of_group_features_stats_request_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_GROUP_FEATURES_STATS_REQUEST] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_GROUP_FEATURES_STATS_REQUEST] + of_object_extra_len[version][OF_GROUP_FEATURES_STATS_REQUEST];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_GROUP_FEATURES_STATS_REQUEST;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_group_features_stats_request object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_group_features_stats_request
 */

of_group_features_stats_request_t *
of_group_features_stats_request_new_from_message_(of_message_t msg)
{
    of_group_features_stats_request_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_group_features_stats_request_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_group_features_stats_request_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_group_features_stats_request_t *
of_group_features_stats_request_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_group_features_stats_request_t *obj;

    obj = of_group_features_stats_request_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_group_mod */

/**
 * \defgroup of_group_mod of_group_mod
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_group_mod_push_wire_values(of_group_mod_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_GROUP_MOD));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_group_mod object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_group_mod
 */

of_group_mod_t *
of_group_mod_new_(of_version_t version)
{
    of_group_mod_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_GROUP_MOD] + of_object_extra_len[version][OF_GROUP_MOD];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_group_mod_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_group_mod_init(obj, version, bytes, 0);

    if (of_group_mod_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_group_mod_t *
of_group_mod_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_group_mod_t *obj;

    obj = of_group_mod_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_group_mod.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_group_mod_init(of_group_mod_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_GROUP_MOD] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_GROUP_MOD] + of_object_extra_len[version][OF_GROUP_MOD];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_GROUP_MOD;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_group_mod object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_group_mod
 */

of_group_mod_t *
of_group_mod_new_from_message_(of_message_t msg)
{
    of_group_mod_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_group_mod_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_group_mod_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_group_mod_t *
of_group_mod_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_group_mod_t *obj;

    obj = of_group_mod_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_group_stats_reply */

/**
 * \defgroup of_group_stats_reply of_group_stats_reply
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_group_stats_reply_push_wire_values(of_group_stats_reply_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_GROUP_STATS_REPLY));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_group_stats_reply object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_group_stats_reply
 */

of_group_stats_reply_t *
of_group_stats_reply_new_(of_version_t version)
{
    of_group_stats_reply_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_GROUP_STATS_REPLY] + of_object_extra_len[version][OF_GROUP_STATS_REPLY];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_group_stats_reply_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_group_stats_reply_init(obj, version, bytes, 0);

    if (of_group_stats_reply_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_group_stats_reply_t *
of_group_stats_reply_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_group_stats_reply_t *obj;

    obj = of_group_stats_reply_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_group_stats_reply.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_group_stats_reply_init(of_group_stats_reply_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_GROUP_STATS_REPLY] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_GROUP_STATS_REPLY] + of_object_extra_len[version][OF_GROUP_STATS_REPLY];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_GROUP_STATS_REPLY;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_group_stats_reply object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_group_stats_reply
 */

of_group_stats_reply_t *
of_group_stats_reply_new_from_message_(of_message_t msg)
{
    of_group_stats_reply_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_group_stats_reply_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_group_stats_reply_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_group_stats_reply_t *
of_group_stats_reply_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_group_stats_reply_t *obj;

    obj = of_group_stats_reply_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_group_stats_request */

/**
 * \defgroup of_group_stats_request of_group_stats_request
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_group_stats_request_push_wire_values(of_group_stats_request_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_GROUP_STATS_REQUEST));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_group_stats_request object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_group_stats_request
 */

of_group_stats_request_t *
of_group_stats_request_new_(of_version_t version)
{
    of_group_stats_request_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_GROUP_STATS_REQUEST] + of_object_extra_len[version][OF_GROUP_STATS_REQUEST];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_group_stats_request_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_group_stats_request_init(obj, version, bytes, 0);

    if (of_group_stats_request_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_group_stats_request_t *
of_group_stats_request_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_group_stats_request_t *obj;

    obj = of_group_stats_request_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_group_stats_request.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_group_stats_request_init(of_group_stats_request_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_GROUP_STATS_REQUEST] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_GROUP_STATS_REQUEST] + of_object_extra_len[version][OF_GROUP_STATS_REQUEST];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_GROUP_STATS_REQUEST;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_group_stats_request object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_group_stats_request
 */

of_group_stats_request_t *
of_group_stats_request_new_from_message_(of_message_t msg)
{
    of_group_stats_request_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_group_stats_request_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_group_stats_request_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_group_stats_request_t *
of_group_stats_request_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_group_stats_request_t *obj;

    obj = of_group_stats_request_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_hello */

/**
 * \defgroup of_hello of_hello
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_hello_push_wire_values(of_hello_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_HELLO));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_hello object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_hello
 */

of_hello_t *
of_hello_new_(of_version_t version)
{
    of_hello_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_HELLO] + of_object_extra_len[version][OF_HELLO];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_hello_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_hello_init(obj, version, bytes, 0);

    if (of_hello_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_hello_t *
of_hello_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_hello_t *obj;

    obj = of_hello_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_hello.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_hello_init(of_hello_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_HELLO] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_HELLO] + of_object_extra_len[version][OF_HELLO];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_HELLO;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_hello object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_hello
 */

of_hello_t *
of_hello_new_from_message_(of_message_t msg)
{
    of_hello_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_hello_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_hello_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_hello_t *
of_hello_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_hello_t *obj;

    obj = of_hello_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_meter_config_stats_reply */

/**
 * \defgroup of_meter_config_stats_reply of_meter_config_stats_reply
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_meter_config_stats_reply_push_wire_values(of_meter_config_stats_reply_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_METER_CONFIG_STATS_REPLY));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_meter_config_stats_reply object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_meter_config_stats_reply
 */

of_meter_config_stats_reply_t *
of_meter_config_stats_reply_new_(of_version_t version)
{
    of_meter_config_stats_reply_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_METER_CONFIG_STATS_REPLY] + of_object_extra_len[version][OF_METER_CONFIG_STATS_REPLY];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_meter_config_stats_reply_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_meter_config_stats_reply_init(obj, version, bytes, 0);

    if (of_meter_config_stats_reply_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_meter_config_stats_reply_t *
of_meter_config_stats_reply_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_meter_config_stats_reply_t *obj;

    obj = of_meter_config_stats_reply_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_meter_config_stats_reply.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_meter_config_stats_reply_init(of_meter_config_stats_reply_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_METER_CONFIG_STATS_REPLY] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_METER_CONFIG_STATS_REPLY] + of_object_extra_len[version][OF_METER_CONFIG_STATS_REPLY];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_METER_CONFIG_STATS_REPLY;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_meter_config_stats_reply object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_meter_config_stats_reply
 */

of_meter_config_stats_reply_t *
of_meter_config_stats_reply_new_from_message_(of_message_t msg)
{
    of_meter_config_stats_reply_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_meter_config_stats_reply_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_meter_config_stats_reply_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_meter_config_stats_reply_t *
of_meter_config_stats_reply_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_meter_config_stats_reply_t *obj;

    obj = of_meter_config_stats_reply_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_meter_config_stats_request */

/**
 * \defgroup of_meter_config_stats_request of_meter_config_stats_request
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_meter_config_stats_request_push_wire_values(of_meter_config_stats_request_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_METER_CONFIG_STATS_REQUEST));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_meter_config_stats_request object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_meter_config_stats_request
 */

of_meter_config_stats_request_t *
of_meter_config_stats_request_new_(of_version_t version)
{
    of_meter_config_stats_request_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_METER_CONFIG_STATS_REQUEST] + of_object_extra_len[version][OF_METER_CONFIG_STATS_REQUEST];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_meter_config_stats_request_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_meter_config_stats_request_init(obj, version, bytes, 0);

    if (of_meter_config_stats_request_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_meter_config_stats_request_t *
of_meter_config_stats_request_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_meter_config_stats_request_t *obj;

    obj = of_meter_config_stats_request_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_meter_config_stats_request.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_meter_config_stats_request_init(of_meter_config_stats_request_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_METER_CONFIG_STATS_REQUEST] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_METER_CONFIG_STATS_REQUEST] + of_object_extra_len[version][OF_METER_CONFIG_STATS_REQUEST];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_METER_CONFIG_STATS_REQUEST;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_meter_config_stats_request object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_meter_config_stats_request
 */

of_meter_config_stats_request_t *
of_meter_config_stats_request_new_from_message_(of_message_t msg)
{
    of_meter_config_stats_request_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_meter_config_stats_request_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_meter_config_stats_request_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_meter_config_stats_request_t *
of_meter_config_stats_request_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_meter_config_stats_request_t *obj;

    obj = of_meter_config_stats_request_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_meter_features_stats_reply */

/**
 * \defgroup of_meter_features_stats_reply of_meter_features_stats_reply
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_meter_features_stats_reply_push_wire_values(of_meter_features_stats_reply_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_METER_FEATURES_STATS_REPLY));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_meter_features_stats_reply object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_meter_features_stats_reply
 */

of_meter_features_stats_reply_t *
of_meter_features_stats_reply_new_(of_version_t version)
{
    of_meter_features_stats_reply_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_METER_FEATURES_STATS_REPLY] + of_object_extra_len[version][OF_METER_FEATURES_STATS_REPLY];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_meter_features_stats_reply_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_meter_features_stats_reply_init(obj, version, bytes, 0);

    if (of_meter_features_stats_reply_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_meter_features_stats_reply_t *
of_meter_features_stats_reply_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_meter_features_stats_reply_t *obj;

    obj = of_meter_features_stats_reply_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_meter_features_stats_reply.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_meter_features_stats_reply_init(of_meter_features_stats_reply_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_METER_FEATURES_STATS_REPLY] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_METER_FEATURES_STATS_REPLY] + of_object_extra_len[version][OF_METER_FEATURES_STATS_REPLY];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_METER_FEATURES_STATS_REPLY;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_meter_features_stats_reply object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_meter_features_stats_reply
 */

of_meter_features_stats_reply_t *
of_meter_features_stats_reply_new_from_message_(of_message_t msg)
{
    of_meter_features_stats_reply_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_meter_features_stats_reply_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_meter_features_stats_reply_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_meter_features_stats_reply_t *
of_meter_features_stats_reply_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_meter_features_stats_reply_t *obj;

    obj = of_meter_features_stats_reply_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_meter_features_stats_request */

/**
 * \defgroup of_meter_features_stats_request of_meter_features_stats_request
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_meter_features_stats_request_push_wire_values(of_meter_features_stats_request_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_METER_FEATURES_STATS_REQUEST));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_meter_features_stats_request object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_meter_features_stats_request
 */

of_meter_features_stats_request_t *
of_meter_features_stats_request_new_(of_version_t version)
{
    of_meter_features_stats_request_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_METER_FEATURES_STATS_REQUEST] + of_object_extra_len[version][OF_METER_FEATURES_STATS_REQUEST];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_meter_features_stats_request_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_meter_features_stats_request_init(obj, version, bytes, 0);

    if (of_meter_features_stats_request_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_meter_features_stats_request_t *
of_meter_features_stats_request_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_meter_features_stats_request_t *obj;

    obj = of_meter_features_stats_request_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_meter_features_stats_request.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_meter_features_stats_request_init(of_meter_features_stats_request_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_METER_FEATURES_STATS_REQUEST] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_METER_FEATURES_STATS_REQUEST] + of_object_extra_len[version][OF_METER_FEATURES_STATS_REQUEST];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_METER_FEATURES_STATS_REQUEST;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_meter_features_stats_request object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_meter_features_stats_request
 */

of_meter_features_stats_request_t *
of_meter_features_stats_request_new_from_message_(of_message_t msg)
{
    of_meter_features_stats_request_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_meter_features_stats_request_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_meter_features_stats_request_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_meter_features_stats_request_t *
of_meter_features_stats_request_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_meter_features_stats_request_t *obj;

    obj = of_meter_features_stats_request_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_meter_mod */

/**
 * \defgroup of_meter_mod of_meter_mod
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_meter_mod_push_wire_values(of_meter_mod_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_METER_MOD));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_meter_mod object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_meter_mod
 */

of_meter_mod_t *
of_meter_mod_new_(of_version_t version)
{
    of_meter_mod_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_METER_MOD] + of_object_extra_len[version][OF_METER_MOD];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_meter_mod_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_meter_mod_init(obj, version, bytes, 0);

    if (of_meter_mod_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_meter_mod_t *
of_meter_mod_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_meter_mod_t *obj;

    obj = of_meter_mod_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_meter_mod.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_meter_mod_init(of_meter_mod_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_METER_MOD] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_METER_MOD] + of_object_extra_len[version][OF_METER_MOD];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_METER_MOD;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_meter_mod object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_meter_mod
 */

of_meter_mod_t *
of_meter_mod_new_from_message_(of_message_t msg)
{
    of_meter_mod_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_meter_mod_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_meter_mod_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_meter_mod_t *
of_meter_mod_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_meter_mod_t *obj;

    obj = of_meter_mod_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_meter_stats_reply */

/**
 * \defgroup of_meter_stats_reply of_meter_stats_reply
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_meter_stats_reply_push_wire_values(of_meter_stats_reply_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_METER_STATS_REPLY));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_meter_stats_reply object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_meter_stats_reply
 */

of_meter_stats_reply_t *
of_meter_stats_reply_new_(of_version_t version)
{
    of_meter_stats_reply_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_METER_STATS_REPLY] + of_object_extra_len[version][OF_METER_STATS_REPLY];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_meter_stats_reply_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_meter_stats_reply_init(obj, version, bytes, 0);

    if (of_meter_stats_reply_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_meter_stats_reply_t *
of_meter_stats_reply_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_meter_stats_reply_t *obj;

    obj = of_meter_stats_reply_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_meter_stats_reply.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_meter_stats_reply_init(of_meter_stats_reply_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_METER_STATS_REPLY] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_METER_STATS_REPLY] + of_object_extra_len[version][OF_METER_STATS_REPLY];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_METER_STATS_REPLY;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_meter_stats_reply object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_meter_stats_reply
 */

of_meter_stats_reply_t *
of_meter_stats_reply_new_from_message_(of_message_t msg)
{
    of_meter_stats_reply_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_meter_stats_reply_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_meter_stats_reply_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_meter_stats_reply_t *
of_meter_stats_reply_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_meter_stats_reply_t *obj;

    obj = of_meter_stats_reply_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_meter_stats_request */

/**
 * \defgroup of_meter_stats_request of_meter_stats_request
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_meter_stats_request_push_wire_values(of_meter_stats_request_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_METER_STATS_REQUEST));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_meter_stats_request object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_meter_stats_request
 */

of_meter_stats_request_t *
of_meter_stats_request_new_(of_version_t version)
{
    of_meter_stats_request_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_METER_STATS_REQUEST] + of_object_extra_len[version][OF_METER_STATS_REQUEST];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_meter_stats_request_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_meter_stats_request_init(obj, version, bytes, 0);

    if (of_meter_stats_request_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_meter_stats_request_t *
of_meter_stats_request_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_meter_stats_request_t *obj;

    obj = of_meter_stats_request_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_meter_stats_request.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_meter_stats_request_init(of_meter_stats_request_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_METER_STATS_REQUEST] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_METER_STATS_REQUEST] + of_object_extra_len[version][OF_METER_STATS_REQUEST];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_METER_STATS_REQUEST;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_meter_stats_request object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_meter_stats_request
 */

of_meter_stats_request_t *
of_meter_stats_request_new_from_message_(of_message_t msg)
{
    of_meter_stats_request_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_meter_stats_request_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_meter_stats_request_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_meter_stats_request_t *
of_meter_stats_request_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_meter_stats_request_t *obj;

    obj = of_meter_stats_request_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_nicira_controller_role_reply */

/**
 * \defgroup of_nicira_controller_role_reply of_nicira_controller_role_reply
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_nicira_controller_role_reply_push_wire_values(of_nicira_controller_role_reply_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_NICIRA_CONTROLLER_ROLE_REPLY));
    }

    if (obj->version == OF_VERSION_1_0) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_NICIRA);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            11);
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_nicira_controller_role_reply object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_nicira_controller_role_reply
 */

of_nicira_controller_role_reply_t *
of_nicira_controller_role_reply_new_(of_version_t version)
{
    of_nicira_controller_role_reply_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_NICIRA_CONTROLLER_ROLE_REPLY] + of_object_extra_len[version][OF_NICIRA_CONTROLLER_ROLE_REPLY];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_nicira_controller_role_reply_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_nicira_controller_role_reply_init(obj, version, bytes, 0);

    if (of_nicira_controller_role_reply_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_nicira_controller_role_reply_t *
of_nicira_controller_role_reply_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_nicira_controller_role_reply_t *obj;

    obj = of_nicira_controller_role_reply_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_nicira_controller_role_reply.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_nicira_controller_role_reply_init(of_nicira_controller_role_reply_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_NICIRA_CONTROLLER_ROLE_REPLY] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_NICIRA_CONTROLLER_ROLE_REPLY] + of_object_extra_len[version][OF_NICIRA_CONTROLLER_ROLE_REPLY];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_NICIRA_CONTROLLER_ROLE_REPLY;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_nicira_controller_role_reply object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_nicira_controller_role_reply
 */

of_nicira_controller_role_reply_t *
of_nicira_controller_role_reply_new_from_message_(of_message_t msg)
{
    of_nicira_controller_role_reply_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_nicira_controller_role_reply_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_nicira_controller_role_reply_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_nicira_controller_role_reply_t *
of_nicira_controller_role_reply_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_nicira_controller_role_reply_t *obj;

    obj = of_nicira_controller_role_reply_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_nicira_controller_role_request */

/**
 * \defgroup of_nicira_controller_role_request of_nicira_controller_role_request
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_nicira_controller_role_request_push_wire_values(of_nicira_controller_role_request_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_NICIRA_CONTROLLER_ROLE_REQUEST));
    }

    if (obj->version == OF_VERSION_1_0) {
        of_message_experimenter_id_set(OF_OBJECT_TO_MESSAGE(obj),
                                       OF_EXPERIMENTER_ID_NICIRA);
        of_message_experimenter_subtype_set(OF_OBJECT_TO_MESSAGE(obj),
                                            10);
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_nicira_controller_role_request object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_nicira_controller_role_request
 */

of_nicira_controller_role_request_t *
of_nicira_controller_role_request_new_(of_version_t version)
{
    of_nicira_controller_role_request_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_NICIRA_CONTROLLER_ROLE_REQUEST] + of_object_extra_len[version][OF_NICIRA_CONTROLLER_ROLE_REQUEST];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_nicira_controller_role_request_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_nicira_controller_role_request_init(obj, version, bytes, 0);

    if (of_nicira_controller_role_request_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_nicira_controller_role_request_t *
of_nicira_controller_role_request_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_nicira_controller_role_request_t *obj;

    obj = of_nicira_controller_role_request_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_nicira_controller_role_request.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_nicira_controller_role_request_init(of_nicira_controller_role_request_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_NICIRA_CONTROLLER_ROLE_REQUEST] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_NICIRA_CONTROLLER_ROLE_REQUEST] + of_object_extra_len[version][OF_NICIRA_CONTROLLER_ROLE_REQUEST];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_NICIRA_CONTROLLER_ROLE_REQUEST;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_nicira_controller_role_request object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_nicira_controller_role_request
 */

of_nicira_controller_role_request_t *
of_nicira_controller_role_request_new_from_message_(of_message_t msg)
{
    of_nicira_controller_role_request_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_nicira_controller_role_request_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_nicira_controller_role_request_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_nicira_controller_role_request_t *
of_nicira_controller_role_request_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_nicira_controller_role_request_t *obj;

    obj = of_nicira_controller_role_request_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_packet_in */

/**
 * \defgroup of_packet_in of_packet_in
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_packet_in_push_wire_values(of_packet_in_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_PACKET_IN));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_packet_in object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_packet_in
 */

of_packet_in_t *
of_packet_in_new_(of_version_t version)
{
    of_packet_in_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_PACKET_IN] + of_object_extra_len[version][OF_PACKET_IN];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_packet_in_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_packet_in_init(obj, version, bytes, 0);

    if (of_packet_in_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    /* Initialize match TLV for 1.2 */
    /* FIXME: Check 1.3 below */
    if ((version == OF_VERSION_1_2) || (version == OF_VERSION_1_3)) {
        of_object_u16_set((of_object_t *)obj, 16 + 2, 4);
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_packet_in_t *
of_packet_in_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_packet_in_t *obj;

    obj = of_packet_in_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_packet_in.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_packet_in_init(of_packet_in_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_PACKET_IN] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_PACKET_IN] + of_object_extra_len[version][OF_PACKET_IN];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_PACKET_IN;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_packet_in object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_packet_in
 */

of_packet_in_t *
of_packet_in_new_from_message_(of_message_t msg)
{
    of_packet_in_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_packet_in_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_packet_in_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_packet_in_t *
of_packet_in_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_packet_in_t *obj;

    obj = of_packet_in_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_packet_out */

/**
 * \defgroup of_packet_out of_packet_out
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_packet_out_push_wire_values(of_packet_out_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_PACKET_OUT));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_packet_out object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_packet_out
 */

of_packet_out_t *
of_packet_out_new_(of_version_t version)
{
    of_packet_out_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_PACKET_OUT] + of_object_extra_len[version][OF_PACKET_OUT];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_packet_out_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_packet_out_init(obj, version, bytes, 0);

    if (of_packet_out_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_packet_out_t *
of_packet_out_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_packet_out_t *obj;

    obj = of_packet_out_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_packet_out.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_packet_out_init(of_packet_out_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_PACKET_OUT] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_PACKET_OUT] + of_object_extra_len[version][OF_PACKET_OUT];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_PACKET_OUT;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_packet_out object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_packet_out
 */

of_packet_out_t *
of_packet_out_new_from_message_(of_message_t msg)
{
    of_packet_out_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_packet_out_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_packet_out_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_packet_out_t *
of_packet_out_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_packet_out_t *obj;

    obj = of_packet_out_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_port_desc_stats_reply */

/**
 * \defgroup of_port_desc_stats_reply of_port_desc_stats_reply
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_port_desc_stats_reply_push_wire_values(of_port_desc_stats_reply_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_PORT_DESC_STATS_REPLY));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_port_desc_stats_reply object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_port_desc_stats_reply
 */

of_port_desc_stats_reply_t *
of_port_desc_stats_reply_new_(of_version_t version)
{
    of_port_desc_stats_reply_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_PORT_DESC_STATS_REPLY] + of_object_extra_len[version][OF_PORT_DESC_STATS_REPLY];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_port_desc_stats_reply_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_port_desc_stats_reply_init(obj, version, bytes, 0);

    if (of_port_desc_stats_reply_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_port_desc_stats_reply_t *
of_port_desc_stats_reply_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_port_desc_stats_reply_t *obj;

    obj = of_port_desc_stats_reply_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_port_desc_stats_reply.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_port_desc_stats_reply_init(of_port_desc_stats_reply_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_PORT_DESC_STATS_REPLY] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_PORT_DESC_STATS_REPLY] + of_object_extra_len[version][OF_PORT_DESC_STATS_REPLY];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_PORT_DESC_STATS_REPLY;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_port_desc_stats_reply object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_port_desc_stats_reply
 */

of_port_desc_stats_reply_t *
of_port_desc_stats_reply_new_from_message_(of_message_t msg)
{
    of_port_desc_stats_reply_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_port_desc_stats_reply_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_port_desc_stats_reply_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_port_desc_stats_reply_t *
of_port_desc_stats_reply_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_port_desc_stats_reply_t *obj;

    obj = of_port_desc_stats_reply_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_port_desc_stats_request */

/**
 * \defgroup of_port_desc_stats_request of_port_desc_stats_request
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_port_desc_stats_request_push_wire_values(of_port_desc_stats_request_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_PORT_DESC_STATS_REQUEST));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_port_desc_stats_request object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_port_desc_stats_request
 */

of_port_desc_stats_request_t *
of_port_desc_stats_request_new_(of_version_t version)
{
    of_port_desc_stats_request_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_PORT_DESC_STATS_REQUEST] + of_object_extra_len[version][OF_PORT_DESC_STATS_REQUEST];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_port_desc_stats_request_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_port_desc_stats_request_init(obj, version, bytes, 0);

    if (of_port_desc_stats_request_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_port_desc_stats_request_t *
of_port_desc_stats_request_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_port_desc_stats_request_t *obj;

    obj = of_port_desc_stats_request_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_port_desc_stats_request.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_port_desc_stats_request_init(of_port_desc_stats_request_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_PORT_DESC_STATS_REQUEST] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_PORT_DESC_STATS_REQUEST] + of_object_extra_len[version][OF_PORT_DESC_STATS_REQUEST];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_PORT_DESC_STATS_REQUEST;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_port_desc_stats_request object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_port_desc_stats_request
 */

of_port_desc_stats_request_t *
of_port_desc_stats_request_new_from_message_(of_message_t msg)
{
    of_port_desc_stats_request_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_port_desc_stats_request_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_port_desc_stats_request_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_port_desc_stats_request_t *
of_port_desc_stats_request_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_port_desc_stats_request_t *obj;

    obj = of_port_desc_stats_request_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_port_mod */

/**
 * \defgroup of_port_mod of_port_mod
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_port_mod_push_wire_values(of_port_mod_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_PORT_MOD));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_port_mod object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_port_mod
 */

of_port_mod_t *
of_port_mod_new_(of_version_t version)
{
    of_port_mod_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_PORT_MOD] + of_object_extra_len[version][OF_PORT_MOD];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_port_mod_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_port_mod_init(obj, version, bytes, 0);

    if (of_port_mod_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_port_mod_t *
of_port_mod_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_port_mod_t *obj;

    obj = of_port_mod_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_port_mod.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_port_mod_init(of_port_mod_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_PORT_MOD] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_PORT_MOD] + of_object_extra_len[version][OF_PORT_MOD];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_PORT_MOD;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_port_mod object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_port_mod
 */

of_port_mod_t *
of_port_mod_new_from_message_(of_message_t msg)
{
    of_port_mod_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_port_mod_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_port_mod_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_port_mod_t *
of_port_mod_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_port_mod_t *obj;

    obj = of_port_mod_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_port_stats_reply */

/**
 * \defgroup of_port_stats_reply of_port_stats_reply
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_port_stats_reply_push_wire_values(of_port_stats_reply_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_PORT_STATS_REPLY));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_port_stats_reply object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_port_stats_reply
 */

of_port_stats_reply_t *
of_port_stats_reply_new_(of_version_t version)
{
    of_port_stats_reply_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_PORT_STATS_REPLY] + of_object_extra_len[version][OF_PORT_STATS_REPLY];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_port_stats_reply_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_port_stats_reply_init(obj, version, bytes, 0);

    if (of_port_stats_reply_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_port_stats_reply_t *
of_port_stats_reply_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_port_stats_reply_t *obj;

    obj = of_port_stats_reply_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_port_stats_reply.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_port_stats_reply_init(of_port_stats_reply_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_PORT_STATS_REPLY] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_PORT_STATS_REPLY] + of_object_extra_len[version][OF_PORT_STATS_REPLY];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_PORT_STATS_REPLY;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_port_stats_reply object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_port_stats_reply
 */

of_port_stats_reply_t *
of_port_stats_reply_new_from_message_(of_message_t msg)
{
    of_port_stats_reply_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_port_stats_reply_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_port_stats_reply_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_port_stats_reply_t *
of_port_stats_reply_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_port_stats_reply_t *obj;

    obj = of_port_stats_reply_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_port_stats_request */

/**
 * \defgroup of_port_stats_request of_port_stats_request
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_port_stats_request_push_wire_values(of_port_stats_request_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_PORT_STATS_REQUEST));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_port_stats_request object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_port_stats_request
 */

of_port_stats_request_t *
of_port_stats_request_new_(of_version_t version)
{
    of_port_stats_request_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_PORT_STATS_REQUEST] + of_object_extra_len[version][OF_PORT_STATS_REQUEST];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_port_stats_request_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_port_stats_request_init(obj, version, bytes, 0);

    if (of_port_stats_request_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_port_stats_request_t *
of_port_stats_request_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_port_stats_request_t *obj;

    obj = of_port_stats_request_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_port_stats_request.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_port_stats_request_init(of_port_stats_request_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_PORT_STATS_REQUEST] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_PORT_STATS_REQUEST] + of_object_extra_len[version][OF_PORT_STATS_REQUEST];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_PORT_STATS_REQUEST;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_port_stats_request object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_port_stats_request
 */

of_port_stats_request_t *
of_port_stats_request_new_from_message_(of_message_t msg)
{
    of_port_stats_request_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_port_stats_request_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_port_stats_request_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_port_stats_request_t *
of_port_stats_request_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_port_stats_request_t *obj;

    obj = of_port_stats_request_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_port_status */

/**
 * \defgroup of_port_status of_port_status
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_port_status_push_wire_values(of_port_status_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_PORT_STATUS));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_port_status object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_port_status
 */

of_port_status_t *
of_port_status_new_(of_version_t version)
{
    of_port_status_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_PORT_STATUS] + of_object_extra_len[version][OF_PORT_STATUS];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_port_status_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_port_status_init(obj, version, bytes, 0);

    if (of_port_status_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_port_status_t *
of_port_status_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_port_status_t *obj;

    obj = of_port_status_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_port_status.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_port_status_init(of_port_status_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_PORT_STATUS] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_PORT_STATUS] + of_object_extra_len[version][OF_PORT_STATUS];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_PORT_STATUS;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_port_status object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_port_status
 */

of_port_status_t *
of_port_status_new_from_message_(of_message_t msg)
{
    of_port_status_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_port_status_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_port_status_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_port_status_t *
of_port_status_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_port_status_t *obj;

    obj = of_port_status_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_queue_get_config_reply */

/**
 * \defgroup of_queue_get_config_reply of_queue_get_config_reply
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_queue_get_config_reply_push_wire_values(of_queue_get_config_reply_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_QUEUE_GET_CONFIG_REPLY));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_queue_get_config_reply object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_queue_get_config_reply
 */

of_queue_get_config_reply_t *
of_queue_get_config_reply_new_(of_version_t version)
{
    of_queue_get_config_reply_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_QUEUE_GET_CONFIG_REPLY] + of_object_extra_len[version][OF_QUEUE_GET_CONFIG_REPLY];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_queue_get_config_reply_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_queue_get_config_reply_init(obj, version, bytes, 0);

    if (of_queue_get_config_reply_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_queue_get_config_reply_t *
of_queue_get_config_reply_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_queue_get_config_reply_t *obj;

    obj = of_queue_get_config_reply_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_queue_get_config_reply.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_queue_get_config_reply_init(of_queue_get_config_reply_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_QUEUE_GET_CONFIG_REPLY] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_QUEUE_GET_CONFIG_REPLY] + of_object_extra_len[version][OF_QUEUE_GET_CONFIG_REPLY];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_QUEUE_GET_CONFIG_REPLY;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_queue_get_config_reply object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_queue_get_config_reply
 */

of_queue_get_config_reply_t *
of_queue_get_config_reply_new_from_message_(of_message_t msg)
{
    of_queue_get_config_reply_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_queue_get_config_reply_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_queue_get_config_reply_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_queue_get_config_reply_t *
of_queue_get_config_reply_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_queue_get_config_reply_t *obj;

    obj = of_queue_get_config_reply_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_queue_get_config_request */

/**
 * \defgroup of_queue_get_config_request of_queue_get_config_request
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_queue_get_config_request_push_wire_values(of_queue_get_config_request_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_QUEUE_GET_CONFIG_REQUEST));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_queue_get_config_request object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_queue_get_config_request
 */

of_queue_get_config_request_t *
of_queue_get_config_request_new_(of_version_t version)
{
    of_queue_get_config_request_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_QUEUE_GET_CONFIG_REQUEST] + of_object_extra_len[version][OF_QUEUE_GET_CONFIG_REQUEST];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_queue_get_config_request_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_queue_get_config_request_init(obj, version, bytes, 0);

    if (of_queue_get_config_request_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_queue_get_config_request_t *
of_queue_get_config_request_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_queue_get_config_request_t *obj;

    obj = of_queue_get_config_request_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_queue_get_config_request.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_queue_get_config_request_init(of_queue_get_config_request_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_QUEUE_GET_CONFIG_REQUEST] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_QUEUE_GET_CONFIG_REQUEST] + of_object_extra_len[version][OF_QUEUE_GET_CONFIG_REQUEST];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_QUEUE_GET_CONFIG_REQUEST;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_queue_get_config_request object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_queue_get_config_request
 */

of_queue_get_config_request_t *
of_queue_get_config_request_new_from_message_(of_message_t msg)
{
    of_queue_get_config_request_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_queue_get_config_request_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_queue_get_config_request_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_queue_get_config_request_t *
of_queue_get_config_request_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_queue_get_config_request_t *obj;

    obj = of_queue_get_config_request_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_queue_stats_reply */

/**
 * \defgroup of_queue_stats_reply of_queue_stats_reply
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_queue_stats_reply_push_wire_values(of_queue_stats_reply_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_QUEUE_STATS_REPLY));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_queue_stats_reply object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_queue_stats_reply
 */

of_queue_stats_reply_t *
of_queue_stats_reply_new_(of_version_t version)
{
    of_queue_stats_reply_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_QUEUE_STATS_REPLY] + of_object_extra_len[version][OF_QUEUE_STATS_REPLY];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_queue_stats_reply_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_queue_stats_reply_init(obj, version, bytes, 0);

    if (of_queue_stats_reply_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_queue_stats_reply_t *
of_queue_stats_reply_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_queue_stats_reply_t *obj;

    obj = of_queue_stats_reply_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_queue_stats_reply.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_queue_stats_reply_init(of_queue_stats_reply_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_QUEUE_STATS_REPLY] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_QUEUE_STATS_REPLY] + of_object_extra_len[version][OF_QUEUE_STATS_REPLY];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_QUEUE_STATS_REPLY;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_queue_stats_reply object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_queue_stats_reply
 */

of_queue_stats_reply_t *
of_queue_stats_reply_new_from_message_(of_message_t msg)
{
    of_queue_stats_reply_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_queue_stats_reply_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_queue_stats_reply_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_queue_stats_reply_t *
of_queue_stats_reply_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_queue_stats_reply_t *obj;

    obj = of_queue_stats_reply_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_queue_stats_request */

/**
 * \defgroup of_queue_stats_request of_queue_stats_request
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_queue_stats_request_push_wire_values(of_queue_stats_request_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_QUEUE_STATS_REQUEST));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_queue_stats_request object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_queue_stats_request
 */

of_queue_stats_request_t *
of_queue_stats_request_new_(of_version_t version)
{
    of_queue_stats_request_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_QUEUE_STATS_REQUEST] + of_object_extra_len[version][OF_QUEUE_STATS_REQUEST];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_queue_stats_request_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_queue_stats_request_init(obj, version, bytes, 0);

    if (of_queue_stats_request_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_queue_stats_request_t *
of_queue_stats_request_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_queue_stats_request_t *obj;

    obj = of_queue_stats_request_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_queue_stats_request.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_queue_stats_request_init(of_queue_stats_request_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_QUEUE_STATS_REQUEST] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_QUEUE_STATS_REQUEST] + of_object_extra_len[version][OF_QUEUE_STATS_REQUEST];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_QUEUE_STATS_REQUEST;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_queue_stats_request object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_queue_stats_request
 */

of_queue_stats_request_t *
of_queue_stats_request_new_from_message_(of_message_t msg)
{
    of_queue_stats_request_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_queue_stats_request_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_queue_stats_request_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_queue_stats_request_t *
of_queue_stats_request_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_queue_stats_request_t *obj;

    obj = of_queue_stats_request_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_role_reply */

/**
 * \defgroup of_role_reply of_role_reply
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_role_reply_push_wire_values(of_role_reply_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_ROLE_REPLY));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_role_reply object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_role_reply
 */

of_role_reply_t *
of_role_reply_new_(of_version_t version)
{
    of_role_reply_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ROLE_REPLY] + of_object_extra_len[version][OF_ROLE_REPLY];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_role_reply_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_role_reply_init(obj, version, bytes, 0);

    if (of_role_reply_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_role_reply_t *
of_role_reply_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_role_reply_t *obj;

    obj = of_role_reply_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_role_reply.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_role_reply_init(of_role_reply_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ROLE_REPLY] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ROLE_REPLY] + of_object_extra_len[version][OF_ROLE_REPLY];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ROLE_REPLY;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_role_reply object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_role_reply
 */

of_role_reply_t *
of_role_reply_new_from_message_(of_message_t msg)
{
    of_role_reply_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_role_reply_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_role_reply_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_role_reply_t *
of_role_reply_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_role_reply_t *obj;

    obj = of_role_reply_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_role_request */

/**
 * \defgroup of_role_request of_role_request
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_role_request_push_wire_values(of_role_request_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_ROLE_REQUEST));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_role_request object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_role_request
 */

of_role_request_t *
of_role_request_new_(of_version_t version)
{
    of_role_request_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ROLE_REQUEST] + of_object_extra_len[version][OF_ROLE_REQUEST];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_role_request_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_role_request_init(obj, version, bytes, 0);

    if (of_role_request_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_role_request_t *
of_role_request_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_role_request_t *obj;

    obj = of_role_request_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_role_request.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_role_request_init(of_role_request_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ROLE_REQUEST] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ROLE_REQUEST] + of_object_extra_len[version][OF_ROLE_REQUEST];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ROLE_REQUEST;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_role_request object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_role_request
 */

of_role_request_t *
of_role_request_new_from_message_(of_message_t msg)
{
    of_role_request_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_role_request_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_role_request_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_role_request_t *
of_role_request_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_role_request_t *obj;

    obj = of_role_request_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_set_config */

/**
 * \defgroup of_set_config of_set_config
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_set_config_push_wire_values(of_set_config_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_SET_CONFIG));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_set_config object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_set_config
 */

of_set_config_t *
of_set_config_new_(of_version_t version)
{
    of_set_config_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_SET_CONFIG] + of_object_extra_len[version][OF_SET_CONFIG];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_set_config_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_set_config_init(obj, version, bytes, 0);

    if (of_set_config_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_set_config_t *
of_set_config_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_set_config_t *obj;

    obj = of_set_config_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_set_config.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_set_config_init(of_set_config_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_SET_CONFIG] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_SET_CONFIG] + of_object_extra_len[version][OF_SET_CONFIG];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_SET_CONFIG;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_set_config object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_set_config
 */

of_set_config_t *
of_set_config_new_from_message_(of_message_t msg)
{
    of_set_config_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_set_config_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_set_config_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_set_config_t *
of_set_config_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_set_config_t *obj;

    obj = of_set_config_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_table_features_stats_reply */

/**
 * \defgroup of_table_features_stats_reply of_table_features_stats_reply
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_table_features_stats_reply_push_wire_values(of_table_features_stats_reply_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_TABLE_FEATURES_STATS_REPLY));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_table_features_stats_reply object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_table_features_stats_reply
 */

of_table_features_stats_reply_t *
of_table_features_stats_reply_new_(of_version_t version)
{
    of_table_features_stats_reply_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_TABLE_FEATURES_STATS_REPLY] + of_object_extra_len[version][OF_TABLE_FEATURES_STATS_REPLY];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_table_features_stats_reply_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_table_features_stats_reply_init(obj, version, bytes, 0);

    if (of_table_features_stats_reply_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_table_features_stats_reply_t *
of_table_features_stats_reply_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_table_features_stats_reply_t *obj;

    obj = of_table_features_stats_reply_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_table_features_stats_reply.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_table_features_stats_reply_init(of_table_features_stats_reply_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_TABLE_FEATURES_STATS_REPLY] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_TABLE_FEATURES_STATS_REPLY] + of_object_extra_len[version][OF_TABLE_FEATURES_STATS_REPLY];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_TABLE_FEATURES_STATS_REPLY;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_table_features_stats_reply object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_table_features_stats_reply
 */

of_table_features_stats_reply_t *
of_table_features_stats_reply_new_from_message_(of_message_t msg)
{
    of_table_features_stats_reply_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_table_features_stats_reply_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_table_features_stats_reply_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_table_features_stats_reply_t *
of_table_features_stats_reply_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_table_features_stats_reply_t *obj;

    obj = of_table_features_stats_reply_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_table_features_stats_request */

/**
 * \defgroup of_table_features_stats_request of_table_features_stats_request
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_table_features_stats_request_push_wire_values(of_table_features_stats_request_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_TABLE_FEATURES_STATS_REQUEST));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_table_features_stats_request object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_table_features_stats_request
 */

of_table_features_stats_request_t *
of_table_features_stats_request_new_(of_version_t version)
{
    of_table_features_stats_request_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_TABLE_FEATURES_STATS_REQUEST] + of_object_extra_len[version][OF_TABLE_FEATURES_STATS_REQUEST];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_table_features_stats_request_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_table_features_stats_request_init(obj, version, bytes, 0);

    if (of_table_features_stats_request_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_table_features_stats_request_t *
of_table_features_stats_request_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_table_features_stats_request_t *obj;

    obj = of_table_features_stats_request_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_table_features_stats_request.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_table_features_stats_request_init(of_table_features_stats_request_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_TABLE_FEATURES_STATS_REQUEST] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_TABLE_FEATURES_STATS_REQUEST] + of_object_extra_len[version][OF_TABLE_FEATURES_STATS_REQUEST];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_TABLE_FEATURES_STATS_REQUEST;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_table_features_stats_request object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_table_features_stats_request
 */

of_table_features_stats_request_t *
of_table_features_stats_request_new_from_message_(of_message_t msg)
{
    of_table_features_stats_request_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_table_features_stats_request_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_table_features_stats_request_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_table_features_stats_request_t *
of_table_features_stats_request_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_table_features_stats_request_t *obj;

    obj = of_table_features_stats_request_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_table_mod */

/**
 * \defgroup of_table_mod of_table_mod
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_table_mod_push_wire_values(of_table_mod_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_TABLE_MOD));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_table_mod object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_table_mod
 */

of_table_mod_t *
of_table_mod_new_(of_version_t version)
{
    of_table_mod_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_TABLE_MOD] + of_object_extra_len[version][OF_TABLE_MOD];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_table_mod_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_table_mod_init(obj, version, bytes, 0);

    if (of_table_mod_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_table_mod_t *
of_table_mod_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_table_mod_t *obj;

    obj = of_table_mod_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_table_mod.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_table_mod_init(of_table_mod_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_TABLE_MOD] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_TABLE_MOD] + of_object_extra_len[version][OF_TABLE_MOD];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_TABLE_MOD;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_table_mod object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_table_mod
 */

of_table_mod_t *
of_table_mod_new_from_message_(of_message_t msg)
{
    of_table_mod_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_table_mod_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_table_mod_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_table_mod_t *
of_table_mod_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_table_mod_t *obj;

    obj = of_table_mod_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_table_stats_reply */

/**
 * \defgroup of_table_stats_reply of_table_stats_reply
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_table_stats_reply_push_wire_values(of_table_stats_reply_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_TABLE_STATS_REPLY));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_table_stats_reply object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_table_stats_reply
 */

of_table_stats_reply_t *
of_table_stats_reply_new_(of_version_t version)
{
    of_table_stats_reply_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_TABLE_STATS_REPLY] + of_object_extra_len[version][OF_TABLE_STATS_REPLY];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_table_stats_reply_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_table_stats_reply_init(obj, version, bytes, 0);

    if (of_table_stats_reply_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_table_stats_reply_t *
of_table_stats_reply_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_table_stats_reply_t *obj;

    obj = of_table_stats_reply_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_table_stats_reply.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_table_stats_reply_init(of_table_stats_reply_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_TABLE_STATS_REPLY] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_TABLE_STATS_REPLY] + of_object_extra_len[version][OF_TABLE_STATS_REPLY];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_TABLE_STATS_REPLY;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_table_stats_reply object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_table_stats_reply
 */

of_table_stats_reply_t *
of_table_stats_reply_new_from_message_(of_message_t msg)
{
    of_table_stats_reply_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_table_stats_reply_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_table_stats_reply_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_table_stats_reply_t *
of_table_stats_reply_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_table_stats_reply_t *obj;

    obj = of_table_stats_reply_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_table_stats_request */

/**
 * \defgroup of_table_stats_request of_table_stats_request
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_table_stats_request_push_wire_values(of_table_stats_request_t *obj)
{

    /* Message obj; push version, length and type to wire */
    of_message_t msg;

    if ((msg = OF_OBJECT_TO_MESSAGE(obj)) != NULL) {
        of_message_version_set(msg, obj->version);
        of_message_length_set(msg, obj->length);
        OF_TRY(of_wire_message_object_id_set(OF_OBJECT_TO_WBUF(obj),
                 OF_TABLE_STATS_REQUEST));
    }

    return OF_ERROR_NONE;
}

/**
 * Create a new of_table_stats_request object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_table_stats_request
 */

of_table_stats_request_t *
of_table_stats_request_new_(of_version_t version)
{
    of_table_stats_request_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_TABLE_STATS_REQUEST] + of_object_extra_len[version][OF_TABLE_STATS_REQUEST];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_table_stats_request_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_table_stats_request_init(obj, version, bytes, 0);

    if (of_table_stats_request_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_table_stats_request_t *
of_table_stats_request_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_table_stats_request_t *obj;

    obj = of_table_stats_request_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_table_stats_request.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_table_stats_request_init(of_table_stats_request_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_TABLE_STATS_REQUEST] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_TABLE_STATS_REQUEST] + of_object_extra_len[version][OF_TABLE_STATS_REQUEST];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_TABLE_STATS_REQUEST;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_object_message_wire_length_get;
    obj->wire_length_set = of_object_message_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Create a new of_table_stats_request object and bind it to an existing message
 *
 * @param msg The message to bind the new object to
 * @return Pointer to the newly create object or NULL on error
 *
 * \ingroup of_table_stats_request
 */

of_table_stats_request_t *
of_table_stats_request_new_from_message_(of_message_t msg)
{
    of_table_stats_request_t *obj = NULL;
    of_version_t version;
    int length;

    if (msg == NULL) return NULL;

    version = of_message_version_get(msg);
    if (!OF_VERSION_OKAY(version)) return NULL;

    length = of_message_length_get(msg);

    if ((obj = (of_table_stats_request_t *)of_object_new(-1)) == NULL) {
        return NULL;
    }

    of_table_stats_request_init(obj, version, 0, 0);

    if ((of_object_buffer_bind((of_object_t *)obj, OF_MESSAGE_TO_BUFFER(msg),
                               length, OF_MESSAGE_FREE_FUNCTION)) < 0) {
       FREE(obj);
       return NULL;
    }
    obj->length = length;
    obj->version = version;

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_table_stats_request_t *
of_table_stats_request_new_from_message_tracking(of_message_t msg,
    const char *file, int line)
{
    of_table_stats_request_t *obj;

    obj = of_table_stats_request_new_from_message_(msg);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/* New operators for of_action */

/**
 * \defgroup of_action of_action
 */

/**
 * Create a new of_action object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action
 */

of_action_t *
of_action_new_(of_version_t version)
{
    of_action_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION] + of_object_extra_len[version][OF_ACTION];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_init(obj, version, bytes, 0);

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_t *
of_action_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_t *obj;

    obj = of_action_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_init(of_action_t *obj_p,
    of_version_t version, int bytes, int clean_wire)
{
    of_action_header_t *obj;

    obj = &obj_p->header;  /* Need instantiable subclass */

    ASSERT(of_object_fixed_len[version][OF_ACTION] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION] + of_object_extra_len[version][OF_ACTION];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_bsn_mirror */

/**
 * \defgroup of_action_bsn_mirror of_action_bsn_mirror
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_bsn_mirror_push_wire_values(of_action_bsn_mirror_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_BSN_MIRROR);

    /* Extended TLV obj; Call specific accessor */
    of_extension_object_id_set(obj, OF_ACTION_BSN_MIRROR);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_bsn_mirror object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_bsn_mirror
 */

of_action_bsn_mirror_t *
of_action_bsn_mirror_new_(of_version_t version)
{
    of_action_bsn_mirror_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_BSN_MIRROR] + of_object_extra_len[version][OF_ACTION_BSN_MIRROR];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_bsn_mirror_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_bsn_mirror_init(obj, version, bytes, 0);

    if (of_action_bsn_mirror_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_bsn_mirror_t *
of_action_bsn_mirror_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_bsn_mirror_t *obj;

    obj = of_action_bsn_mirror_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_bsn_mirror.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_bsn_mirror_init(of_action_bsn_mirror_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_BSN_MIRROR] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_BSN_MIRROR] + of_object_extra_len[version][OF_ACTION_BSN_MIRROR];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_BSN_MIRROR;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_bsn_set_tunnel_dst */

/**
 * \defgroup of_action_bsn_set_tunnel_dst of_action_bsn_set_tunnel_dst
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_bsn_set_tunnel_dst_push_wire_values(of_action_bsn_set_tunnel_dst_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_BSN_SET_TUNNEL_DST);

    /* Extended TLV obj; Call specific accessor */
    of_extension_object_id_set(obj, OF_ACTION_BSN_SET_TUNNEL_DST);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_bsn_set_tunnel_dst object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_bsn_set_tunnel_dst
 */

of_action_bsn_set_tunnel_dst_t *
of_action_bsn_set_tunnel_dst_new_(of_version_t version)
{
    of_action_bsn_set_tunnel_dst_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_BSN_SET_TUNNEL_DST] + of_object_extra_len[version][OF_ACTION_BSN_SET_TUNNEL_DST];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_bsn_set_tunnel_dst_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_bsn_set_tunnel_dst_init(obj, version, bytes, 0);

    if (of_action_bsn_set_tunnel_dst_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_bsn_set_tunnel_dst_t *
of_action_bsn_set_tunnel_dst_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_bsn_set_tunnel_dst_t *obj;

    obj = of_action_bsn_set_tunnel_dst_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_bsn_set_tunnel_dst.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_bsn_set_tunnel_dst_init(of_action_bsn_set_tunnel_dst_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_BSN_SET_TUNNEL_DST] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_BSN_SET_TUNNEL_DST] + of_object_extra_len[version][OF_ACTION_BSN_SET_TUNNEL_DST];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_BSN_SET_TUNNEL_DST;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_copy_ttl_in */

/**
 * \defgroup of_action_copy_ttl_in of_action_copy_ttl_in
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_copy_ttl_in_push_wire_values(of_action_copy_ttl_in_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_COPY_TTL_IN);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_copy_ttl_in object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_copy_ttl_in
 */

of_action_copy_ttl_in_t *
of_action_copy_ttl_in_new_(of_version_t version)
{
    of_action_copy_ttl_in_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_COPY_TTL_IN] + of_object_extra_len[version][OF_ACTION_COPY_TTL_IN];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_copy_ttl_in_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_copy_ttl_in_init(obj, version, bytes, 0);

    if (of_action_copy_ttl_in_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_copy_ttl_in_t *
of_action_copy_ttl_in_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_copy_ttl_in_t *obj;

    obj = of_action_copy_ttl_in_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_copy_ttl_in.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_copy_ttl_in_init(of_action_copy_ttl_in_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_COPY_TTL_IN] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_COPY_TTL_IN] + of_object_extra_len[version][OF_ACTION_COPY_TTL_IN];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_COPY_TTL_IN;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_copy_ttl_out */

/**
 * \defgroup of_action_copy_ttl_out of_action_copy_ttl_out
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_copy_ttl_out_push_wire_values(of_action_copy_ttl_out_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_COPY_TTL_OUT);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_copy_ttl_out object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_copy_ttl_out
 */

of_action_copy_ttl_out_t *
of_action_copy_ttl_out_new_(of_version_t version)
{
    of_action_copy_ttl_out_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_COPY_TTL_OUT] + of_object_extra_len[version][OF_ACTION_COPY_TTL_OUT];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_copy_ttl_out_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_copy_ttl_out_init(obj, version, bytes, 0);

    if (of_action_copy_ttl_out_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_copy_ttl_out_t *
of_action_copy_ttl_out_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_copy_ttl_out_t *obj;

    obj = of_action_copy_ttl_out_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_copy_ttl_out.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_copy_ttl_out_init(of_action_copy_ttl_out_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_COPY_TTL_OUT] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_COPY_TTL_OUT] + of_object_extra_len[version][OF_ACTION_COPY_TTL_OUT];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_COPY_TTL_OUT;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_dec_mpls_ttl */

/**
 * \defgroup of_action_dec_mpls_ttl of_action_dec_mpls_ttl
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_dec_mpls_ttl_push_wire_values(of_action_dec_mpls_ttl_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_DEC_MPLS_TTL);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_dec_mpls_ttl object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_dec_mpls_ttl
 */

of_action_dec_mpls_ttl_t *
of_action_dec_mpls_ttl_new_(of_version_t version)
{
    of_action_dec_mpls_ttl_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_DEC_MPLS_TTL] + of_object_extra_len[version][OF_ACTION_DEC_MPLS_TTL];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_dec_mpls_ttl_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_dec_mpls_ttl_init(obj, version, bytes, 0);

    if (of_action_dec_mpls_ttl_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_dec_mpls_ttl_t *
of_action_dec_mpls_ttl_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_dec_mpls_ttl_t *obj;

    obj = of_action_dec_mpls_ttl_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_dec_mpls_ttl.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_dec_mpls_ttl_init(of_action_dec_mpls_ttl_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_DEC_MPLS_TTL] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_DEC_MPLS_TTL] + of_object_extra_len[version][OF_ACTION_DEC_MPLS_TTL];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_DEC_MPLS_TTL;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_dec_nw_ttl */

/**
 * \defgroup of_action_dec_nw_ttl of_action_dec_nw_ttl
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_dec_nw_ttl_push_wire_values(of_action_dec_nw_ttl_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_DEC_NW_TTL);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_dec_nw_ttl object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_dec_nw_ttl
 */

of_action_dec_nw_ttl_t *
of_action_dec_nw_ttl_new_(of_version_t version)
{
    of_action_dec_nw_ttl_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_DEC_NW_TTL] + of_object_extra_len[version][OF_ACTION_DEC_NW_TTL];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_dec_nw_ttl_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_dec_nw_ttl_init(obj, version, bytes, 0);

    if (of_action_dec_nw_ttl_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_dec_nw_ttl_t *
of_action_dec_nw_ttl_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_dec_nw_ttl_t *obj;

    obj = of_action_dec_nw_ttl_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_dec_nw_ttl.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_dec_nw_ttl_init(of_action_dec_nw_ttl_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_DEC_NW_TTL] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_DEC_NW_TTL] + of_object_extra_len[version][OF_ACTION_DEC_NW_TTL];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_DEC_NW_TTL;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_enqueue */

/**
 * \defgroup of_action_enqueue of_action_enqueue
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_enqueue_push_wire_values(of_action_enqueue_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_ENQUEUE);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_enqueue object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_enqueue
 */

of_action_enqueue_t *
of_action_enqueue_new_(of_version_t version)
{
    of_action_enqueue_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_ENQUEUE] + of_object_extra_len[version][OF_ACTION_ENQUEUE];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_enqueue_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_enqueue_init(obj, version, bytes, 0);

    if (of_action_enqueue_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_enqueue_t *
of_action_enqueue_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_enqueue_t *obj;

    obj = of_action_enqueue_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_enqueue.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_enqueue_init(of_action_enqueue_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_ENQUEUE] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_ENQUEUE] + of_object_extra_len[version][OF_ACTION_ENQUEUE];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_ENQUEUE;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_experimenter */

/**
 * \defgroup of_action_experimenter of_action_experimenter
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_experimenter_push_wire_values(of_action_experimenter_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_EXPERIMENTER);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_experimenter object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_experimenter
 */

of_action_experimenter_t *
of_action_experimenter_new_(of_version_t version)
{
    of_action_experimenter_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_EXPERIMENTER] + of_object_extra_len[version][OF_ACTION_EXPERIMENTER];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_experimenter_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_experimenter_init(obj, version, bytes, 0);

    if (of_action_experimenter_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_experimenter_t *
of_action_experimenter_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_experimenter_t *obj;

    obj = of_action_experimenter_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_experimenter.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_experimenter_init(of_action_experimenter_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_EXPERIMENTER] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_EXPERIMENTER] + of_object_extra_len[version][OF_ACTION_EXPERIMENTER];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_EXPERIMENTER;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_group */

/**
 * \defgroup of_action_group of_action_group
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_group_push_wire_values(of_action_group_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_GROUP);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_group object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_group
 */

of_action_group_t *
of_action_group_new_(of_version_t version)
{
    of_action_group_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_GROUP] + of_object_extra_len[version][OF_ACTION_GROUP];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_group_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_group_init(obj, version, bytes, 0);

    if (of_action_group_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_group_t *
of_action_group_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_group_t *obj;

    obj = of_action_group_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_group.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_group_init(of_action_group_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_GROUP] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_GROUP] + of_object_extra_len[version][OF_ACTION_GROUP];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_GROUP;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_header */

/**
 * \defgroup of_action_header of_action_header
 */

/**
 * Create a new of_action_header object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_header
 */

of_action_header_t *
of_action_header_new_(of_version_t version)
{
    of_action_header_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_HEADER] + of_object_extra_len[version][OF_ACTION_HEADER];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_header_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_header_init(obj, version, bytes, 0);

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_header_t *
of_action_header_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_header_t *obj;

    obj = of_action_header_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_header.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_header_init(of_action_header_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_HEADER] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_HEADER] + of_object_extra_len[version][OF_ACTION_HEADER];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_HEADER;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_id */

/**
 * \defgroup of_action_id of_action_id
 */

/**
 * Create a new of_action_id object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_id
 */

of_action_id_t *
of_action_id_new_(of_version_t version)
{
    of_action_id_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_ID] + of_object_extra_len[version][OF_ACTION_ID];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_id_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_id_init(obj, version, bytes, 0);

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_id_t *
of_action_id_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_id_t *obj;

    obj = of_action_id_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_id.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_id_init(of_action_id_t *obj_p,
    of_version_t version, int bytes, int clean_wire)
{
    of_action_id_header_t *obj;

    obj = &obj_p->header;  /* Need instantiable subclass */

    ASSERT(of_object_fixed_len[version][OF_ACTION_ID] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_ID] + of_object_extra_len[version][OF_ACTION_ID];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_ID;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_id_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_id_bsn_mirror */

/**
 * \defgroup of_action_id_bsn_mirror of_action_id_bsn_mirror
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_id_bsn_mirror_push_wire_values(of_action_id_bsn_mirror_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_ID_BSN_MIRROR);

    /* Extended TLV obj; Call specific accessor */
    of_extension_object_id_set(obj, OF_ACTION_ID_BSN_MIRROR);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_id_bsn_mirror object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_id_bsn_mirror
 */

of_action_id_bsn_mirror_t *
of_action_id_bsn_mirror_new_(of_version_t version)
{
    of_action_id_bsn_mirror_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_ID_BSN_MIRROR] + of_object_extra_len[version][OF_ACTION_ID_BSN_MIRROR];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_id_bsn_mirror_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_id_bsn_mirror_init(obj, version, bytes, 0);

    if (of_action_id_bsn_mirror_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_id_bsn_mirror_t *
of_action_id_bsn_mirror_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_id_bsn_mirror_t *obj;

    obj = of_action_id_bsn_mirror_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_id_bsn_mirror.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_id_bsn_mirror_init(of_action_id_bsn_mirror_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_ID_BSN_MIRROR] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_ID_BSN_MIRROR] + of_object_extra_len[version][OF_ACTION_ID_BSN_MIRROR];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_ID_BSN_MIRROR;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_id_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_id_bsn_set_tunnel_dst */

/**
 * \defgroup of_action_id_bsn_set_tunnel_dst of_action_id_bsn_set_tunnel_dst
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_id_bsn_set_tunnel_dst_push_wire_values(of_action_id_bsn_set_tunnel_dst_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_ID_BSN_SET_TUNNEL_DST);

    /* Extended TLV obj; Call specific accessor */
    of_extension_object_id_set(obj, OF_ACTION_ID_BSN_SET_TUNNEL_DST);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_id_bsn_set_tunnel_dst object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_id_bsn_set_tunnel_dst
 */

of_action_id_bsn_set_tunnel_dst_t *
of_action_id_bsn_set_tunnel_dst_new_(of_version_t version)
{
    of_action_id_bsn_set_tunnel_dst_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_ID_BSN_SET_TUNNEL_DST] + of_object_extra_len[version][OF_ACTION_ID_BSN_SET_TUNNEL_DST];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_id_bsn_set_tunnel_dst_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_id_bsn_set_tunnel_dst_init(obj, version, bytes, 0);

    if (of_action_id_bsn_set_tunnel_dst_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_id_bsn_set_tunnel_dst_t *
of_action_id_bsn_set_tunnel_dst_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_id_bsn_set_tunnel_dst_t *obj;

    obj = of_action_id_bsn_set_tunnel_dst_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_id_bsn_set_tunnel_dst.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_id_bsn_set_tunnel_dst_init(of_action_id_bsn_set_tunnel_dst_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_ID_BSN_SET_TUNNEL_DST] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_ID_BSN_SET_TUNNEL_DST] + of_object_extra_len[version][OF_ACTION_ID_BSN_SET_TUNNEL_DST];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_ID_BSN_SET_TUNNEL_DST;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_id_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_id_copy_ttl_in */

/**
 * \defgroup of_action_id_copy_ttl_in of_action_id_copy_ttl_in
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_id_copy_ttl_in_push_wire_values(of_action_id_copy_ttl_in_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_ID_COPY_TTL_IN);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_id_copy_ttl_in object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_id_copy_ttl_in
 */

of_action_id_copy_ttl_in_t *
of_action_id_copy_ttl_in_new_(of_version_t version)
{
    of_action_id_copy_ttl_in_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_ID_COPY_TTL_IN] + of_object_extra_len[version][OF_ACTION_ID_COPY_TTL_IN];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_id_copy_ttl_in_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_id_copy_ttl_in_init(obj, version, bytes, 0);

    if (of_action_id_copy_ttl_in_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_id_copy_ttl_in_t *
of_action_id_copy_ttl_in_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_id_copy_ttl_in_t *obj;

    obj = of_action_id_copy_ttl_in_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_id_copy_ttl_in.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_id_copy_ttl_in_init(of_action_id_copy_ttl_in_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_ID_COPY_TTL_IN] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_ID_COPY_TTL_IN] + of_object_extra_len[version][OF_ACTION_ID_COPY_TTL_IN];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_ID_COPY_TTL_IN;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_id_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_id_copy_ttl_out */

/**
 * \defgroup of_action_id_copy_ttl_out of_action_id_copy_ttl_out
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_id_copy_ttl_out_push_wire_values(of_action_id_copy_ttl_out_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_ID_COPY_TTL_OUT);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_id_copy_ttl_out object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_id_copy_ttl_out
 */

of_action_id_copy_ttl_out_t *
of_action_id_copy_ttl_out_new_(of_version_t version)
{
    of_action_id_copy_ttl_out_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_ID_COPY_TTL_OUT] + of_object_extra_len[version][OF_ACTION_ID_COPY_TTL_OUT];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_id_copy_ttl_out_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_id_copy_ttl_out_init(obj, version, bytes, 0);

    if (of_action_id_copy_ttl_out_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_id_copy_ttl_out_t *
of_action_id_copy_ttl_out_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_id_copy_ttl_out_t *obj;

    obj = of_action_id_copy_ttl_out_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_id_copy_ttl_out.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_id_copy_ttl_out_init(of_action_id_copy_ttl_out_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_ID_COPY_TTL_OUT] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_ID_COPY_TTL_OUT] + of_object_extra_len[version][OF_ACTION_ID_COPY_TTL_OUT];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_ID_COPY_TTL_OUT;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_id_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_id_dec_mpls_ttl */

/**
 * \defgroup of_action_id_dec_mpls_ttl of_action_id_dec_mpls_ttl
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_id_dec_mpls_ttl_push_wire_values(of_action_id_dec_mpls_ttl_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_ID_DEC_MPLS_TTL);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_id_dec_mpls_ttl object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_id_dec_mpls_ttl
 */

of_action_id_dec_mpls_ttl_t *
of_action_id_dec_mpls_ttl_new_(of_version_t version)
{
    of_action_id_dec_mpls_ttl_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_ID_DEC_MPLS_TTL] + of_object_extra_len[version][OF_ACTION_ID_DEC_MPLS_TTL];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_id_dec_mpls_ttl_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_id_dec_mpls_ttl_init(obj, version, bytes, 0);

    if (of_action_id_dec_mpls_ttl_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_id_dec_mpls_ttl_t *
of_action_id_dec_mpls_ttl_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_id_dec_mpls_ttl_t *obj;

    obj = of_action_id_dec_mpls_ttl_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_id_dec_mpls_ttl.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_id_dec_mpls_ttl_init(of_action_id_dec_mpls_ttl_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_ID_DEC_MPLS_TTL] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_ID_DEC_MPLS_TTL] + of_object_extra_len[version][OF_ACTION_ID_DEC_MPLS_TTL];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_ID_DEC_MPLS_TTL;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_id_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_id_dec_nw_ttl */

/**
 * \defgroup of_action_id_dec_nw_ttl of_action_id_dec_nw_ttl
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_id_dec_nw_ttl_push_wire_values(of_action_id_dec_nw_ttl_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_ID_DEC_NW_TTL);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_id_dec_nw_ttl object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_id_dec_nw_ttl
 */

of_action_id_dec_nw_ttl_t *
of_action_id_dec_nw_ttl_new_(of_version_t version)
{
    of_action_id_dec_nw_ttl_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_ID_DEC_NW_TTL] + of_object_extra_len[version][OF_ACTION_ID_DEC_NW_TTL];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_id_dec_nw_ttl_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_id_dec_nw_ttl_init(obj, version, bytes, 0);

    if (of_action_id_dec_nw_ttl_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_id_dec_nw_ttl_t *
of_action_id_dec_nw_ttl_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_id_dec_nw_ttl_t *obj;

    obj = of_action_id_dec_nw_ttl_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_id_dec_nw_ttl.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_id_dec_nw_ttl_init(of_action_id_dec_nw_ttl_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_ID_DEC_NW_TTL] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_ID_DEC_NW_TTL] + of_object_extra_len[version][OF_ACTION_ID_DEC_NW_TTL];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_ID_DEC_NW_TTL;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_id_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_id_experimenter */

/**
 * \defgroup of_action_id_experimenter of_action_id_experimenter
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_id_experimenter_push_wire_values(of_action_id_experimenter_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_ID_EXPERIMENTER);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_id_experimenter object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_id_experimenter
 */

of_action_id_experimenter_t *
of_action_id_experimenter_new_(of_version_t version)
{
    of_action_id_experimenter_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_ID_EXPERIMENTER] + of_object_extra_len[version][OF_ACTION_ID_EXPERIMENTER];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_id_experimenter_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_id_experimenter_init(obj, version, bytes, 0);

    if (of_action_id_experimenter_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_id_experimenter_t *
of_action_id_experimenter_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_id_experimenter_t *obj;

    obj = of_action_id_experimenter_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_id_experimenter.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_id_experimenter_init(of_action_id_experimenter_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_ID_EXPERIMENTER] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_ID_EXPERIMENTER] + of_object_extra_len[version][OF_ACTION_ID_EXPERIMENTER];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_ID_EXPERIMENTER;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_id_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_id_group */

/**
 * \defgroup of_action_id_group of_action_id_group
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_id_group_push_wire_values(of_action_id_group_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_ID_GROUP);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_id_group object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_id_group
 */

of_action_id_group_t *
of_action_id_group_new_(of_version_t version)
{
    of_action_id_group_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_ID_GROUP] + of_object_extra_len[version][OF_ACTION_ID_GROUP];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_id_group_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_id_group_init(obj, version, bytes, 0);

    if (of_action_id_group_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_id_group_t *
of_action_id_group_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_id_group_t *obj;

    obj = of_action_id_group_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_id_group.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_id_group_init(of_action_id_group_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_ID_GROUP] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_ID_GROUP] + of_object_extra_len[version][OF_ACTION_ID_GROUP];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_ID_GROUP;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_id_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_id_header */

/**
 * \defgroup of_action_id_header of_action_id_header
 */

/**
 * Create a new of_action_id_header object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_id_header
 */

of_action_id_header_t *
of_action_id_header_new_(of_version_t version)
{
    of_action_id_header_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_ID_HEADER] + of_object_extra_len[version][OF_ACTION_ID_HEADER];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_id_header_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_id_header_init(obj, version, bytes, 0);

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_id_header_t *
of_action_id_header_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_id_header_t *obj;

    obj = of_action_id_header_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_id_header.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_id_header_init(of_action_id_header_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_ID_HEADER] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_ID_HEADER] + of_object_extra_len[version][OF_ACTION_ID_HEADER];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_ID_HEADER;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_id_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_id_nicira_dec_ttl */

/**
 * \defgroup of_action_id_nicira_dec_ttl of_action_id_nicira_dec_ttl
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_id_nicira_dec_ttl_push_wire_values(of_action_id_nicira_dec_ttl_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_ID_NICIRA_DEC_TTL);

    /* Extended TLV obj; Call specific accessor */
    of_extension_object_id_set(obj, OF_ACTION_ID_NICIRA_DEC_TTL);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_id_nicira_dec_ttl object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_id_nicira_dec_ttl
 */

of_action_id_nicira_dec_ttl_t *
of_action_id_nicira_dec_ttl_new_(of_version_t version)
{
    of_action_id_nicira_dec_ttl_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_ID_NICIRA_DEC_TTL] + of_object_extra_len[version][OF_ACTION_ID_NICIRA_DEC_TTL];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_id_nicira_dec_ttl_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_id_nicira_dec_ttl_init(obj, version, bytes, 0);

    if (of_action_id_nicira_dec_ttl_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_id_nicira_dec_ttl_t *
of_action_id_nicira_dec_ttl_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_id_nicira_dec_ttl_t *obj;

    obj = of_action_id_nicira_dec_ttl_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_id_nicira_dec_ttl.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_id_nicira_dec_ttl_init(of_action_id_nicira_dec_ttl_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_ID_NICIRA_DEC_TTL] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_ID_NICIRA_DEC_TTL] + of_object_extra_len[version][OF_ACTION_ID_NICIRA_DEC_TTL];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_ID_NICIRA_DEC_TTL;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_id_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_id_output */

/**
 * \defgroup of_action_id_output of_action_id_output
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_id_output_push_wire_values(of_action_id_output_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_ID_OUTPUT);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_id_output object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_id_output
 */

of_action_id_output_t *
of_action_id_output_new_(of_version_t version)
{
    of_action_id_output_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_ID_OUTPUT] + of_object_extra_len[version][OF_ACTION_ID_OUTPUT];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_id_output_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_id_output_init(obj, version, bytes, 0);

    if (of_action_id_output_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_id_output_t *
of_action_id_output_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_id_output_t *obj;

    obj = of_action_id_output_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_id_output.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_id_output_init(of_action_id_output_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_ID_OUTPUT] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_ID_OUTPUT] + of_object_extra_len[version][OF_ACTION_ID_OUTPUT];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_ID_OUTPUT;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_id_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_id_pop_mpls */

/**
 * \defgroup of_action_id_pop_mpls of_action_id_pop_mpls
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_id_pop_mpls_push_wire_values(of_action_id_pop_mpls_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_ID_POP_MPLS);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_id_pop_mpls object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_id_pop_mpls
 */

of_action_id_pop_mpls_t *
of_action_id_pop_mpls_new_(of_version_t version)
{
    of_action_id_pop_mpls_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_ID_POP_MPLS] + of_object_extra_len[version][OF_ACTION_ID_POP_MPLS];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_id_pop_mpls_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_id_pop_mpls_init(obj, version, bytes, 0);

    if (of_action_id_pop_mpls_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_id_pop_mpls_t *
of_action_id_pop_mpls_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_id_pop_mpls_t *obj;

    obj = of_action_id_pop_mpls_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_id_pop_mpls.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_id_pop_mpls_init(of_action_id_pop_mpls_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_ID_POP_MPLS] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_ID_POP_MPLS] + of_object_extra_len[version][OF_ACTION_ID_POP_MPLS];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_ID_POP_MPLS;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_id_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_id_pop_pbb */

/**
 * \defgroup of_action_id_pop_pbb of_action_id_pop_pbb
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_id_pop_pbb_push_wire_values(of_action_id_pop_pbb_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_ID_POP_PBB);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_id_pop_pbb object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_id_pop_pbb
 */

of_action_id_pop_pbb_t *
of_action_id_pop_pbb_new_(of_version_t version)
{
    of_action_id_pop_pbb_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_ID_POP_PBB] + of_object_extra_len[version][OF_ACTION_ID_POP_PBB];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_id_pop_pbb_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_id_pop_pbb_init(obj, version, bytes, 0);

    if (of_action_id_pop_pbb_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_id_pop_pbb_t *
of_action_id_pop_pbb_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_id_pop_pbb_t *obj;

    obj = of_action_id_pop_pbb_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_id_pop_pbb.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_id_pop_pbb_init(of_action_id_pop_pbb_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_ID_POP_PBB] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_ID_POP_PBB] + of_object_extra_len[version][OF_ACTION_ID_POP_PBB];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_ID_POP_PBB;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_id_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_id_pop_vlan */

/**
 * \defgroup of_action_id_pop_vlan of_action_id_pop_vlan
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_id_pop_vlan_push_wire_values(of_action_id_pop_vlan_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_ID_POP_VLAN);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_id_pop_vlan object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_id_pop_vlan
 */

of_action_id_pop_vlan_t *
of_action_id_pop_vlan_new_(of_version_t version)
{
    of_action_id_pop_vlan_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_ID_POP_VLAN] + of_object_extra_len[version][OF_ACTION_ID_POP_VLAN];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_id_pop_vlan_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_id_pop_vlan_init(obj, version, bytes, 0);

    if (of_action_id_pop_vlan_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_id_pop_vlan_t *
of_action_id_pop_vlan_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_id_pop_vlan_t *obj;

    obj = of_action_id_pop_vlan_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_id_pop_vlan.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_id_pop_vlan_init(of_action_id_pop_vlan_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_ID_POP_VLAN] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_ID_POP_VLAN] + of_object_extra_len[version][OF_ACTION_ID_POP_VLAN];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_ID_POP_VLAN;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_id_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_id_push_mpls */

/**
 * \defgroup of_action_id_push_mpls of_action_id_push_mpls
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_id_push_mpls_push_wire_values(of_action_id_push_mpls_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_ID_PUSH_MPLS);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_id_push_mpls object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_id_push_mpls
 */

of_action_id_push_mpls_t *
of_action_id_push_mpls_new_(of_version_t version)
{
    of_action_id_push_mpls_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_ID_PUSH_MPLS] + of_object_extra_len[version][OF_ACTION_ID_PUSH_MPLS];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_id_push_mpls_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_id_push_mpls_init(obj, version, bytes, 0);

    if (of_action_id_push_mpls_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_id_push_mpls_t *
of_action_id_push_mpls_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_id_push_mpls_t *obj;

    obj = of_action_id_push_mpls_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_id_push_mpls.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_id_push_mpls_init(of_action_id_push_mpls_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_ID_PUSH_MPLS] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_ID_PUSH_MPLS] + of_object_extra_len[version][OF_ACTION_ID_PUSH_MPLS];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_ID_PUSH_MPLS;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_id_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_id_push_pbb */

/**
 * \defgroup of_action_id_push_pbb of_action_id_push_pbb
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_id_push_pbb_push_wire_values(of_action_id_push_pbb_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_ID_PUSH_PBB);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_id_push_pbb object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_id_push_pbb
 */

of_action_id_push_pbb_t *
of_action_id_push_pbb_new_(of_version_t version)
{
    of_action_id_push_pbb_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_ID_PUSH_PBB] + of_object_extra_len[version][OF_ACTION_ID_PUSH_PBB];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_id_push_pbb_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_id_push_pbb_init(obj, version, bytes, 0);

    if (of_action_id_push_pbb_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_id_push_pbb_t *
of_action_id_push_pbb_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_id_push_pbb_t *obj;

    obj = of_action_id_push_pbb_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_id_push_pbb.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_id_push_pbb_init(of_action_id_push_pbb_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_ID_PUSH_PBB] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_ID_PUSH_PBB] + of_object_extra_len[version][OF_ACTION_ID_PUSH_PBB];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_ID_PUSH_PBB;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_id_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_id_push_vlan */

/**
 * \defgroup of_action_id_push_vlan of_action_id_push_vlan
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_id_push_vlan_push_wire_values(of_action_id_push_vlan_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_ID_PUSH_VLAN);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_id_push_vlan object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_id_push_vlan
 */

of_action_id_push_vlan_t *
of_action_id_push_vlan_new_(of_version_t version)
{
    of_action_id_push_vlan_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_ID_PUSH_VLAN] + of_object_extra_len[version][OF_ACTION_ID_PUSH_VLAN];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_id_push_vlan_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_id_push_vlan_init(obj, version, bytes, 0);

    if (of_action_id_push_vlan_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_id_push_vlan_t *
of_action_id_push_vlan_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_id_push_vlan_t *obj;

    obj = of_action_id_push_vlan_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_id_push_vlan.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_id_push_vlan_init(of_action_id_push_vlan_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_ID_PUSH_VLAN] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_ID_PUSH_VLAN] + of_object_extra_len[version][OF_ACTION_ID_PUSH_VLAN];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_ID_PUSH_VLAN;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_id_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_id_set_field */

/**
 * \defgroup of_action_id_set_field of_action_id_set_field
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_id_set_field_push_wire_values(of_action_id_set_field_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_ID_SET_FIELD);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_id_set_field object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_id_set_field
 */

of_action_id_set_field_t *
of_action_id_set_field_new_(of_version_t version)
{
    of_action_id_set_field_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_ID_SET_FIELD] + of_object_extra_len[version][OF_ACTION_ID_SET_FIELD];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_id_set_field_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_id_set_field_init(obj, version, bytes, 0);

    if (of_action_id_set_field_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_id_set_field_t *
of_action_id_set_field_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_id_set_field_t *obj;

    obj = of_action_id_set_field_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_id_set_field.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_id_set_field_init(of_action_id_set_field_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_ID_SET_FIELD] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_ID_SET_FIELD] + of_object_extra_len[version][OF_ACTION_ID_SET_FIELD];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_ID_SET_FIELD;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_id_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_id_set_mpls_ttl */

/**
 * \defgroup of_action_id_set_mpls_ttl of_action_id_set_mpls_ttl
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_id_set_mpls_ttl_push_wire_values(of_action_id_set_mpls_ttl_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_ID_SET_MPLS_TTL);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_id_set_mpls_ttl object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_id_set_mpls_ttl
 */

of_action_id_set_mpls_ttl_t *
of_action_id_set_mpls_ttl_new_(of_version_t version)
{
    of_action_id_set_mpls_ttl_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_ID_SET_MPLS_TTL] + of_object_extra_len[version][OF_ACTION_ID_SET_MPLS_TTL];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_id_set_mpls_ttl_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_id_set_mpls_ttl_init(obj, version, bytes, 0);

    if (of_action_id_set_mpls_ttl_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_id_set_mpls_ttl_t *
of_action_id_set_mpls_ttl_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_id_set_mpls_ttl_t *obj;

    obj = of_action_id_set_mpls_ttl_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_id_set_mpls_ttl.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_id_set_mpls_ttl_init(of_action_id_set_mpls_ttl_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_ID_SET_MPLS_TTL] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_ID_SET_MPLS_TTL] + of_object_extra_len[version][OF_ACTION_ID_SET_MPLS_TTL];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_ID_SET_MPLS_TTL;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_id_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_id_set_nw_ttl */

/**
 * \defgroup of_action_id_set_nw_ttl of_action_id_set_nw_ttl
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_id_set_nw_ttl_push_wire_values(of_action_id_set_nw_ttl_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_ID_SET_NW_TTL);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_id_set_nw_ttl object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_id_set_nw_ttl
 */

of_action_id_set_nw_ttl_t *
of_action_id_set_nw_ttl_new_(of_version_t version)
{
    of_action_id_set_nw_ttl_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_ID_SET_NW_TTL] + of_object_extra_len[version][OF_ACTION_ID_SET_NW_TTL];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_id_set_nw_ttl_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_id_set_nw_ttl_init(obj, version, bytes, 0);

    if (of_action_id_set_nw_ttl_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_id_set_nw_ttl_t *
of_action_id_set_nw_ttl_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_id_set_nw_ttl_t *obj;

    obj = of_action_id_set_nw_ttl_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_id_set_nw_ttl.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_id_set_nw_ttl_init(of_action_id_set_nw_ttl_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_ID_SET_NW_TTL] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_ID_SET_NW_TTL] + of_object_extra_len[version][OF_ACTION_ID_SET_NW_TTL];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_ID_SET_NW_TTL;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_id_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_id_set_queue */

/**
 * \defgroup of_action_id_set_queue of_action_id_set_queue
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_id_set_queue_push_wire_values(of_action_id_set_queue_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_ID_SET_QUEUE);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_id_set_queue object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_id_set_queue
 */

of_action_id_set_queue_t *
of_action_id_set_queue_new_(of_version_t version)
{
    of_action_id_set_queue_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_ID_SET_QUEUE] + of_object_extra_len[version][OF_ACTION_ID_SET_QUEUE];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_id_set_queue_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_id_set_queue_init(obj, version, bytes, 0);

    if (of_action_id_set_queue_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_id_set_queue_t *
of_action_id_set_queue_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_id_set_queue_t *obj;

    obj = of_action_id_set_queue_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_id_set_queue.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_id_set_queue_init(of_action_id_set_queue_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_ID_SET_QUEUE] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_ID_SET_QUEUE] + of_object_extra_len[version][OF_ACTION_ID_SET_QUEUE];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_ID_SET_QUEUE;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_id_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_nicira_dec_ttl */

/**
 * \defgroup of_action_nicira_dec_ttl of_action_nicira_dec_ttl
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_nicira_dec_ttl_push_wire_values(of_action_nicira_dec_ttl_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_NICIRA_DEC_TTL);

    /* Extended TLV obj; Call specific accessor */
    of_extension_object_id_set(obj, OF_ACTION_NICIRA_DEC_TTL);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_nicira_dec_ttl object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_nicira_dec_ttl
 */

of_action_nicira_dec_ttl_t *
of_action_nicira_dec_ttl_new_(of_version_t version)
{
    of_action_nicira_dec_ttl_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_NICIRA_DEC_TTL] + of_object_extra_len[version][OF_ACTION_NICIRA_DEC_TTL];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_nicira_dec_ttl_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_nicira_dec_ttl_init(obj, version, bytes, 0);

    if (of_action_nicira_dec_ttl_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_nicira_dec_ttl_t *
of_action_nicira_dec_ttl_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_nicira_dec_ttl_t *obj;

    obj = of_action_nicira_dec_ttl_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_nicira_dec_ttl.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_nicira_dec_ttl_init(of_action_nicira_dec_ttl_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_NICIRA_DEC_TTL] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_NICIRA_DEC_TTL] + of_object_extra_len[version][OF_ACTION_NICIRA_DEC_TTL];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_NICIRA_DEC_TTL;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_output */

/**
 * \defgroup of_action_output of_action_output
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_output_push_wire_values(of_action_output_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_OUTPUT);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_output object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_output
 */

of_action_output_t *
of_action_output_new_(of_version_t version)
{
    of_action_output_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_OUTPUT] + of_object_extra_len[version][OF_ACTION_OUTPUT];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_output_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_output_init(obj, version, bytes, 0);

    if (of_action_output_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_output_t *
of_action_output_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_output_t *obj;

    obj = of_action_output_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_output.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_output_init(of_action_output_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_OUTPUT] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_OUTPUT] + of_object_extra_len[version][OF_ACTION_OUTPUT];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_OUTPUT;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_pop_mpls */

/**
 * \defgroup of_action_pop_mpls of_action_pop_mpls
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_pop_mpls_push_wire_values(of_action_pop_mpls_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_POP_MPLS);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_pop_mpls object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_pop_mpls
 */

of_action_pop_mpls_t *
of_action_pop_mpls_new_(of_version_t version)
{
    of_action_pop_mpls_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_POP_MPLS] + of_object_extra_len[version][OF_ACTION_POP_MPLS];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_pop_mpls_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_pop_mpls_init(obj, version, bytes, 0);

    if (of_action_pop_mpls_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_pop_mpls_t *
of_action_pop_mpls_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_pop_mpls_t *obj;

    obj = of_action_pop_mpls_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_pop_mpls.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_pop_mpls_init(of_action_pop_mpls_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_POP_MPLS] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_POP_MPLS] + of_object_extra_len[version][OF_ACTION_POP_MPLS];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_POP_MPLS;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_pop_pbb */

/**
 * \defgroup of_action_pop_pbb of_action_pop_pbb
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_pop_pbb_push_wire_values(of_action_pop_pbb_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_POP_PBB);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_pop_pbb object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_pop_pbb
 */

of_action_pop_pbb_t *
of_action_pop_pbb_new_(of_version_t version)
{
    of_action_pop_pbb_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_POP_PBB] + of_object_extra_len[version][OF_ACTION_POP_PBB];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_pop_pbb_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_pop_pbb_init(obj, version, bytes, 0);

    if (of_action_pop_pbb_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_pop_pbb_t *
of_action_pop_pbb_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_pop_pbb_t *obj;

    obj = of_action_pop_pbb_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_pop_pbb.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_pop_pbb_init(of_action_pop_pbb_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_POP_PBB] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_POP_PBB] + of_object_extra_len[version][OF_ACTION_POP_PBB];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_POP_PBB;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_pop_vlan */

/**
 * \defgroup of_action_pop_vlan of_action_pop_vlan
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_pop_vlan_push_wire_values(of_action_pop_vlan_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_POP_VLAN);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_pop_vlan object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_pop_vlan
 */

of_action_pop_vlan_t *
of_action_pop_vlan_new_(of_version_t version)
{
    of_action_pop_vlan_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_POP_VLAN] + of_object_extra_len[version][OF_ACTION_POP_VLAN];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_pop_vlan_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_pop_vlan_init(obj, version, bytes, 0);

    if (of_action_pop_vlan_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_pop_vlan_t *
of_action_pop_vlan_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_pop_vlan_t *obj;

    obj = of_action_pop_vlan_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_pop_vlan.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_pop_vlan_init(of_action_pop_vlan_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_POP_VLAN] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_POP_VLAN] + of_object_extra_len[version][OF_ACTION_POP_VLAN];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_POP_VLAN;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_push_mpls */

/**
 * \defgroup of_action_push_mpls of_action_push_mpls
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_push_mpls_push_wire_values(of_action_push_mpls_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_PUSH_MPLS);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_push_mpls object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_push_mpls
 */

of_action_push_mpls_t *
of_action_push_mpls_new_(of_version_t version)
{
    of_action_push_mpls_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_PUSH_MPLS] + of_object_extra_len[version][OF_ACTION_PUSH_MPLS];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_push_mpls_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_push_mpls_init(obj, version, bytes, 0);

    if (of_action_push_mpls_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_push_mpls_t *
of_action_push_mpls_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_push_mpls_t *obj;

    obj = of_action_push_mpls_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_push_mpls.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_push_mpls_init(of_action_push_mpls_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_PUSH_MPLS] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_PUSH_MPLS] + of_object_extra_len[version][OF_ACTION_PUSH_MPLS];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_PUSH_MPLS;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_push_pbb */

/**
 * \defgroup of_action_push_pbb of_action_push_pbb
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_push_pbb_push_wire_values(of_action_push_pbb_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_PUSH_PBB);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_push_pbb object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_push_pbb
 */

of_action_push_pbb_t *
of_action_push_pbb_new_(of_version_t version)
{
    of_action_push_pbb_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_PUSH_PBB] + of_object_extra_len[version][OF_ACTION_PUSH_PBB];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_push_pbb_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_push_pbb_init(obj, version, bytes, 0);

    if (of_action_push_pbb_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_push_pbb_t *
of_action_push_pbb_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_push_pbb_t *obj;

    obj = of_action_push_pbb_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_push_pbb.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_push_pbb_init(of_action_push_pbb_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_PUSH_PBB] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_PUSH_PBB] + of_object_extra_len[version][OF_ACTION_PUSH_PBB];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_PUSH_PBB;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_push_vlan */

/**
 * \defgroup of_action_push_vlan of_action_push_vlan
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_push_vlan_push_wire_values(of_action_push_vlan_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_PUSH_VLAN);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_push_vlan object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_push_vlan
 */

of_action_push_vlan_t *
of_action_push_vlan_new_(of_version_t version)
{
    of_action_push_vlan_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_PUSH_VLAN] + of_object_extra_len[version][OF_ACTION_PUSH_VLAN];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_push_vlan_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_push_vlan_init(obj, version, bytes, 0);

    if (of_action_push_vlan_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_push_vlan_t *
of_action_push_vlan_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_push_vlan_t *obj;

    obj = of_action_push_vlan_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_push_vlan.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_push_vlan_init(of_action_push_vlan_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_PUSH_VLAN] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_PUSH_VLAN] + of_object_extra_len[version][OF_ACTION_PUSH_VLAN];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_PUSH_VLAN;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_set_dl_dst */

/**
 * \defgroup of_action_set_dl_dst of_action_set_dl_dst
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_set_dl_dst_push_wire_values(of_action_set_dl_dst_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_SET_DL_DST);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_set_dl_dst object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_set_dl_dst
 */

of_action_set_dl_dst_t *
of_action_set_dl_dst_new_(of_version_t version)
{
    of_action_set_dl_dst_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_SET_DL_DST] + of_object_extra_len[version][OF_ACTION_SET_DL_DST];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_set_dl_dst_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_set_dl_dst_init(obj, version, bytes, 0);

    if (of_action_set_dl_dst_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_set_dl_dst_t *
of_action_set_dl_dst_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_set_dl_dst_t *obj;

    obj = of_action_set_dl_dst_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_set_dl_dst.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_set_dl_dst_init(of_action_set_dl_dst_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_SET_DL_DST] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_SET_DL_DST] + of_object_extra_len[version][OF_ACTION_SET_DL_DST];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_SET_DL_DST;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_set_dl_src */

/**
 * \defgroup of_action_set_dl_src of_action_set_dl_src
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_set_dl_src_push_wire_values(of_action_set_dl_src_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_SET_DL_SRC);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_set_dl_src object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_set_dl_src
 */

of_action_set_dl_src_t *
of_action_set_dl_src_new_(of_version_t version)
{
    of_action_set_dl_src_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_SET_DL_SRC] + of_object_extra_len[version][OF_ACTION_SET_DL_SRC];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_set_dl_src_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_set_dl_src_init(obj, version, bytes, 0);

    if (of_action_set_dl_src_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_set_dl_src_t *
of_action_set_dl_src_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_set_dl_src_t *obj;

    obj = of_action_set_dl_src_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_set_dl_src.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_set_dl_src_init(of_action_set_dl_src_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_SET_DL_SRC] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_SET_DL_SRC] + of_object_extra_len[version][OF_ACTION_SET_DL_SRC];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_SET_DL_SRC;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_set_field */

/**
 * \defgroup of_action_set_field of_action_set_field
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_set_field_push_wire_values(of_action_set_field_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_SET_FIELD);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_set_field object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_set_field
 */

of_action_set_field_t *
of_action_set_field_new_(of_version_t version)
{
    of_action_set_field_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_SET_FIELD] + of_object_extra_len[version][OF_ACTION_SET_FIELD];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_set_field_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_set_field_init(obj, version, bytes, 0);

    if (of_action_set_field_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_set_field_t *
of_action_set_field_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_set_field_t *obj;

    obj = of_action_set_field_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_set_field.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_set_field_init(of_action_set_field_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_SET_FIELD] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_SET_FIELD] + of_object_extra_len[version][OF_ACTION_SET_FIELD];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_SET_FIELD;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_set_mpls_label */

/**
 * \defgroup of_action_set_mpls_label of_action_set_mpls_label
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_set_mpls_label_push_wire_values(of_action_set_mpls_label_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_SET_MPLS_LABEL);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_set_mpls_label object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_set_mpls_label
 */

of_action_set_mpls_label_t *
of_action_set_mpls_label_new_(of_version_t version)
{
    of_action_set_mpls_label_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_SET_MPLS_LABEL] + of_object_extra_len[version][OF_ACTION_SET_MPLS_LABEL];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_set_mpls_label_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_set_mpls_label_init(obj, version, bytes, 0);

    if (of_action_set_mpls_label_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_set_mpls_label_t *
of_action_set_mpls_label_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_set_mpls_label_t *obj;

    obj = of_action_set_mpls_label_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_set_mpls_label.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_set_mpls_label_init(of_action_set_mpls_label_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_SET_MPLS_LABEL] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_SET_MPLS_LABEL] + of_object_extra_len[version][OF_ACTION_SET_MPLS_LABEL];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_SET_MPLS_LABEL;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_set_mpls_tc */

/**
 * \defgroup of_action_set_mpls_tc of_action_set_mpls_tc
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_set_mpls_tc_push_wire_values(of_action_set_mpls_tc_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_SET_MPLS_TC);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_set_mpls_tc object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_set_mpls_tc
 */

of_action_set_mpls_tc_t *
of_action_set_mpls_tc_new_(of_version_t version)
{
    of_action_set_mpls_tc_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_SET_MPLS_TC] + of_object_extra_len[version][OF_ACTION_SET_MPLS_TC];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_set_mpls_tc_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_set_mpls_tc_init(obj, version, bytes, 0);

    if (of_action_set_mpls_tc_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_set_mpls_tc_t *
of_action_set_mpls_tc_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_set_mpls_tc_t *obj;

    obj = of_action_set_mpls_tc_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_set_mpls_tc.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_set_mpls_tc_init(of_action_set_mpls_tc_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_SET_MPLS_TC] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_SET_MPLS_TC] + of_object_extra_len[version][OF_ACTION_SET_MPLS_TC];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_SET_MPLS_TC;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_set_mpls_ttl */

/**
 * \defgroup of_action_set_mpls_ttl of_action_set_mpls_ttl
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_set_mpls_ttl_push_wire_values(of_action_set_mpls_ttl_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_SET_MPLS_TTL);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_set_mpls_ttl object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_set_mpls_ttl
 */

of_action_set_mpls_ttl_t *
of_action_set_mpls_ttl_new_(of_version_t version)
{
    of_action_set_mpls_ttl_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_SET_MPLS_TTL] + of_object_extra_len[version][OF_ACTION_SET_MPLS_TTL];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_set_mpls_ttl_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_set_mpls_ttl_init(obj, version, bytes, 0);

    if (of_action_set_mpls_ttl_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_set_mpls_ttl_t *
of_action_set_mpls_ttl_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_set_mpls_ttl_t *obj;

    obj = of_action_set_mpls_ttl_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_set_mpls_ttl.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_set_mpls_ttl_init(of_action_set_mpls_ttl_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_SET_MPLS_TTL] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_SET_MPLS_TTL] + of_object_extra_len[version][OF_ACTION_SET_MPLS_TTL];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_SET_MPLS_TTL;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_set_nw_dst */

/**
 * \defgroup of_action_set_nw_dst of_action_set_nw_dst
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_set_nw_dst_push_wire_values(of_action_set_nw_dst_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_SET_NW_DST);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_set_nw_dst object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_set_nw_dst
 */

of_action_set_nw_dst_t *
of_action_set_nw_dst_new_(of_version_t version)
{
    of_action_set_nw_dst_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_SET_NW_DST] + of_object_extra_len[version][OF_ACTION_SET_NW_DST];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_set_nw_dst_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_set_nw_dst_init(obj, version, bytes, 0);

    if (of_action_set_nw_dst_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_set_nw_dst_t *
of_action_set_nw_dst_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_set_nw_dst_t *obj;

    obj = of_action_set_nw_dst_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_set_nw_dst.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_set_nw_dst_init(of_action_set_nw_dst_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_SET_NW_DST] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_SET_NW_DST] + of_object_extra_len[version][OF_ACTION_SET_NW_DST];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_SET_NW_DST;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_set_nw_ecn */

/**
 * \defgroup of_action_set_nw_ecn of_action_set_nw_ecn
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_set_nw_ecn_push_wire_values(of_action_set_nw_ecn_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_SET_NW_ECN);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_set_nw_ecn object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_set_nw_ecn
 */

of_action_set_nw_ecn_t *
of_action_set_nw_ecn_new_(of_version_t version)
{
    of_action_set_nw_ecn_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_SET_NW_ECN] + of_object_extra_len[version][OF_ACTION_SET_NW_ECN];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_set_nw_ecn_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_set_nw_ecn_init(obj, version, bytes, 0);

    if (of_action_set_nw_ecn_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_set_nw_ecn_t *
of_action_set_nw_ecn_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_set_nw_ecn_t *obj;

    obj = of_action_set_nw_ecn_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_set_nw_ecn.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_set_nw_ecn_init(of_action_set_nw_ecn_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_SET_NW_ECN] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_SET_NW_ECN] + of_object_extra_len[version][OF_ACTION_SET_NW_ECN];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_SET_NW_ECN;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_set_nw_src */

/**
 * \defgroup of_action_set_nw_src of_action_set_nw_src
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_set_nw_src_push_wire_values(of_action_set_nw_src_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_SET_NW_SRC);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_set_nw_src object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_set_nw_src
 */

of_action_set_nw_src_t *
of_action_set_nw_src_new_(of_version_t version)
{
    of_action_set_nw_src_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_SET_NW_SRC] + of_object_extra_len[version][OF_ACTION_SET_NW_SRC];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_set_nw_src_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_set_nw_src_init(obj, version, bytes, 0);

    if (of_action_set_nw_src_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_set_nw_src_t *
of_action_set_nw_src_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_set_nw_src_t *obj;

    obj = of_action_set_nw_src_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_set_nw_src.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_set_nw_src_init(of_action_set_nw_src_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_SET_NW_SRC] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_SET_NW_SRC] + of_object_extra_len[version][OF_ACTION_SET_NW_SRC];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_SET_NW_SRC;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_set_nw_tos */

/**
 * \defgroup of_action_set_nw_tos of_action_set_nw_tos
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_set_nw_tos_push_wire_values(of_action_set_nw_tos_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_SET_NW_TOS);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_set_nw_tos object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_set_nw_tos
 */

of_action_set_nw_tos_t *
of_action_set_nw_tos_new_(of_version_t version)
{
    of_action_set_nw_tos_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_SET_NW_TOS] + of_object_extra_len[version][OF_ACTION_SET_NW_TOS];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_set_nw_tos_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_set_nw_tos_init(obj, version, bytes, 0);

    if (of_action_set_nw_tos_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_set_nw_tos_t *
of_action_set_nw_tos_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_set_nw_tos_t *obj;

    obj = of_action_set_nw_tos_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_set_nw_tos.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_set_nw_tos_init(of_action_set_nw_tos_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_SET_NW_TOS] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_SET_NW_TOS] + of_object_extra_len[version][OF_ACTION_SET_NW_TOS];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_SET_NW_TOS;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_set_nw_ttl */

/**
 * \defgroup of_action_set_nw_ttl of_action_set_nw_ttl
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_set_nw_ttl_push_wire_values(of_action_set_nw_ttl_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_SET_NW_TTL);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_set_nw_ttl object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_set_nw_ttl
 */

of_action_set_nw_ttl_t *
of_action_set_nw_ttl_new_(of_version_t version)
{
    of_action_set_nw_ttl_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_SET_NW_TTL] + of_object_extra_len[version][OF_ACTION_SET_NW_TTL];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_set_nw_ttl_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_set_nw_ttl_init(obj, version, bytes, 0);

    if (of_action_set_nw_ttl_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_set_nw_ttl_t *
of_action_set_nw_ttl_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_set_nw_ttl_t *obj;

    obj = of_action_set_nw_ttl_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_set_nw_ttl.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_set_nw_ttl_init(of_action_set_nw_ttl_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_SET_NW_TTL] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_SET_NW_TTL] + of_object_extra_len[version][OF_ACTION_SET_NW_TTL];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_SET_NW_TTL;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_set_queue */

/**
 * \defgroup of_action_set_queue of_action_set_queue
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_set_queue_push_wire_values(of_action_set_queue_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_SET_QUEUE);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_set_queue object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_set_queue
 */

of_action_set_queue_t *
of_action_set_queue_new_(of_version_t version)
{
    of_action_set_queue_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_SET_QUEUE] + of_object_extra_len[version][OF_ACTION_SET_QUEUE];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_set_queue_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_set_queue_init(obj, version, bytes, 0);

    if (of_action_set_queue_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_set_queue_t *
of_action_set_queue_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_set_queue_t *obj;

    obj = of_action_set_queue_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_set_queue.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_set_queue_init(of_action_set_queue_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_SET_QUEUE] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_SET_QUEUE] + of_object_extra_len[version][OF_ACTION_SET_QUEUE];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_SET_QUEUE;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_set_tp_dst */

/**
 * \defgroup of_action_set_tp_dst of_action_set_tp_dst
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_set_tp_dst_push_wire_values(of_action_set_tp_dst_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_SET_TP_DST);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_set_tp_dst object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_set_tp_dst
 */

of_action_set_tp_dst_t *
of_action_set_tp_dst_new_(of_version_t version)
{
    of_action_set_tp_dst_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_SET_TP_DST] + of_object_extra_len[version][OF_ACTION_SET_TP_DST];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_set_tp_dst_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_set_tp_dst_init(obj, version, bytes, 0);

    if (of_action_set_tp_dst_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_set_tp_dst_t *
of_action_set_tp_dst_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_set_tp_dst_t *obj;

    obj = of_action_set_tp_dst_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_set_tp_dst.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_set_tp_dst_init(of_action_set_tp_dst_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_SET_TP_DST] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_SET_TP_DST] + of_object_extra_len[version][OF_ACTION_SET_TP_DST];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_SET_TP_DST;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_set_tp_src */

/**
 * \defgroup of_action_set_tp_src of_action_set_tp_src
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_set_tp_src_push_wire_values(of_action_set_tp_src_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_SET_TP_SRC);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_set_tp_src object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_set_tp_src
 */

of_action_set_tp_src_t *
of_action_set_tp_src_new_(of_version_t version)
{
    of_action_set_tp_src_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_SET_TP_SRC] + of_object_extra_len[version][OF_ACTION_SET_TP_SRC];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_set_tp_src_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_set_tp_src_init(obj, version, bytes, 0);

    if (of_action_set_tp_src_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_set_tp_src_t *
of_action_set_tp_src_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_set_tp_src_t *obj;

    obj = of_action_set_tp_src_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_set_tp_src.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_set_tp_src_init(of_action_set_tp_src_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_SET_TP_SRC] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_SET_TP_SRC] + of_object_extra_len[version][OF_ACTION_SET_TP_SRC];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_SET_TP_SRC;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_set_vlan_pcp */

/**
 * \defgroup of_action_set_vlan_pcp of_action_set_vlan_pcp
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_set_vlan_pcp_push_wire_values(of_action_set_vlan_pcp_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_SET_VLAN_PCP);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_set_vlan_pcp object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_set_vlan_pcp
 */

of_action_set_vlan_pcp_t *
of_action_set_vlan_pcp_new_(of_version_t version)
{
    of_action_set_vlan_pcp_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_SET_VLAN_PCP] + of_object_extra_len[version][OF_ACTION_SET_VLAN_PCP];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_set_vlan_pcp_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_set_vlan_pcp_init(obj, version, bytes, 0);

    if (of_action_set_vlan_pcp_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_set_vlan_pcp_t *
of_action_set_vlan_pcp_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_set_vlan_pcp_t *obj;

    obj = of_action_set_vlan_pcp_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_set_vlan_pcp.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_set_vlan_pcp_init(of_action_set_vlan_pcp_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_SET_VLAN_PCP] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_SET_VLAN_PCP] + of_object_extra_len[version][OF_ACTION_SET_VLAN_PCP];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_SET_VLAN_PCP;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_set_vlan_vid */

/**
 * \defgroup of_action_set_vlan_vid of_action_set_vlan_vid
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_set_vlan_vid_push_wire_values(of_action_set_vlan_vid_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_SET_VLAN_VID);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_set_vlan_vid object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_set_vlan_vid
 */

of_action_set_vlan_vid_t *
of_action_set_vlan_vid_new_(of_version_t version)
{
    of_action_set_vlan_vid_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_SET_VLAN_VID] + of_object_extra_len[version][OF_ACTION_SET_VLAN_VID];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_set_vlan_vid_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_set_vlan_vid_init(obj, version, bytes, 0);

    if (of_action_set_vlan_vid_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_set_vlan_vid_t *
of_action_set_vlan_vid_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_set_vlan_vid_t *obj;

    obj = of_action_set_vlan_vid_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_set_vlan_vid.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_set_vlan_vid_init(of_action_set_vlan_vid_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_SET_VLAN_VID] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_SET_VLAN_VID] + of_object_extra_len[version][OF_ACTION_SET_VLAN_VID];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_SET_VLAN_VID;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_action_strip_vlan */

/**
 * \defgroup of_action_strip_vlan of_action_strip_vlan
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_action_strip_vlan_push_wire_values(of_action_strip_vlan_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_ACTION_STRIP_VLAN);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_action_strip_vlan object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_action_strip_vlan
 */

of_action_strip_vlan_t *
of_action_strip_vlan_new_(of_version_t version)
{
    of_action_strip_vlan_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_ACTION_STRIP_VLAN] + of_object_extra_len[version][OF_ACTION_STRIP_VLAN];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_action_strip_vlan_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_action_strip_vlan_init(obj, version, bytes, 0);

    if (of_action_strip_vlan_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_action_strip_vlan_t *
of_action_strip_vlan_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_action_strip_vlan_t *obj;

    obj = of_action_strip_vlan_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_action_strip_vlan.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_action_strip_vlan_init(of_action_strip_vlan_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_ACTION_STRIP_VLAN] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_ACTION_STRIP_VLAN] + of_object_extra_len[version][OF_ACTION_STRIP_VLAN];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_ACTION_STRIP_VLAN;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_action_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_bsn_interface */

/**
 * \defgroup of_bsn_interface of_bsn_interface
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_bsn_interface_push_wire_values(of_bsn_interface_t *obj)
{

    return OF_ERROR_NONE;
}

/**
 * Create a new of_bsn_interface object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_bsn_interface
 */

of_bsn_interface_t *
of_bsn_interface_new_(of_version_t version)
{
    of_bsn_interface_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_BSN_INTERFACE] + of_object_extra_len[version][OF_BSN_INTERFACE];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_bsn_interface_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_bsn_interface_init(obj, version, bytes, 0);

    if (of_bsn_interface_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_interface_t *
of_bsn_interface_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_bsn_interface_t *obj;

    obj = of_bsn_interface_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_bsn_interface.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_bsn_interface_init(of_bsn_interface_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_BSN_INTERFACE] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_BSN_INTERFACE] + of_object_extra_len[version][OF_BSN_INTERFACE];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_BSN_INTERFACE;

    /* Set up the object's function pointers */

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_bsn_vport */

/**
 * \defgroup of_bsn_vport of_bsn_vport
 */

/**
 * Create a new of_bsn_vport object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_bsn_vport
 */

of_bsn_vport_t *
of_bsn_vport_new_(of_version_t version)
{
    of_bsn_vport_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_BSN_VPORT] + of_object_extra_len[version][OF_BSN_VPORT];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_bsn_vport_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_bsn_vport_init(obj, version, bytes, 0);

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_vport_t *
of_bsn_vport_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_bsn_vport_t *obj;

    obj = of_bsn_vport_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_bsn_vport.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_bsn_vport_init(of_bsn_vport_t *obj_p,
    of_version_t version, int bytes, int clean_wire)
{
    of_bsn_vport_header_t *obj;

    obj = &obj_p->header;  /* Need instantiable subclass */

    ASSERT(of_object_fixed_len[version][OF_BSN_VPORT] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_BSN_VPORT] + of_object_extra_len[version][OF_BSN_VPORT];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_BSN_VPORT;

    /* Set up the object's function pointers */

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_bsn_vport_header */

/**
 * \defgroup of_bsn_vport_header of_bsn_vport_header
 */

/**
 * Create a new of_bsn_vport_header object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_bsn_vport_header
 */

of_bsn_vport_header_t *
of_bsn_vport_header_new_(of_version_t version)
{
    of_bsn_vport_header_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_BSN_VPORT_HEADER] + of_object_extra_len[version][OF_BSN_VPORT_HEADER];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_bsn_vport_header_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_bsn_vport_header_init(obj, version, bytes, 0);

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_vport_header_t *
of_bsn_vport_header_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_bsn_vport_header_t *obj;

    obj = of_bsn_vport_header_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_bsn_vport_header.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_bsn_vport_header_init(of_bsn_vport_header_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_BSN_VPORT_HEADER] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_BSN_VPORT_HEADER] + of_object_extra_len[version][OF_BSN_VPORT_HEADER];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_BSN_VPORT_HEADER;

    /* Set up the object's function pointers */

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_bsn_vport_q_in_q */

/**
 * \defgroup of_bsn_vport_q_in_q of_bsn_vport_q_in_q
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_bsn_vport_q_in_q_push_wire_values(of_bsn_vport_q_in_q_t *obj)
{

    return OF_ERROR_NONE;
}

/**
 * Create a new of_bsn_vport_q_in_q object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_bsn_vport_q_in_q
 */

of_bsn_vport_q_in_q_t *
of_bsn_vport_q_in_q_new_(of_version_t version)
{
    of_bsn_vport_q_in_q_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_BSN_VPORT_Q_IN_Q] + of_object_extra_len[version][OF_BSN_VPORT_Q_IN_Q];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_bsn_vport_q_in_q_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_bsn_vport_q_in_q_init(obj, version, bytes, 0);

    if (of_bsn_vport_q_in_q_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bsn_vport_q_in_q_t *
of_bsn_vport_q_in_q_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_bsn_vport_q_in_q_t *obj;

    obj = of_bsn_vport_q_in_q_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_bsn_vport_q_in_q.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_bsn_vport_q_in_q_init(of_bsn_vport_q_in_q_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_BSN_VPORT_Q_IN_Q] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_BSN_VPORT_Q_IN_Q] + of_object_extra_len[version][OF_BSN_VPORT_Q_IN_Q];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_BSN_VPORT_Q_IN_Q;

    /* Set up the object's function pointers */

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_bucket */

/**
 * \defgroup of_bucket of_bucket
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_bucket_push_wire_values(of_bucket_t *obj)
{

    obj->wire_length_set((of_object_t *)obj, obj->length);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_bucket object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_bucket
 */

of_bucket_t *
of_bucket_new_(of_version_t version)
{
    of_bucket_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_BUCKET] + of_object_extra_len[version][OF_BUCKET];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_bucket_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_bucket_init(obj, version, bytes, 0);

    if (of_bucket_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bucket_t *
of_bucket_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_bucket_t *obj;

    obj = of_bucket_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_bucket.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_bucket_init(of_bucket_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_BUCKET] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_BUCKET] + of_object_extra_len[version][OF_BUCKET];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_BUCKET;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_u16_len_wire_length_get;
    obj->wire_length_set = of_u16_len_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_bucket_counter */

/**
 * \defgroup of_bucket_counter of_bucket_counter
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_bucket_counter_push_wire_values(of_bucket_counter_t *obj)
{

    return OF_ERROR_NONE;
}

/**
 * Create a new of_bucket_counter object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_bucket_counter
 */

of_bucket_counter_t *
of_bucket_counter_new_(of_version_t version)
{
    of_bucket_counter_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_BUCKET_COUNTER] + of_object_extra_len[version][OF_BUCKET_COUNTER];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_bucket_counter_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_bucket_counter_init(obj, version, bytes, 0);

    if (of_bucket_counter_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_bucket_counter_t *
of_bucket_counter_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_bucket_counter_t *obj;

    obj = of_bucket_counter_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_bucket_counter.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_bucket_counter_init(of_bucket_counter_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_BUCKET_COUNTER] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_BUCKET_COUNTER] + of_object_extra_len[version][OF_BUCKET_COUNTER];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_BUCKET_COUNTER;

    /* Set up the object's function pointers */

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_experimenter_multipart_header */

/**
 * \defgroup of_experimenter_multipart_header of_experimenter_multipart_header
 */

/**
 * Create a new of_experimenter_multipart_header object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_experimenter_multipart_header
 */

of_experimenter_multipart_header_t *
of_experimenter_multipart_header_new_(of_version_t version)
{
    of_experimenter_multipart_header_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_EXPERIMENTER_MULTIPART_HEADER] + of_object_extra_len[version][OF_EXPERIMENTER_MULTIPART_HEADER];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_experimenter_multipart_header_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_experimenter_multipart_header_init(obj, version, bytes, 0);

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_experimenter_multipart_header_t *
of_experimenter_multipart_header_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_experimenter_multipart_header_t *obj;

    obj = of_experimenter_multipart_header_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_experimenter_multipart_header.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_experimenter_multipart_header_init(of_experimenter_multipart_header_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_EXPERIMENTER_MULTIPART_HEADER] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_EXPERIMENTER_MULTIPART_HEADER] + of_object_extra_len[version][OF_EXPERIMENTER_MULTIPART_HEADER];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_EXPERIMENTER_MULTIPART_HEADER;

    /* Set up the object's function pointers */

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_flow_stats_entry */

/**
 * \defgroup of_flow_stats_entry of_flow_stats_entry
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_flow_stats_entry_push_wire_values(of_flow_stats_entry_t *obj)
{

    obj->wire_length_set((of_object_t *)obj, obj->length);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_flow_stats_entry object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_flow_stats_entry
 */

of_flow_stats_entry_t *
of_flow_stats_entry_new_(of_version_t version)
{
    of_flow_stats_entry_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_FLOW_STATS_ENTRY] + of_object_extra_len[version][OF_FLOW_STATS_ENTRY];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_flow_stats_entry_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_flow_stats_entry_init(obj, version, bytes, 0);

    if (of_flow_stats_entry_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    /* Initialize match TLV for 1.2 */
    /* FIXME: Check 1.3 below */
    if ((version == OF_VERSION_1_2) || (version == OF_VERSION_1_3)) {
        of_object_u16_set((of_object_t *)obj, 48 + 2, 4);
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_flow_stats_entry_t *
of_flow_stats_entry_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_flow_stats_entry_t *obj;

    obj = of_flow_stats_entry_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_flow_stats_entry.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_flow_stats_entry_init(of_flow_stats_entry_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_FLOW_STATS_ENTRY] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_FLOW_STATS_ENTRY] + of_object_extra_len[version][OF_FLOW_STATS_ENTRY];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_FLOW_STATS_ENTRY;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_u16_len_wire_length_get;
    obj->wire_length_set = of_u16_len_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_group_desc_stats_entry */

/**
 * \defgroup of_group_desc_stats_entry of_group_desc_stats_entry
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_group_desc_stats_entry_push_wire_values(of_group_desc_stats_entry_t *obj)
{

    obj->wire_length_set((of_object_t *)obj, obj->length);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_group_desc_stats_entry object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_group_desc_stats_entry
 */

of_group_desc_stats_entry_t *
of_group_desc_stats_entry_new_(of_version_t version)
{
    of_group_desc_stats_entry_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_GROUP_DESC_STATS_ENTRY] + of_object_extra_len[version][OF_GROUP_DESC_STATS_ENTRY];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_group_desc_stats_entry_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_group_desc_stats_entry_init(obj, version, bytes, 0);

    if (of_group_desc_stats_entry_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_group_desc_stats_entry_t *
of_group_desc_stats_entry_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_group_desc_stats_entry_t *obj;

    obj = of_group_desc_stats_entry_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_group_desc_stats_entry.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_group_desc_stats_entry_init(of_group_desc_stats_entry_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_GROUP_DESC_STATS_ENTRY] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_GROUP_DESC_STATS_ENTRY] + of_object_extra_len[version][OF_GROUP_DESC_STATS_ENTRY];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_GROUP_DESC_STATS_ENTRY;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_u16_len_wire_length_get;
    obj->wire_length_set = of_u16_len_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_group_stats_entry */

/**
 * \defgroup of_group_stats_entry of_group_stats_entry
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_group_stats_entry_push_wire_values(of_group_stats_entry_t *obj)
{

    obj->wire_length_set((of_object_t *)obj, obj->length);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_group_stats_entry object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_group_stats_entry
 */

of_group_stats_entry_t *
of_group_stats_entry_new_(of_version_t version)
{
    of_group_stats_entry_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_GROUP_STATS_ENTRY] + of_object_extra_len[version][OF_GROUP_STATS_ENTRY];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_group_stats_entry_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_group_stats_entry_init(obj, version, bytes, 0);

    if (of_group_stats_entry_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_group_stats_entry_t *
of_group_stats_entry_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_group_stats_entry_t *obj;

    obj = of_group_stats_entry_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_group_stats_entry.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_group_stats_entry_init(of_group_stats_entry_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_GROUP_STATS_ENTRY] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_GROUP_STATS_ENTRY] + of_object_extra_len[version][OF_GROUP_STATS_ENTRY];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_GROUP_STATS_ENTRY;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_u16_len_wire_length_get;
    obj->wire_length_set = of_u16_len_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_header */

/**
 * \defgroup of_header of_header
 */

/**
 * Create a new of_header object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_header
 */

of_header_t *
of_header_new_(of_version_t version)
{
    of_header_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_HEADER] + of_object_extra_len[version][OF_HEADER];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_header_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_header_init(obj, version, bytes, 0);

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_header_t *
of_header_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_header_t *obj;

    obj = of_header_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_header.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_header_init(of_header_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_HEADER] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_HEADER] + of_object_extra_len[version][OF_HEADER];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_HEADER;

    /* Set up the object's function pointers */

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_hello_elem */

/**
 * \defgroup of_hello_elem of_hello_elem
 */

/**
 * Create a new of_hello_elem object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_hello_elem
 */

of_hello_elem_t *
of_hello_elem_new_(of_version_t version)
{
    of_hello_elem_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_HELLO_ELEM] + of_object_extra_len[version][OF_HELLO_ELEM];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_hello_elem_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_hello_elem_init(obj, version, bytes, 0);

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_hello_elem_t *
of_hello_elem_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_hello_elem_t *obj;

    obj = of_hello_elem_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_hello_elem.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_hello_elem_init(of_hello_elem_t *obj_p,
    of_version_t version, int bytes, int clean_wire)
{
    of_hello_elem_header_t *obj;

    obj = &obj_p->header;  /* Need instantiable subclass */

    ASSERT(of_object_fixed_len[version][OF_HELLO_ELEM] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_HELLO_ELEM] + of_object_extra_len[version][OF_HELLO_ELEM];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_HELLO_ELEM;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_hello_elem_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_hello_elem_header */

/**
 * \defgroup of_hello_elem_header of_hello_elem_header
 */

/**
 * Create a new of_hello_elem_header object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_hello_elem_header
 */

of_hello_elem_header_t *
of_hello_elem_header_new_(of_version_t version)
{
    of_hello_elem_header_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_HELLO_ELEM_HEADER] + of_object_extra_len[version][OF_HELLO_ELEM_HEADER];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_hello_elem_header_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_hello_elem_header_init(obj, version, bytes, 0);

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_hello_elem_header_t *
of_hello_elem_header_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_hello_elem_header_t *obj;

    obj = of_hello_elem_header_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_hello_elem_header.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_hello_elem_header_init(of_hello_elem_header_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_HELLO_ELEM_HEADER] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_HELLO_ELEM_HEADER] + of_object_extra_len[version][OF_HELLO_ELEM_HEADER];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_HELLO_ELEM_HEADER;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_hello_elem_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_hello_elem_versionbitmap */

/**
 * \defgroup of_hello_elem_versionbitmap of_hello_elem_versionbitmap
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_hello_elem_versionbitmap_push_wire_values(of_hello_elem_versionbitmap_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_HELLO_ELEM_VERSIONBITMAP);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_hello_elem_versionbitmap object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_hello_elem_versionbitmap
 */

of_hello_elem_versionbitmap_t *
of_hello_elem_versionbitmap_new_(of_version_t version)
{
    of_hello_elem_versionbitmap_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_HELLO_ELEM_VERSIONBITMAP] + of_object_extra_len[version][OF_HELLO_ELEM_VERSIONBITMAP];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_hello_elem_versionbitmap_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_hello_elem_versionbitmap_init(obj, version, bytes, 0);

    if (of_hello_elem_versionbitmap_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_hello_elem_versionbitmap_t *
of_hello_elem_versionbitmap_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_hello_elem_versionbitmap_t *obj;

    obj = of_hello_elem_versionbitmap_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_hello_elem_versionbitmap.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_hello_elem_versionbitmap_init(of_hello_elem_versionbitmap_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_HELLO_ELEM_VERSIONBITMAP] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_HELLO_ELEM_VERSIONBITMAP] + of_object_extra_len[version][OF_HELLO_ELEM_VERSIONBITMAP];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_HELLO_ELEM_VERSIONBITMAP;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_hello_elem_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_instruction */

/**
 * \defgroup of_instruction of_instruction
 */

/**
 * Create a new of_instruction object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_instruction
 */

of_instruction_t *
of_instruction_new_(of_version_t version)
{
    of_instruction_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_INSTRUCTION] + of_object_extra_len[version][OF_INSTRUCTION];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_instruction_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_instruction_init(obj, version, bytes, 0);

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_instruction_t *
of_instruction_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_instruction_t *obj;

    obj = of_instruction_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_instruction.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_instruction_init(of_instruction_t *obj_p,
    of_version_t version, int bytes, int clean_wire)
{
    of_instruction_header_t *obj;

    obj = &obj_p->header;  /* Need instantiable subclass */

    ASSERT(of_object_fixed_len[version][OF_INSTRUCTION] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_INSTRUCTION] + of_object_extra_len[version][OF_INSTRUCTION];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_INSTRUCTION;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_instruction_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_instruction_apply_actions */

/**
 * \defgroup of_instruction_apply_actions of_instruction_apply_actions
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_instruction_apply_actions_push_wire_values(of_instruction_apply_actions_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_INSTRUCTION_APPLY_ACTIONS);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_instruction_apply_actions object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_instruction_apply_actions
 */

of_instruction_apply_actions_t *
of_instruction_apply_actions_new_(of_version_t version)
{
    of_instruction_apply_actions_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_INSTRUCTION_APPLY_ACTIONS] + of_object_extra_len[version][OF_INSTRUCTION_APPLY_ACTIONS];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_instruction_apply_actions_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_instruction_apply_actions_init(obj, version, bytes, 0);

    if (of_instruction_apply_actions_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_instruction_apply_actions_t *
of_instruction_apply_actions_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_instruction_apply_actions_t *obj;

    obj = of_instruction_apply_actions_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_instruction_apply_actions.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_instruction_apply_actions_init(of_instruction_apply_actions_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_INSTRUCTION_APPLY_ACTIONS] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_INSTRUCTION_APPLY_ACTIONS] + of_object_extra_len[version][OF_INSTRUCTION_APPLY_ACTIONS];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_INSTRUCTION_APPLY_ACTIONS;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_instruction_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_instruction_clear_actions */

/**
 * \defgroup of_instruction_clear_actions of_instruction_clear_actions
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_instruction_clear_actions_push_wire_values(of_instruction_clear_actions_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_INSTRUCTION_CLEAR_ACTIONS);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_instruction_clear_actions object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_instruction_clear_actions
 */

of_instruction_clear_actions_t *
of_instruction_clear_actions_new_(of_version_t version)
{
    of_instruction_clear_actions_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_INSTRUCTION_CLEAR_ACTIONS] + of_object_extra_len[version][OF_INSTRUCTION_CLEAR_ACTIONS];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_instruction_clear_actions_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_instruction_clear_actions_init(obj, version, bytes, 0);

    if (of_instruction_clear_actions_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_instruction_clear_actions_t *
of_instruction_clear_actions_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_instruction_clear_actions_t *obj;

    obj = of_instruction_clear_actions_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_instruction_clear_actions.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_instruction_clear_actions_init(of_instruction_clear_actions_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_INSTRUCTION_CLEAR_ACTIONS] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_INSTRUCTION_CLEAR_ACTIONS] + of_object_extra_len[version][OF_INSTRUCTION_CLEAR_ACTIONS];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_INSTRUCTION_CLEAR_ACTIONS;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_instruction_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_instruction_experimenter */

/**
 * \defgroup of_instruction_experimenter of_instruction_experimenter
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_instruction_experimenter_push_wire_values(of_instruction_experimenter_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_INSTRUCTION_EXPERIMENTER);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_instruction_experimenter object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_instruction_experimenter
 */

of_instruction_experimenter_t *
of_instruction_experimenter_new_(of_version_t version)
{
    of_instruction_experimenter_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_INSTRUCTION_EXPERIMENTER] + of_object_extra_len[version][OF_INSTRUCTION_EXPERIMENTER];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_instruction_experimenter_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_instruction_experimenter_init(obj, version, bytes, 0);

    if (of_instruction_experimenter_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_instruction_experimenter_t *
of_instruction_experimenter_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_instruction_experimenter_t *obj;

    obj = of_instruction_experimenter_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_instruction_experimenter.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_instruction_experimenter_init(of_instruction_experimenter_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_INSTRUCTION_EXPERIMENTER] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_INSTRUCTION_EXPERIMENTER] + of_object_extra_len[version][OF_INSTRUCTION_EXPERIMENTER];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_INSTRUCTION_EXPERIMENTER;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_instruction_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_instruction_goto_table */

/**
 * \defgroup of_instruction_goto_table of_instruction_goto_table
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_instruction_goto_table_push_wire_values(of_instruction_goto_table_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_INSTRUCTION_GOTO_TABLE);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_instruction_goto_table object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_instruction_goto_table
 */

of_instruction_goto_table_t *
of_instruction_goto_table_new_(of_version_t version)
{
    of_instruction_goto_table_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_INSTRUCTION_GOTO_TABLE] + of_object_extra_len[version][OF_INSTRUCTION_GOTO_TABLE];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_instruction_goto_table_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_instruction_goto_table_init(obj, version, bytes, 0);

    if (of_instruction_goto_table_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_instruction_goto_table_t *
of_instruction_goto_table_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_instruction_goto_table_t *obj;

    obj = of_instruction_goto_table_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_instruction_goto_table.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_instruction_goto_table_init(of_instruction_goto_table_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_INSTRUCTION_GOTO_TABLE] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_INSTRUCTION_GOTO_TABLE] + of_object_extra_len[version][OF_INSTRUCTION_GOTO_TABLE];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_INSTRUCTION_GOTO_TABLE;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_instruction_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_instruction_header */

/**
 * \defgroup of_instruction_header of_instruction_header
 */

/**
 * Create a new of_instruction_header object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_instruction_header
 */

of_instruction_header_t *
of_instruction_header_new_(of_version_t version)
{
    of_instruction_header_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_INSTRUCTION_HEADER] + of_object_extra_len[version][OF_INSTRUCTION_HEADER];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_instruction_header_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_instruction_header_init(obj, version, bytes, 0);

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_instruction_header_t *
of_instruction_header_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_instruction_header_t *obj;

    obj = of_instruction_header_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_instruction_header.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_instruction_header_init(of_instruction_header_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_INSTRUCTION_HEADER] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_INSTRUCTION_HEADER] + of_object_extra_len[version][OF_INSTRUCTION_HEADER];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_INSTRUCTION_HEADER;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_instruction_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_instruction_meter */

/**
 * \defgroup of_instruction_meter of_instruction_meter
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_instruction_meter_push_wire_values(of_instruction_meter_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_INSTRUCTION_METER);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_instruction_meter object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_instruction_meter
 */

of_instruction_meter_t *
of_instruction_meter_new_(of_version_t version)
{
    of_instruction_meter_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_INSTRUCTION_METER] + of_object_extra_len[version][OF_INSTRUCTION_METER];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_instruction_meter_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_instruction_meter_init(obj, version, bytes, 0);

    if (of_instruction_meter_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_instruction_meter_t *
of_instruction_meter_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_instruction_meter_t *obj;

    obj = of_instruction_meter_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_instruction_meter.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_instruction_meter_init(of_instruction_meter_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_INSTRUCTION_METER] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_INSTRUCTION_METER] + of_object_extra_len[version][OF_INSTRUCTION_METER];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_INSTRUCTION_METER;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_instruction_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_instruction_write_actions */

/**
 * \defgroup of_instruction_write_actions of_instruction_write_actions
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_instruction_write_actions_push_wire_values(of_instruction_write_actions_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_INSTRUCTION_WRITE_ACTIONS);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_instruction_write_actions object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_instruction_write_actions
 */

of_instruction_write_actions_t *
of_instruction_write_actions_new_(of_version_t version)
{
    of_instruction_write_actions_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_INSTRUCTION_WRITE_ACTIONS] + of_object_extra_len[version][OF_INSTRUCTION_WRITE_ACTIONS];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_instruction_write_actions_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_instruction_write_actions_init(obj, version, bytes, 0);

    if (of_instruction_write_actions_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_instruction_write_actions_t *
of_instruction_write_actions_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_instruction_write_actions_t *obj;

    obj = of_instruction_write_actions_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_instruction_write_actions.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_instruction_write_actions_init(of_instruction_write_actions_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_INSTRUCTION_WRITE_ACTIONS] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_INSTRUCTION_WRITE_ACTIONS] + of_object_extra_len[version][OF_INSTRUCTION_WRITE_ACTIONS];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_INSTRUCTION_WRITE_ACTIONS;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_instruction_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_instruction_write_metadata */

/**
 * \defgroup of_instruction_write_metadata of_instruction_write_metadata
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_instruction_write_metadata_push_wire_values(of_instruction_write_metadata_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_INSTRUCTION_WRITE_METADATA);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_instruction_write_metadata object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_instruction_write_metadata
 */

of_instruction_write_metadata_t *
of_instruction_write_metadata_new_(of_version_t version)
{
    of_instruction_write_metadata_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_INSTRUCTION_WRITE_METADATA] + of_object_extra_len[version][OF_INSTRUCTION_WRITE_METADATA];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_instruction_write_metadata_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_instruction_write_metadata_init(obj, version, bytes, 0);

    if (of_instruction_write_metadata_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_instruction_write_metadata_t *
of_instruction_write_metadata_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_instruction_write_metadata_t *obj;

    obj = of_instruction_write_metadata_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_instruction_write_metadata.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_instruction_write_metadata_init(of_instruction_write_metadata_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_INSTRUCTION_WRITE_METADATA] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_INSTRUCTION_WRITE_METADATA] + of_object_extra_len[version][OF_INSTRUCTION_WRITE_METADATA];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_INSTRUCTION_WRITE_METADATA;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_instruction_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_match_v1 */

/**
 * \defgroup of_match_v1 of_match_v1
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_match_v1_push_wire_values(of_match_v1_t *obj)
{

    return OF_ERROR_NONE;
}

/**
 * Create a new of_match_v1 object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_match_v1
 */

of_match_v1_t *
of_match_v1_new_(of_version_t version)
{
    of_match_v1_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_MATCH_V1] + of_object_extra_len[version][OF_MATCH_V1];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_match_v1_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_match_v1_init(obj, version, bytes, 0);

    if (of_match_v1_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_match_v1_t *
of_match_v1_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_match_v1_t *obj;

    obj = of_match_v1_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_match_v1.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_match_v1_init(of_match_v1_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_MATCH_V1] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_MATCH_V1] + of_object_extra_len[version][OF_MATCH_V1];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_MATCH_V1;

    /* Set up the object's function pointers */

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_match_v2 */

/**
 * \defgroup of_match_v2 of_match_v2
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_match_v2_push_wire_values(of_match_v2_t *obj)
{

    return OF_ERROR_NONE;
}

/**
 * Create a new of_match_v2 object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_match_v2
 */

of_match_v2_t *
of_match_v2_new_(of_version_t version)
{
    of_match_v2_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_MATCH_V2] + of_object_extra_len[version][OF_MATCH_V2];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_match_v2_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_match_v2_init(obj, version, bytes, 0);

    if (of_match_v2_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_match_v2_t *
of_match_v2_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_match_v2_t *obj;

    obj = of_match_v2_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_match_v2.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_match_v2_init(of_match_v2_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_MATCH_V2] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_MATCH_V2] + of_object_extra_len[version][OF_MATCH_V2];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_MATCH_V2;

    /* Set up the object's function pointers */

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_match_v3 */

/**
 * \defgroup of_match_v3 of_match_v3
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_match_v3_push_wire_values(of_match_v3_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_MATCH_V3);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_match_v3 object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_match_v3
 */

of_match_v3_t *
of_match_v3_new_(of_version_t version)
{
    of_match_v3_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_MATCH_V3] + of_object_extra_len[version][OF_MATCH_V3];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_match_v3_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_match_v3_init(obj, version, bytes, 0);

    if (of_match_v3_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_match_v3_t *
of_match_v3_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_match_v3_t *obj;

    obj = of_match_v3_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_match_v3.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_match_v3_init(of_match_v3_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_MATCH_V3] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_MATCH_V3] + of_object_extra_len[version][OF_MATCH_V3];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_MATCH_V3;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_meter_band */

/**
 * \defgroup of_meter_band of_meter_band
 */

/**
 * Create a new of_meter_band object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_meter_band
 */

of_meter_band_t *
of_meter_band_new_(of_version_t version)
{
    of_meter_band_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_METER_BAND] + of_object_extra_len[version][OF_METER_BAND];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_meter_band_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_meter_band_init(obj, version, bytes, 0);

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_meter_band_t *
of_meter_band_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_meter_band_t *obj;

    obj = of_meter_band_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_meter_band.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_meter_band_init(of_meter_band_t *obj_p,
    of_version_t version, int bytes, int clean_wire)
{
    of_meter_band_header_t *obj;

    obj = &obj_p->header;  /* Need instantiable subclass */

    ASSERT(of_object_fixed_len[version][OF_METER_BAND] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_METER_BAND] + of_object_extra_len[version][OF_METER_BAND];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_METER_BAND;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_meter_band_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_meter_band_drop */

/**
 * \defgroup of_meter_band_drop of_meter_band_drop
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_meter_band_drop_push_wire_values(of_meter_band_drop_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_METER_BAND_DROP);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_meter_band_drop object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_meter_band_drop
 */

of_meter_band_drop_t *
of_meter_band_drop_new_(of_version_t version)
{
    of_meter_band_drop_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_METER_BAND_DROP] + of_object_extra_len[version][OF_METER_BAND_DROP];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_meter_band_drop_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_meter_band_drop_init(obj, version, bytes, 0);

    if (of_meter_band_drop_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_meter_band_drop_t *
of_meter_band_drop_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_meter_band_drop_t *obj;

    obj = of_meter_band_drop_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_meter_band_drop.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_meter_band_drop_init(of_meter_band_drop_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_METER_BAND_DROP] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_METER_BAND_DROP] + of_object_extra_len[version][OF_METER_BAND_DROP];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_METER_BAND_DROP;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_meter_band_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_meter_band_dscp_remark */

/**
 * \defgroup of_meter_band_dscp_remark of_meter_band_dscp_remark
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_meter_band_dscp_remark_push_wire_values(of_meter_band_dscp_remark_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_METER_BAND_DSCP_REMARK);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_meter_band_dscp_remark object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_meter_band_dscp_remark
 */

of_meter_band_dscp_remark_t *
of_meter_band_dscp_remark_new_(of_version_t version)
{
    of_meter_band_dscp_remark_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_METER_BAND_DSCP_REMARK] + of_object_extra_len[version][OF_METER_BAND_DSCP_REMARK];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_meter_band_dscp_remark_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_meter_band_dscp_remark_init(obj, version, bytes, 0);

    if (of_meter_band_dscp_remark_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_meter_band_dscp_remark_t *
of_meter_band_dscp_remark_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_meter_band_dscp_remark_t *obj;

    obj = of_meter_band_dscp_remark_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_meter_band_dscp_remark.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_meter_band_dscp_remark_init(of_meter_band_dscp_remark_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_METER_BAND_DSCP_REMARK] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_METER_BAND_DSCP_REMARK] + of_object_extra_len[version][OF_METER_BAND_DSCP_REMARK];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_METER_BAND_DSCP_REMARK;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_meter_band_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_meter_band_experimenter */

/**
 * \defgroup of_meter_band_experimenter of_meter_band_experimenter
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_meter_band_experimenter_push_wire_values(of_meter_band_experimenter_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_METER_BAND_EXPERIMENTER);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_meter_band_experimenter object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_meter_band_experimenter
 */

of_meter_band_experimenter_t *
of_meter_band_experimenter_new_(of_version_t version)
{
    of_meter_band_experimenter_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_METER_BAND_EXPERIMENTER] + of_object_extra_len[version][OF_METER_BAND_EXPERIMENTER];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_meter_band_experimenter_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_meter_band_experimenter_init(obj, version, bytes, 0);

    if (of_meter_band_experimenter_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_meter_band_experimenter_t *
of_meter_band_experimenter_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_meter_band_experimenter_t *obj;

    obj = of_meter_band_experimenter_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_meter_band_experimenter.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_meter_band_experimenter_init(of_meter_band_experimenter_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_METER_BAND_EXPERIMENTER] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_METER_BAND_EXPERIMENTER] + of_object_extra_len[version][OF_METER_BAND_EXPERIMENTER];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_METER_BAND_EXPERIMENTER;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_meter_band_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_meter_band_header */

/**
 * \defgroup of_meter_band_header of_meter_band_header
 */

/**
 * Create a new of_meter_band_header object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_meter_band_header
 */

of_meter_band_header_t *
of_meter_band_header_new_(of_version_t version)
{
    of_meter_band_header_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_METER_BAND_HEADER] + of_object_extra_len[version][OF_METER_BAND_HEADER];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_meter_band_header_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_meter_band_header_init(obj, version, bytes, 0);

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_meter_band_header_t *
of_meter_band_header_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_meter_band_header_t *obj;

    obj = of_meter_band_header_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_meter_band_header.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_meter_band_header_init(of_meter_band_header_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_METER_BAND_HEADER] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_METER_BAND_HEADER] + of_object_extra_len[version][OF_METER_BAND_HEADER];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_METER_BAND_HEADER;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_meter_band_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_meter_band_stats */

/**
 * \defgroup of_meter_band_stats of_meter_band_stats
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_meter_band_stats_push_wire_values(of_meter_band_stats_t *obj)
{

    return OF_ERROR_NONE;
}

/**
 * Create a new of_meter_band_stats object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_meter_band_stats
 */

of_meter_band_stats_t *
of_meter_band_stats_new_(of_version_t version)
{
    of_meter_band_stats_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_METER_BAND_STATS] + of_object_extra_len[version][OF_METER_BAND_STATS];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_meter_band_stats_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_meter_band_stats_init(obj, version, bytes, 0);

    if (of_meter_band_stats_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_meter_band_stats_t *
of_meter_band_stats_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_meter_band_stats_t *obj;

    obj = of_meter_band_stats_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_meter_band_stats.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_meter_band_stats_init(of_meter_band_stats_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_METER_BAND_STATS] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_METER_BAND_STATS] + of_object_extra_len[version][OF_METER_BAND_STATS];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_METER_BAND_STATS;

    /* Set up the object's function pointers */

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_meter_config */

/**
 * \defgroup of_meter_config of_meter_config
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_meter_config_push_wire_values(of_meter_config_t *obj)
{

    return OF_ERROR_NONE;
}

/**
 * Create a new of_meter_config object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_meter_config
 */

of_meter_config_t *
of_meter_config_new_(of_version_t version)
{
    of_meter_config_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_METER_CONFIG] + of_object_extra_len[version][OF_METER_CONFIG];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_meter_config_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_meter_config_init(obj, version, bytes, 0);

    if (of_meter_config_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_meter_config_t *
of_meter_config_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_meter_config_t *obj;

    obj = of_meter_config_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_meter_config.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_meter_config_init(of_meter_config_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_METER_CONFIG] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_METER_CONFIG] + of_object_extra_len[version][OF_METER_CONFIG];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_METER_CONFIG;

    /* Set up the object's function pointers */

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_meter_features */

/**
 * \defgroup of_meter_features of_meter_features
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_meter_features_push_wire_values(of_meter_features_t *obj)
{

    return OF_ERROR_NONE;
}

/**
 * Create a new of_meter_features object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_meter_features
 */

of_meter_features_t *
of_meter_features_new_(of_version_t version)
{
    of_meter_features_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_METER_FEATURES] + of_object_extra_len[version][OF_METER_FEATURES];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_meter_features_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_meter_features_init(obj, version, bytes, 0);

    if (of_meter_features_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_meter_features_t *
of_meter_features_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_meter_features_t *obj;

    obj = of_meter_features_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_meter_features.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_meter_features_init(of_meter_features_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_METER_FEATURES] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_METER_FEATURES] + of_object_extra_len[version][OF_METER_FEATURES];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_METER_FEATURES;

    /* Set up the object's function pointers */

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_meter_stats */

/**
 * \defgroup of_meter_stats of_meter_stats
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_meter_stats_push_wire_values(of_meter_stats_t *obj)
{

    of_meter_stats_wire_length_set((of_object_t *)obj, obj->length);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_meter_stats object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_meter_stats
 */

of_meter_stats_t *
of_meter_stats_new_(of_version_t version)
{
    of_meter_stats_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_METER_STATS] + of_object_extra_len[version][OF_METER_STATS];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_meter_stats_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_meter_stats_init(obj, version, bytes, 0);

    if (of_meter_stats_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_meter_stats_t *
of_meter_stats_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_meter_stats_t *obj;

    obj = of_meter_stats_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_meter_stats.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_meter_stats_init(of_meter_stats_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_METER_STATS] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_METER_STATS] + of_object_extra_len[version][OF_METER_STATS];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_METER_STATS;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_meter_stats_wire_length_get;
    obj->wire_length_set = of_meter_stats_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm */

/**
 * \defgroup of_oxm of_oxm
 */

/**
 * Create a new of_oxm object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm
 */

of_oxm_t *
of_oxm_new_(of_version_t version)
{
    of_oxm_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM] + of_object_extra_len[version][OF_OXM];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_init(obj, version, bytes, 0);

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_t *
of_oxm_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_t *obj;

    obj = of_oxm_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_init(of_oxm_t *obj_p,
    of_version_t version, int bytes, int clean_wire)
{
    of_oxm_header_t *obj;

    obj = &obj_p->header;  /* Need instantiable subclass */

    ASSERT(of_object_fixed_len[version][OF_OXM] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM] + of_object_extra_len[version][OF_OXM];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_arp_op */

/**
 * \defgroup of_oxm_arp_op of_oxm_arp_op
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_arp_op_push_wire_values(of_oxm_arp_op_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_ARP_OP);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_arp_op object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_arp_op
 */

of_oxm_arp_op_t *
of_oxm_arp_op_new_(of_version_t version)
{
    of_oxm_arp_op_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_ARP_OP] + of_object_extra_len[version][OF_OXM_ARP_OP];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_arp_op_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_arp_op_init(obj, version, bytes, 0);

    if (of_oxm_arp_op_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_arp_op_t *
of_oxm_arp_op_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_arp_op_t *obj;

    obj = of_oxm_arp_op_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_arp_op.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_arp_op_init(of_oxm_arp_op_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_ARP_OP] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_ARP_OP] + of_object_extra_len[version][OF_OXM_ARP_OP];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_ARP_OP;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_arp_op_masked */

/**
 * \defgroup of_oxm_arp_op_masked of_oxm_arp_op_masked
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_arp_op_masked_push_wire_values(of_oxm_arp_op_masked_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_ARP_OP_MASKED);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_arp_op_masked object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_arp_op_masked
 */

of_oxm_arp_op_masked_t *
of_oxm_arp_op_masked_new_(of_version_t version)
{
    of_oxm_arp_op_masked_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_ARP_OP_MASKED] + of_object_extra_len[version][OF_OXM_ARP_OP_MASKED];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_arp_op_masked_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_arp_op_masked_init(obj, version, bytes, 0);

    if (of_oxm_arp_op_masked_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_arp_op_masked_t *
of_oxm_arp_op_masked_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_arp_op_masked_t *obj;

    obj = of_oxm_arp_op_masked_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_arp_op_masked.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_arp_op_masked_init(of_oxm_arp_op_masked_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_ARP_OP_MASKED] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_ARP_OP_MASKED] + of_object_extra_len[version][OF_OXM_ARP_OP_MASKED];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_ARP_OP_MASKED;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_arp_sha */

/**
 * \defgroup of_oxm_arp_sha of_oxm_arp_sha
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_arp_sha_push_wire_values(of_oxm_arp_sha_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_ARP_SHA);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_arp_sha object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_arp_sha
 */

of_oxm_arp_sha_t *
of_oxm_arp_sha_new_(of_version_t version)
{
    of_oxm_arp_sha_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_ARP_SHA] + of_object_extra_len[version][OF_OXM_ARP_SHA];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_arp_sha_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_arp_sha_init(obj, version, bytes, 0);

    if (of_oxm_arp_sha_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_arp_sha_t *
of_oxm_arp_sha_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_arp_sha_t *obj;

    obj = of_oxm_arp_sha_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_arp_sha.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_arp_sha_init(of_oxm_arp_sha_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_ARP_SHA] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_ARP_SHA] + of_object_extra_len[version][OF_OXM_ARP_SHA];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_ARP_SHA;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_arp_sha_masked */

/**
 * \defgroup of_oxm_arp_sha_masked of_oxm_arp_sha_masked
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_arp_sha_masked_push_wire_values(of_oxm_arp_sha_masked_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_ARP_SHA_MASKED);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_arp_sha_masked object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_arp_sha_masked
 */

of_oxm_arp_sha_masked_t *
of_oxm_arp_sha_masked_new_(of_version_t version)
{
    of_oxm_arp_sha_masked_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_ARP_SHA_MASKED] + of_object_extra_len[version][OF_OXM_ARP_SHA_MASKED];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_arp_sha_masked_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_arp_sha_masked_init(obj, version, bytes, 0);

    if (of_oxm_arp_sha_masked_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_arp_sha_masked_t *
of_oxm_arp_sha_masked_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_arp_sha_masked_t *obj;

    obj = of_oxm_arp_sha_masked_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_arp_sha_masked.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_arp_sha_masked_init(of_oxm_arp_sha_masked_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_ARP_SHA_MASKED] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_ARP_SHA_MASKED] + of_object_extra_len[version][OF_OXM_ARP_SHA_MASKED];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_ARP_SHA_MASKED;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_arp_spa */

/**
 * \defgroup of_oxm_arp_spa of_oxm_arp_spa
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_arp_spa_push_wire_values(of_oxm_arp_spa_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_ARP_SPA);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_arp_spa object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_arp_spa
 */

of_oxm_arp_spa_t *
of_oxm_arp_spa_new_(of_version_t version)
{
    of_oxm_arp_spa_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_ARP_SPA] + of_object_extra_len[version][OF_OXM_ARP_SPA];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_arp_spa_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_arp_spa_init(obj, version, bytes, 0);

    if (of_oxm_arp_spa_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_arp_spa_t *
of_oxm_arp_spa_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_arp_spa_t *obj;

    obj = of_oxm_arp_spa_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_arp_spa.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_arp_spa_init(of_oxm_arp_spa_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_ARP_SPA] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_ARP_SPA] + of_object_extra_len[version][OF_OXM_ARP_SPA];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_ARP_SPA;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_arp_spa_masked */

/**
 * \defgroup of_oxm_arp_spa_masked of_oxm_arp_spa_masked
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_arp_spa_masked_push_wire_values(of_oxm_arp_spa_masked_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_ARP_SPA_MASKED);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_arp_spa_masked object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_arp_spa_masked
 */

of_oxm_arp_spa_masked_t *
of_oxm_arp_spa_masked_new_(of_version_t version)
{
    of_oxm_arp_spa_masked_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_ARP_SPA_MASKED] + of_object_extra_len[version][OF_OXM_ARP_SPA_MASKED];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_arp_spa_masked_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_arp_spa_masked_init(obj, version, bytes, 0);

    if (of_oxm_arp_spa_masked_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_arp_spa_masked_t *
of_oxm_arp_spa_masked_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_arp_spa_masked_t *obj;

    obj = of_oxm_arp_spa_masked_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_arp_spa_masked.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_arp_spa_masked_init(of_oxm_arp_spa_masked_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_ARP_SPA_MASKED] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_ARP_SPA_MASKED] + of_object_extra_len[version][OF_OXM_ARP_SPA_MASKED];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_ARP_SPA_MASKED;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_arp_tha */

/**
 * \defgroup of_oxm_arp_tha of_oxm_arp_tha
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_arp_tha_push_wire_values(of_oxm_arp_tha_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_ARP_THA);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_arp_tha object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_arp_tha
 */

of_oxm_arp_tha_t *
of_oxm_arp_tha_new_(of_version_t version)
{
    of_oxm_arp_tha_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_ARP_THA] + of_object_extra_len[version][OF_OXM_ARP_THA];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_arp_tha_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_arp_tha_init(obj, version, bytes, 0);

    if (of_oxm_arp_tha_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_arp_tha_t *
of_oxm_arp_tha_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_arp_tha_t *obj;

    obj = of_oxm_arp_tha_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_arp_tha.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_arp_tha_init(of_oxm_arp_tha_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_ARP_THA] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_ARP_THA] + of_object_extra_len[version][OF_OXM_ARP_THA];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_ARP_THA;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_arp_tha_masked */

/**
 * \defgroup of_oxm_arp_tha_masked of_oxm_arp_tha_masked
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_arp_tha_masked_push_wire_values(of_oxm_arp_tha_masked_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_ARP_THA_MASKED);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_arp_tha_masked object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_arp_tha_masked
 */

of_oxm_arp_tha_masked_t *
of_oxm_arp_tha_masked_new_(of_version_t version)
{
    of_oxm_arp_tha_masked_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_ARP_THA_MASKED] + of_object_extra_len[version][OF_OXM_ARP_THA_MASKED];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_arp_tha_masked_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_arp_tha_masked_init(obj, version, bytes, 0);

    if (of_oxm_arp_tha_masked_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_arp_tha_masked_t *
of_oxm_arp_tha_masked_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_arp_tha_masked_t *obj;

    obj = of_oxm_arp_tha_masked_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_arp_tha_masked.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_arp_tha_masked_init(of_oxm_arp_tha_masked_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_ARP_THA_MASKED] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_ARP_THA_MASKED] + of_object_extra_len[version][OF_OXM_ARP_THA_MASKED];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_ARP_THA_MASKED;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_arp_tpa */

/**
 * \defgroup of_oxm_arp_tpa of_oxm_arp_tpa
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_arp_tpa_push_wire_values(of_oxm_arp_tpa_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_ARP_TPA);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_arp_tpa object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_arp_tpa
 */

of_oxm_arp_tpa_t *
of_oxm_arp_tpa_new_(of_version_t version)
{
    of_oxm_arp_tpa_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_ARP_TPA] + of_object_extra_len[version][OF_OXM_ARP_TPA];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_arp_tpa_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_arp_tpa_init(obj, version, bytes, 0);

    if (of_oxm_arp_tpa_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_arp_tpa_t *
of_oxm_arp_tpa_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_arp_tpa_t *obj;

    obj = of_oxm_arp_tpa_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_arp_tpa.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_arp_tpa_init(of_oxm_arp_tpa_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_ARP_TPA] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_ARP_TPA] + of_object_extra_len[version][OF_OXM_ARP_TPA];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_ARP_TPA;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_arp_tpa_masked */

/**
 * \defgroup of_oxm_arp_tpa_masked of_oxm_arp_tpa_masked
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_arp_tpa_masked_push_wire_values(of_oxm_arp_tpa_masked_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_ARP_TPA_MASKED);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_arp_tpa_masked object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_arp_tpa_masked
 */

of_oxm_arp_tpa_masked_t *
of_oxm_arp_tpa_masked_new_(of_version_t version)
{
    of_oxm_arp_tpa_masked_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_ARP_TPA_MASKED] + of_object_extra_len[version][OF_OXM_ARP_TPA_MASKED];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_arp_tpa_masked_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_arp_tpa_masked_init(obj, version, bytes, 0);

    if (of_oxm_arp_tpa_masked_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_arp_tpa_masked_t *
of_oxm_arp_tpa_masked_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_arp_tpa_masked_t *obj;

    obj = of_oxm_arp_tpa_masked_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_arp_tpa_masked.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_arp_tpa_masked_init(of_oxm_arp_tpa_masked_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_ARP_TPA_MASKED] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_ARP_TPA_MASKED] + of_object_extra_len[version][OF_OXM_ARP_TPA_MASKED];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_ARP_TPA_MASKED;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_eth_dst */

/**
 * \defgroup of_oxm_eth_dst of_oxm_eth_dst
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_eth_dst_push_wire_values(of_oxm_eth_dst_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_ETH_DST);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_eth_dst object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_eth_dst
 */

of_oxm_eth_dst_t *
of_oxm_eth_dst_new_(of_version_t version)
{
    of_oxm_eth_dst_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_ETH_DST] + of_object_extra_len[version][OF_OXM_ETH_DST];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_eth_dst_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_eth_dst_init(obj, version, bytes, 0);

    if (of_oxm_eth_dst_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_eth_dst_t *
of_oxm_eth_dst_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_eth_dst_t *obj;

    obj = of_oxm_eth_dst_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_eth_dst.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_eth_dst_init(of_oxm_eth_dst_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_ETH_DST] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_ETH_DST] + of_object_extra_len[version][OF_OXM_ETH_DST];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_ETH_DST;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_eth_dst_masked */

/**
 * \defgroup of_oxm_eth_dst_masked of_oxm_eth_dst_masked
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_eth_dst_masked_push_wire_values(of_oxm_eth_dst_masked_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_ETH_DST_MASKED);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_eth_dst_masked object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_eth_dst_masked
 */

of_oxm_eth_dst_masked_t *
of_oxm_eth_dst_masked_new_(of_version_t version)
{
    of_oxm_eth_dst_masked_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_ETH_DST_MASKED] + of_object_extra_len[version][OF_OXM_ETH_DST_MASKED];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_eth_dst_masked_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_eth_dst_masked_init(obj, version, bytes, 0);

    if (of_oxm_eth_dst_masked_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_eth_dst_masked_t *
of_oxm_eth_dst_masked_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_eth_dst_masked_t *obj;

    obj = of_oxm_eth_dst_masked_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_eth_dst_masked.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_eth_dst_masked_init(of_oxm_eth_dst_masked_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_ETH_DST_MASKED] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_ETH_DST_MASKED] + of_object_extra_len[version][OF_OXM_ETH_DST_MASKED];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_ETH_DST_MASKED;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_eth_src */

/**
 * \defgroup of_oxm_eth_src of_oxm_eth_src
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_eth_src_push_wire_values(of_oxm_eth_src_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_ETH_SRC);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_eth_src object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_eth_src
 */

of_oxm_eth_src_t *
of_oxm_eth_src_new_(of_version_t version)
{
    of_oxm_eth_src_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_ETH_SRC] + of_object_extra_len[version][OF_OXM_ETH_SRC];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_eth_src_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_eth_src_init(obj, version, bytes, 0);

    if (of_oxm_eth_src_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_eth_src_t *
of_oxm_eth_src_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_eth_src_t *obj;

    obj = of_oxm_eth_src_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_eth_src.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_eth_src_init(of_oxm_eth_src_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_ETH_SRC] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_ETH_SRC] + of_object_extra_len[version][OF_OXM_ETH_SRC];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_ETH_SRC;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_eth_src_masked */

/**
 * \defgroup of_oxm_eth_src_masked of_oxm_eth_src_masked
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_eth_src_masked_push_wire_values(of_oxm_eth_src_masked_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_ETH_SRC_MASKED);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_eth_src_masked object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_eth_src_masked
 */

of_oxm_eth_src_masked_t *
of_oxm_eth_src_masked_new_(of_version_t version)
{
    of_oxm_eth_src_masked_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_ETH_SRC_MASKED] + of_object_extra_len[version][OF_OXM_ETH_SRC_MASKED];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_eth_src_masked_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_eth_src_masked_init(obj, version, bytes, 0);

    if (of_oxm_eth_src_masked_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_eth_src_masked_t *
of_oxm_eth_src_masked_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_eth_src_masked_t *obj;

    obj = of_oxm_eth_src_masked_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_eth_src_masked.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_eth_src_masked_init(of_oxm_eth_src_masked_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_ETH_SRC_MASKED] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_ETH_SRC_MASKED] + of_object_extra_len[version][OF_OXM_ETH_SRC_MASKED];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_ETH_SRC_MASKED;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_eth_type */

/**
 * \defgroup of_oxm_eth_type of_oxm_eth_type
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_eth_type_push_wire_values(of_oxm_eth_type_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_ETH_TYPE);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_eth_type object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_eth_type
 */

of_oxm_eth_type_t *
of_oxm_eth_type_new_(of_version_t version)
{
    of_oxm_eth_type_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_ETH_TYPE] + of_object_extra_len[version][OF_OXM_ETH_TYPE];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_eth_type_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_eth_type_init(obj, version, bytes, 0);

    if (of_oxm_eth_type_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_eth_type_t *
of_oxm_eth_type_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_eth_type_t *obj;

    obj = of_oxm_eth_type_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_eth_type.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_eth_type_init(of_oxm_eth_type_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_ETH_TYPE] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_ETH_TYPE] + of_object_extra_len[version][OF_OXM_ETH_TYPE];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_ETH_TYPE;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_eth_type_masked */

/**
 * \defgroup of_oxm_eth_type_masked of_oxm_eth_type_masked
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_eth_type_masked_push_wire_values(of_oxm_eth_type_masked_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_ETH_TYPE_MASKED);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_eth_type_masked object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_eth_type_masked
 */

of_oxm_eth_type_masked_t *
of_oxm_eth_type_masked_new_(of_version_t version)
{
    of_oxm_eth_type_masked_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_ETH_TYPE_MASKED] + of_object_extra_len[version][OF_OXM_ETH_TYPE_MASKED];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_eth_type_masked_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_eth_type_masked_init(obj, version, bytes, 0);

    if (of_oxm_eth_type_masked_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_eth_type_masked_t *
of_oxm_eth_type_masked_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_eth_type_masked_t *obj;

    obj = of_oxm_eth_type_masked_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_eth_type_masked.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_eth_type_masked_init(of_oxm_eth_type_masked_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_ETH_TYPE_MASKED] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_ETH_TYPE_MASKED] + of_object_extra_len[version][OF_OXM_ETH_TYPE_MASKED];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_ETH_TYPE_MASKED;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_header */

/**
 * \defgroup of_oxm_header of_oxm_header
 */

/**
 * Create a new of_oxm_header object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_header
 */

of_oxm_header_t *
of_oxm_header_new_(of_version_t version)
{
    of_oxm_header_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_HEADER] + of_object_extra_len[version][OF_OXM_HEADER];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_header_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_header_init(obj, version, bytes, 0);

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_header_t *
of_oxm_header_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_header_t *obj;

    obj = of_oxm_header_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_header.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_header_init(of_oxm_header_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_HEADER] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_HEADER] + of_object_extra_len[version][OF_OXM_HEADER];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_HEADER;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_icmpv4_code */

/**
 * \defgroup of_oxm_icmpv4_code of_oxm_icmpv4_code
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_icmpv4_code_push_wire_values(of_oxm_icmpv4_code_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_ICMPV4_CODE);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_icmpv4_code object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_icmpv4_code
 */

of_oxm_icmpv4_code_t *
of_oxm_icmpv4_code_new_(of_version_t version)
{
    of_oxm_icmpv4_code_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_ICMPV4_CODE] + of_object_extra_len[version][OF_OXM_ICMPV4_CODE];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_icmpv4_code_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_icmpv4_code_init(obj, version, bytes, 0);

    if (of_oxm_icmpv4_code_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_icmpv4_code_t *
of_oxm_icmpv4_code_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_icmpv4_code_t *obj;

    obj = of_oxm_icmpv4_code_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_icmpv4_code.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_icmpv4_code_init(of_oxm_icmpv4_code_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_ICMPV4_CODE] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_ICMPV4_CODE] + of_object_extra_len[version][OF_OXM_ICMPV4_CODE];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_ICMPV4_CODE;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_icmpv4_code_masked */

/**
 * \defgroup of_oxm_icmpv4_code_masked of_oxm_icmpv4_code_masked
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_icmpv4_code_masked_push_wire_values(of_oxm_icmpv4_code_masked_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_ICMPV4_CODE_MASKED);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_icmpv4_code_masked object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_icmpv4_code_masked
 */

of_oxm_icmpv4_code_masked_t *
of_oxm_icmpv4_code_masked_new_(of_version_t version)
{
    of_oxm_icmpv4_code_masked_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_ICMPV4_CODE_MASKED] + of_object_extra_len[version][OF_OXM_ICMPV4_CODE_MASKED];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_icmpv4_code_masked_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_icmpv4_code_masked_init(obj, version, bytes, 0);

    if (of_oxm_icmpv4_code_masked_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_icmpv4_code_masked_t *
of_oxm_icmpv4_code_masked_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_icmpv4_code_masked_t *obj;

    obj = of_oxm_icmpv4_code_masked_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_icmpv4_code_masked.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_icmpv4_code_masked_init(of_oxm_icmpv4_code_masked_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_ICMPV4_CODE_MASKED] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_ICMPV4_CODE_MASKED] + of_object_extra_len[version][OF_OXM_ICMPV4_CODE_MASKED];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_ICMPV4_CODE_MASKED;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_icmpv4_type */

/**
 * \defgroup of_oxm_icmpv4_type of_oxm_icmpv4_type
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_icmpv4_type_push_wire_values(of_oxm_icmpv4_type_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_ICMPV4_TYPE);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_icmpv4_type object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_icmpv4_type
 */

of_oxm_icmpv4_type_t *
of_oxm_icmpv4_type_new_(of_version_t version)
{
    of_oxm_icmpv4_type_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_ICMPV4_TYPE] + of_object_extra_len[version][OF_OXM_ICMPV4_TYPE];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_icmpv4_type_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_icmpv4_type_init(obj, version, bytes, 0);

    if (of_oxm_icmpv4_type_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_icmpv4_type_t *
of_oxm_icmpv4_type_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_icmpv4_type_t *obj;

    obj = of_oxm_icmpv4_type_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_icmpv4_type.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_icmpv4_type_init(of_oxm_icmpv4_type_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_ICMPV4_TYPE] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_ICMPV4_TYPE] + of_object_extra_len[version][OF_OXM_ICMPV4_TYPE];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_ICMPV4_TYPE;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_icmpv4_type_masked */

/**
 * \defgroup of_oxm_icmpv4_type_masked of_oxm_icmpv4_type_masked
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_icmpv4_type_masked_push_wire_values(of_oxm_icmpv4_type_masked_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_ICMPV4_TYPE_MASKED);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_icmpv4_type_masked object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_icmpv4_type_masked
 */

of_oxm_icmpv4_type_masked_t *
of_oxm_icmpv4_type_masked_new_(of_version_t version)
{
    of_oxm_icmpv4_type_masked_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_ICMPV4_TYPE_MASKED] + of_object_extra_len[version][OF_OXM_ICMPV4_TYPE_MASKED];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_icmpv4_type_masked_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_icmpv4_type_masked_init(obj, version, bytes, 0);

    if (of_oxm_icmpv4_type_masked_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_icmpv4_type_masked_t *
of_oxm_icmpv4_type_masked_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_icmpv4_type_masked_t *obj;

    obj = of_oxm_icmpv4_type_masked_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_icmpv4_type_masked.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_icmpv4_type_masked_init(of_oxm_icmpv4_type_masked_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_ICMPV4_TYPE_MASKED] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_ICMPV4_TYPE_MASKED] + of_object_extra_len[version][OF_OXM_ICMPV4_TYPE_MASKED];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_ICMPV4_TYPE_MASKED;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_icmpv6_code */

/**
 * \defgroup of_oxm_icmpv6_code of_oxm_icmpv6_code
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_icmpv6_code_push_wire_values(of_oxm_icmpv6_code_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_ICMPV6_CODE);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_icmpv6_code object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_icmpv6_code
 */

of_oxm_icmpv6_code_t *
of_oxm_icmpv6_code_new_(of_version_t version)
{
    of_oxm_icmpv6_code_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_ICMPV6_CODE] + of_object_extra_len[version][OF_OXM_ICMPV6_CODE];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_icmpv6_code_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_icmpv6_code_init(obj, version, bytes, 0);

    if (of_oxm_icmpv6_code_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_icmpv6_code_t *
of_oxm_icmpv6_code_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_icmpv6_code_t *obj;

    obj = of_oxm_icmpv6_code_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_icmpv6_code.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_icmpv6_code_init(of_oxm_icmpv6_code_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_ICMPV6_CODE] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_ICMPV6_CODE] + of_object_extra_len[version][OF_OXM_ICMPV6_CODE];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_ICMPV6_CODE;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_icmpv6_code_masked */

/**
 * \defgroup of_oxm_icmpv6_code_masked of_oxm_icmpv6_code_masked
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_icmpv6_code_masked_push_wire_values(of_oxm_icmpv6_code_masked_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_ICMPV6_CODE_MASKED);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_icmpv6_code_masked object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_icmpv6_code_masked
 */

of_oxm_icmpv6_code_masked_t *
of_oxm_icmpv6_code_masked_new_(of_version_t version)
{
    of_oxm_icmpv6_code_masked_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_ICMPV6_CODE_MASKED] + of_object_extra_len[version][OF_OXM_ICMPV6_CODE_MASKED];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_icmpv6_code_masked_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_icmpv6_code_masked_init(obj, version, bytes, 0);

    if (of_oxm_icmpv6_code_masked_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_icmpv6_code_masked_t *
of_oxm_icmpv6_code_masked_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_icmpv6_code_masked_t *obj;

    obj = of_oxm_icmpv6_code_masked_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_icmpv6_code_masked.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_icmpv6_code_masked_init(of_oxm_icmpv6_code_masked_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_ICMPV6_CODE_MASKED] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_ICMPV6_CODE_MASKED] + of_object_extra_len[version][OF_OXM_ICMPV6_CODE_MASKED];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_ICMPV6_CODE_MASKED;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_icmpv6_type */

/**
 * \defgroup of_oxm_icmpv6_type of_oxm_icmpv6_type
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_icmpv6_type_push_wire_values(of_oxm_icmpv6_type_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_ICMPV6_TYPE);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_icmpv6_type object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_icmpv6_type
 */

of_oxm_icmpv6_type_t *
of_oxm_icmpv6_type_new_(of_version_t version)
{
    of_oxm_icmpv6_type_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_ICMPV6_TYPE] + of_object_extra_len[version][OF_OXM_ICMPV6_TYPE];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_icmpv6_type_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_icmpv6_type_init(obj, version, bytes, 0);

    if (of_oxm_icmpv6_type_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_icmpv6_type_t *
of_oxm_icmpv6_type_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_icmpv6_type_t *obj;

    obj = of_oxm_icmpv6_type_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_icmpv6_type.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_icmpv6_type_init(of_oxm_icmpv6_type_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_ICMPV6_TYPE] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_ICMPV6_TYPE] + of_object_extra_len[version][OF_OXM_ICMPV6_TYPE];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_ICMPV6_TYPE;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_icmpv6_type_masked */

/**
 * \defgroup of_oxm_icmpv6_type_masked of_oxm_icmpv6_type_masked
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_icmpv6_type_masked_push_wire_values(of_oxm_icmpv6_type_masked_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_ICMPV6_TYPE_MASKED);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_icmpv6_type_masked object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_icmpv6_type_masked
 */

of_oxm_icmpv6_type_masked_t *
of_oxm_icmpv6_type_masked_new_(of_version_t version)
{
    of_oxm_icmpv6_type_masked_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_ICMPV6_TYPE_MASKED] + of_object_extra_len[version][OF_OXM_ICMPV6_TYPE_MASKED];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_icmpv6_type_masked_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_icmpv6_type_masked_init(obj, version, bytes, 0);

    if (of_oxm_icmpv6_type_masked_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_icmpv6_type_masked_t *
of_oxm_icmpv6_type_masked_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_icmpv6_type_masked_t *obj;

    obj = of_oxm_icmpv6_type_masked_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_icmpv6_type_masked.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_icmpv6_type_masked_init(of_oxm_icmpv6_type_masked_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_ICMPV6_TYPE_MASKED] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_ICMPV6_TYPE_MASKED] + of_object_extra_len[version][OF_OXM_ICMPV6_TYPE_MASKED];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_ICMPV6_TYPE_MASKED;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_in_phy_port */

/**
 * \defgroup of_oxm_in_phy_port of_oxm_in_phy_port
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_in_phy_port_push_wire_values(of_oxm_in_phy_port_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_IN_PHY_PORT);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_in_phy_port object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_in_phy_port
 */

of_oxm_in_phy_port_t *
of_oxm_in_phy_port_new_(of_version_t version)
{
    of_oxm_in_phy_port_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_IN_PHY_PORT] + of_object_extra_len[version][OF_OXM_IN_PHY_PORT];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_in_phy_port_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_in_phy_port_init(obj, version, bytes, 0);

    if (of_oxm_in_phy_port_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_in_phy_port_t *
of_oxm_in_phy_port_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_in_phy_port_t *obj;

    obj = of_oxm_in_phy_port_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_in_phy_port.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_in_phy_port_init(of_oxm_in_phy_port_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_IN_PHY_PORT] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_IN_PHY_PORT] + of_object_extra_len[version][OF_OXM_IN_PHY_PORT];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_IN_PHY_PORT;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_in_phy_port_masked */

/**
 * \defgroup of_oxm_in_phy_port_masked of_oxm_in_phy_port_masked
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_in_phy_port_masked_push_wire_values(of_oxm_in_phy_port_masked_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_IN_PHY_PORT_MASKED);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_in_phy_port_masked object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_in_phy_port_masked
 */

of_oxm_in_phy_port_masked_t *
of_oxm_in_phy_port_masked_new_(of_version_t version)
{
    of_oxm_in_phy_port_masked_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_IN_PHY_PORT_MASKED] + of_object_extra_len[version][OF_OXM_IN_PHY_PORT_MASKED];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_in_phy_port_masked_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_in_phy_port_masked_init(obj, version, bytes, 0);

    if (of_oxm_in_phy_port_masked_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_in_phy_port_masked_t *
of_oxm_in_phy_port_masked_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_in_phy_port_masked_t *obj;

    obj = of_oxm_in_phy_port_masked_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_in_phy_port_masked.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_in_phy_port_masked_init(of_oxm_in_phy_port_masked_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_IN_PHY_PORT_MASKED] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_IN_PHY_PORT_MASKED] + of_object_extra_len[version][OF_OXM_IN_PHY_PORT_MASKED];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_IN_PHY_PORT_MASKED;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_in_port */

/**
 * \defgroup of_oxm_in_port of_oxm_in_port
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_in_port_push_wire_values(of_oxm_in_port_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_IN_PORT);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_in_port object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_in_port
 */

of_oxm_in_port_t *
of_oxm_in_port_new_(of_version_t version)
{
    of_oxm_in_port_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_IN_PORT] + of_object_extra_len[version][OF_OXM_IN_PORT];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_in_port_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_in_port_init(obj, version, bytes, 0);

    if (of_oxm_in_port_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_in_port_t *
of_oxm_in_port_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_in_port_t *obj;

    obj = of_oxm_in_port_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_in_port.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_in_port_init(of_oxm_in_port_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_IN_PORT] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_IN_PORT] + of_object_extra_len[version][OF_OXM_IN_PORT];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_IN_PORT;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_in_port_masked */

/**
 * \defgroup of_oxm_in_port_masked of_oxm_in_port_masked
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_in_port_masked_push_wire_values(of_oxm_in_port_masked_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_IN_PORT_MASKED);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_in_port_masked object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_in_port_masked
 */

of_oxm_in_port_masked_t *
of_oxm_in_port_masked_new_(of_version_t version)
{
    of_oxm_in_port_masked_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_IN_PORT_MASKED] + of_object_extra_len[version][OF_OXM_IN_PORT_MASKED];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_in_port_masked_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_in_port_masked_init(obj, version, bytes, 0);

    if (of_oxm_in_port_masked_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_in_port_masked_t *
of_oxm_in_port_masked_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_in_port_masked_t *obj;

    obj = of_oxm_in_port_masked_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_in_port_masked.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_in_port_masked_init(of_oxm_in_port_masked_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_IN_PORT_MASKED] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_IN_PORT_MASKED] + of_object_extra_len[version][OF_OXM_IN_PORT_MASKED];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_IN_PORT_MASKED;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_ip_dscp */

/**
 * \defgroup of_oxm_ip_dscp of_oxm_ip_dscp
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_ip_dscp_push_wire_values(of_oxm_ip_dscp_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_IP_DSCP);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_ip_dscp object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_ip_dscp
 */

of_oxm_ip_dscp_t *
of_oxm_ip_dscp_new_(of_version_t version)
{
    of_oxm_ip_dscp_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_IP_DSCP] + of_object_extra_len[version][OF_OXM_IP_DSCP];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_ip_dscp_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_ip_dscp_init(obj, version, bytes, 0);

    if (of_oxm_ip_dscp_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_ip_dscp_t *
of_oxm_ip_dscp_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_ip_dscp_t *obj;

    obj = of_oxm_ip_dscp_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_ip_dscp.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_ip_dscp_init(of_oxm_ip_dscp_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_IP_DSCP] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_IP_DSCP] + of_object_extra_len[version][OF_OXM_IP_DSCP];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_IP_DSCP;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_ip_dscp_masked */

/**
 * \defgroup of_oxm_ip_dscp_masked of_oxm_ip_dscp_masked
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_ip_dscp_masked_push_wire_values(of_oxm_ip_dscp_masked_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_IP_DSCP_MASKED);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_ip_dscp_masked object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_ip_dscp_masked
 */

of_oxm_ip_dscp_masked_t *
of_oxm_ip_dscp_masked_new_(of_version_t version)
{
    of_oxm_ip_dscp_masked_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_IP_DSCP_MASKED] + of_object_extra_len[version][OF_OXM_IP_DSCP_MASKED];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_ip_dscp_masked_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_ip_dscp_masked_init(obj, version, bytes, 0);

    if (of_oxm_ip_dscp_masked_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_ip_dscp_masked_t *
of_oxm_ip_dscp_masked_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_ip_dscp_masked_t *obj;

    obj = of_oxm_ip_dscp_masked_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_ip_dscp_masked.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_ip_dscp_masked_init(of_oxm_ip_dscp_masked_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_IP_DSCP_MASKED] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_IP_DSCP_MASKED] + of_object_extra_len[version][OF_OXM_IP_DSCP_MASKED];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_IP_DSCP_MASKED;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_ip_ecn */

/**
 * \defgroup of_oxm_ip_ecn of_oxm_ip_ecn
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_ip_ecn_push_wire_values(of_oxm_ip_ecn_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_IP_ECN);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_ip_ecn object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_ip_ecn
 */

of_oxm_ip_ecn_t *
of_oxm_ip_ecn_new_(of_version_t version)
{
    of_oxm_ip_ecn_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_IP_ECN] + of_object_extra_len[version][OF_OXM_IP_ECN];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_ip_ecn_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_ip_ecn_init(obj, version, bytes, 0);

    if (of_oxm_ip_ecn_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_ip_ecn_t *
of_oxm_ip_ecn_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_ip_ecn_t *obj;

    obj = of_oxm_ip_ecn_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_ip_ecn.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_ip_ecn_init(of_oxm_ip_ecn_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_IP_ECN] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_IP_ECN] + of_object_extra_len[version][OF_OXM_IP_ECN];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_IP_ECN;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_ip_ecn_masked */

/**
 * \defgroup of_oxm_ip_ecn_masked of_oxm_ip_ecn_masked
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_ip_ecn_masked_push_wire_values(of_oxm_ip_ecn_masked_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_IP_ECN_MASKED);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_ip_ecn_masked object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_ip_ecn_masked
 */

of_oxm_ip_ecn_masked_t *
of_oxm_ip_ecn_masked_new_(of_version_t version)
{
    of_oxm_ip_ecn_masked_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_IP_ECN_MASKED] + of_object_extra_len[version][OF_OXM_IP_ECN_MASKED];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_ip_ecn_masked_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_ip_ecn_masked_init(obj, version, bytes, 0);

    if (of_oxm_ip_ecn_masked_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_ip_ecn_masked_t *
of_oxm_ip_ecn_masked_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_ip_ecn_masked_t *obj;

    obj = of_oxm_ip_ecn_masked_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_ip_ecn_masked.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_ip_ecn_masked_init(of_oxm_ip_ecn_masked_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_IP_ECN_MASKED] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_IP_ECN_MASKED] + of_object_extra_len[version][OF_OXM_IP_ECN_MASKED];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_IP_ECN_MASKED;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_ip_proto */

/**
 * \defgroup of_oxm_ip_proto of_oxm_ip_proto
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_ip_proto_push_wire_values(of_oxm_ip_proto_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_IP_PROTO);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_ip_proto object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_ip_proto
 */

of_oxm_ip_proto_t *
of_oxm_ip_proto_new_(of_version_t version)
{
    of_oxm_ip_proto_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_IP_PROTO] + of_object_extra_len[version][OF_OXM_IP_PROTO];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_ip_proto_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_ip_proto_init(obj, version, bytes, 0);

    if (of_oxm_ip_proto_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_ip_proto_t *
of_oxm_ip_proto_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_ip_proto_t *obj;

    obj = of_oxm_ip_proto_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_ip_proto.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_ip_proto_init(of_oxm_ip_proto_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_IP_PROTO] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_IP_PROTO] + of_object_extra_len[version][OF_OXM_IP_PROTO];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_IP_PROTO;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_ip_proto_masked */

/**
 * \defgroup of_oxm_ip_proto_masked of_oxm_ip_proto_masked
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_ip_proto_masked_push_wire_values(of_oxm_ip_proto_masked_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_IP_PROTO_MASKED);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_ip_proto_masked object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_ip_proto_masked
 */

of_oxm_ip_proto_masked_t *
of_oxm_ip_proto_masked_new_(of_version_t version)
{
    of_oxm_ip_proto_masked_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_IP_PROTO_MASKED] + of_object_extra_len[version][OF_OXM_IP_PROTO_MASKED];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_ip_proto_masked_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_ip_proto_masked_init(obj, version, bytes, 0);

    if (of_oxm_ip_proto_masked_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_ip_proto_masked_t *
of_oxm_ip_proto_masked_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_ip_proto_masked_t *obj;

    obj = of_oxm_ip_proto_masked_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_ip_proto_masked.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_ip_proto_masked_init(of_oxm_ip_proto_masked_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_IP_PROTO_MASKED] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_IP_PROTO_MASKED] + of_object_extra_len[version][OF_OXM_IP_PROTO_MASKED];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_IP_PROTO_MASKED;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_ipv4_dst */

/**
 * \defgroup of_oxm_ipv4_dst of_oxm_ipv4_dst
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_ipv4_dst_push_wire_values(of_oxm_ipv4_dst_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_IPV4_DST);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_ipv4_dst object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_ipv4_dst
 */

of_oxm_ipv4_dst_t *
of_oxm_ipv4_dst_new_(of_version_t version)
{
    of_oxm_ipv4_dst_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_IPV4_DST] + of_object_extra_len[version][OF_OXM_IPV4_DST];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_ipv4_dst_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_ipv4_dst_init(obj, version, bytes, 0);

    if (of_oxm_ipv4_dst_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_ipv4_dst_t *
of_oxm_ipv4_dst_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_ipv4_dst_t *obj;

    obj = of_oxm_ipv4_dst_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_ipv4_dst.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_ipv4_dst_init(of_oxm_ipv4_dst_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_IPV4_DST] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_IPV4_DST] + of_object_extra_len[version][OF_OXM_IPV4_DST];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_IPV4_DST;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_ipv4_dst_masked */

/**
 * \defgroup of_oxm_ipv4_dst_masked of_oxm_ipv4_dst_masked
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_ipv4_dst_masked_push_wire_values(of_oxm_ipv4_dst_masked_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_IPV4_DST_MASKED);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_ipv4_dst_masked object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_ipv4_dst_masked
 */

of_oxm_ipv4_dst_masked_t *
of_oxm_ipv4_dst_masked_new_(of_version_t version)
{
    of_oxm_ipv4_dst_masked_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_IPV4_DST_MASKED] + of_object_extra_len[version][OF_OXM_IPV4_DST_MASKED];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_ipv4_dst_masked_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_ipv4_dst_masked_init(obj, version, bytes, 0);

    if (of_oxm_ipv4_dst_masked_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_ipv4_dst_masked_t *
of_oxm_ipv4_dst_masked_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_ipv4_dst_masked_t *obj;

    obj = of_oxm_ipv4_dst_masked_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_ipv4_dst_masked.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_ipv4_dst_masked_init(of_oxm_ipv4_dst_masked_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_IPV4_DST_MASKED] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_IPV4_DST_MASKED] + of_object_extra_len[version][OF_OXM_IPV4_DST_MASKED];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_IPV4_DST_MASKED;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_ipv4_src */

/**
 * \defgroup of_oxm_ipv4_src of_oxm_ipv4_src
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_ipv4_src_push_wire_values(of_oxm_ipv4_src_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_IPV4_SRC);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_ipv4_src object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_ipv4_src
 */

of_oxm_ipv4_src_t *
of_oxm_ipv4_src_new_(of_version_t version)
{
    of_oxm_ipv4_src_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_IPV4_SRC] + of_object_extra_len[version][OF_OXM_IPV4_SRC];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_ipv4_src_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_ipv4_src_init(obj, version, bytes, 0);

    if (of_oxm_ipv4_src_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_ipv4_src_t *
of_oxm_ipv4_src_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_ipv4_src_t *obj;

    obj = of_oxm_ipv4_src_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_ipv4_src.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_ipv4_src_init(of_oxm_ipv4_src_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_IPV4_SRC] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_IPV4_SRC] + of_object_extra_len[version][OF_OXM_IPV4_SRC];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_IPV4_SRC;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_ipv4_src_masked */

/**
 * \defgroup of_oxm_ipv4_src_masked of_oxm_ipv4_src_masked
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_ipv4_src_masked_push_wire_values(of_oxm_ipv4_src_masked_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_IPV4_SRC_MASKED);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_ipv4_src_masked object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_ipv4_src_masked
 */

of_oxm_ipv4_src_masked_t *
of_oxm_ipv4_src_masked_new_(of_version_t version)
{
    of_oxm_ipv4_src_masked_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_IPV4_SRC_MASKED] + of_object_extra_len[version][OF_OXM_IPV4_SRC_MASKED];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_ipv4_src_masked_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_ipv4_src_masked_init(obj, version, bytes, 0);

    if (of_oxm_ipv4_src_masked_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_ipv4_src_masked_t *
of_oxm_ipv4_src_masked_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_ipv4_src_masked_t *obj;

    obj = of_oxm_ipv4_src_masked_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_ipv4_src_masked.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_ipv4_src_masked_init(of_oxm_ipv4_src_masked_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_IPV4_SRC_MASKED] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_IPV4_SRC_MASKED] + of_object_extra_len[version][OF_OXM_IPV4_SRC_MASKED];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_IPV4_SRC_MASKED;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_ipv6_dst */

/**
 * \defgroup of_oxm_ipv6_dst of_oxm_ipv6_dst
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_ipv6_dst_push_wire_values(of_oxm_ipv6_dst_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_IPV6_DST);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_ipv6_dst object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_ipv6_dst
 */

of_oxm_ipv6_dst_t *
of_oxm_ipv6_dst_new_(of_version_t version)
{
    of_oxm_ipv6_dst_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_IPV6_DST] + of_object_extra_len[version][OF_OXM_IPV6_DST];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_ipv6_dst_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_ipv6_dst_init(obj, version, bytes, 0);

    if (of_oxm_ipv6_dst_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_ipv6_dst_t *
of_oxm_ipv6_dst_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_ipv6_dst_t *obj;

    obj = of_oxm_ipv6_dst_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_ipv6_dst.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_ipv6_dst_init(of_oxm_ipv6_dst_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_IPV6_DST] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_IPV6_DST] + of_object_extra_len[version][OF_OXM_IPV6_DST];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_IPV6_DST;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_ipv6_dst_masked */

/**
 * \defgroup of_oxm_ipv6_dst_masked of_oxm_ipv6_dst_masked
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_ipv6_dst_masked_push_wire_values(of_oxm_ipv6_dst_masked_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_IPV6_DST_MASKED);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_ipv6_dst_masked object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_ipv6_dst_masked
 */

of_oxm_ipv6_dst_masked_t *
of_oxm_ipv6_dst_masked_new_(of_version_t version)
{
    of_oxm_ipv6_dst_masked_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_IPV6_DST_MASKED] + of_object_extra_len[version][OF_OXM_IPV6_DST_MASKED];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_ipv6_dst_masked_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_ipv6_dst_masked_init(obj, version, bytes, 0);

    if (of_oxm_ipv6_dst_masked_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_ipv6_dst_masked_t *
of_oxm_ipv6_dst_masked_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_ipv6_dst_masked_t *obj;

    obj = of_oxm_ipv6_dst_masked_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_ipv6_dst_masked.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_ipv6_dst_masked_init(of_oxm_ipv6_dst_masked_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_IPV6_DST_MASKED] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_IPV6_DST_MASKED] + of_object_extra_len[version][OF_OXM_IPV6_DST_MASKED];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_IPV6_DST_MASKED;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_ipv6_flabel */

/**
 * \defgroup of_oxm_ipv6_flabel of_oxm_ipv6_flabel
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_ipv6_flabel_push_wire_values(of_oxm_ipv6_flabel_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_IPV6_FLABEL);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_ipv6_flabel object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_ipv6_flabel
 */

of_oxm_ipv6_flabel_t *
of_oxm_ipv6_flabel_new_(of_version_t version)
{
    of_oxm_ipv6_flabel_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_IPV6_FLABEL] + of_object_extra_len[version][OF_OXM_IPV6_FLABEL];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_ipv6_flabel_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_ipv6_flabel_init(obj, version, bytes, 0);

    if (of_oxm_ipv6_flabel_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_ipv6_flabel_t *
of_oxm_ipv6_flabel_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_ipv6_flabel_t *obj;

    obj = of_oxm_ipv6_flabel_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_ipv6_flabel.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_ipv6_flabel_init(of_oxm_ipv6_flabel_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_IPV6_FLABEL] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_IPV6_FLABEL] + of_object_extra_len[version][OF_OXM_IPV6_FLABEL];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_IPV6_FLABEL;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_ipv6_flabel_masked */

/**
 * \defgroup of_oxm_ipv6_flabel_masked of_oxm_ipv6_flabel_masked
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_ipv6_flabel_masked_push_wire_values(of_oxm_ipv6_flabel_masked_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_IPV6_FLABEL_MASKED);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_ipv6_flabel_masked object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_ipv6_flabel_masked
 */

of_oxm_ipv6_flabel_masked_t *
of_oxm_ipv6_flabel_masked_new_(of_version_t version)
{
    of_oxm_ipv6_flabel_masked_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_IPV6_FLABEL_MASKED] + of_object_extra_len[version][OF_OXM_IPV6_FLABEL_MASKED];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_ipv6_flabel_masked_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_ipv6_flabel_masked_init(obj, version, bytes, 0);

    if (of_oxm_ipv6_flabel_masked_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_ipv6_flabel_masked_t *
of_oxm_ipv6_flabel_masked_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_ipv6_flabel_masked_t *obj;

    obj = of_oxm_ipv6_flabel_masked_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_ipv6_flabel_masked.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_ipv6_flabel_masked_init(of_oxm_ipv6_flabel_masked_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_IPV6_FLABEL_MASKED] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_IPV6_FLABEL_MASKED] + of_object_extra_len[version][OF_OXM_IPV6_FLABEL_MASKED];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_IPV6_FLABEL_MASKED;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_ipv6_nd_sll */

/**
 * \defgroup of_oxm_ipv6_nd_sll of_oxm_ipv6_nd_sll
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_ipv6_nd_sll_push_wire_values(of_oxm_ipv6_nd_sll_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_IPV6_ND_SLL);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_ipv6_nd_sll object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_ipv6_nd_sll
 */

of_oxm_ipv6_nd_sll_t *
of_oxm_ipv6_nd_sll_new_(of_version_t version)
{
    of_oxm_ipv6_nd_sll_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_IPV6_ND_SLL] + of_object_extra_len[version][OF_OXM_IPV6_ND_SLL];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_ipv6_nd_sll_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_ipv6_nd_sll_init(obj, version, bytes, 0);

    if (of_oxm_ipv6_nd_sll_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_ipv6_nd_sll_t *
of_oxm_ipv6_nd_sll_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_ipv6_nd_sll_t *obj;

    obj = of_oxm_ipv6_nd_sll_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_ipv6_nd_sll.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_ipv6_nd_sll_init(of_oxm_ipv6_nd_sll_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_IPV6_ND_SLL] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_IPV6_ND_SLL] + of_object_extra_len[version][OF_OXM_IPV6_ND_SLL];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_IPV6_ND_SLL;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_ipv6_nd_sll_masked */

/**
 * \defgroup of_oxm_ipv6_nd_sll_masked of_oxm_ipv6_nd_sll_masked
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_ipv6_nd_sll_masked_push_wire_values(of_oxm_ipv6_nd_sll_masked_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_IPV6_ND_SLL_MASKED);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_ipv6_nd_sll_masked object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_ipv6_nd_sll_masked
 */

of_oxm_ipv6_nd_sll_masked_t *
of_oxm_ipv6_nd_sll_masked_new_(of_version_t version)
{
    of_oxm_ipv6_nd_sll_masked_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_IPV6_ND_SLL_MASKED] + of_object_extra_len[version][OF_OXM_IPV6_ND_SLL_MASKED];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_ipv6_nd_sll_masked_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_ipv6_nd_sll_masked_init(obj, version, bytes, 0);

    if (of_oxm_ipv6_nd_sll_masked_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_ipv6_nd_sll_masked_t *
of_oxm_ipv6_nd_sll_masked_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_ipv6_nd_sll_masked_t *obj;

    obj = of_oxm_ipv6_nd_sll_masked_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_ipv6_nd_sll_masked.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_ipv6_nd_sll_masked_init(of_oxm_ipv6_nd_sll_masked_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_IPV6_ND_SLL_MASKED] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_IPV6_ND_SLL_MASKED] + of_object_extra_len[version][OF_OXM_IPV6_ND_SLL_MASKED];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_IPV6_ND_SLL_MASKED;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_ipv6_nd_target */

/**
 * \defgroup of_oxm_ipv6_nd_target of_oxm_ipv6_nd_target
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_ipv6_nd_target_push_wire_values(of_oxm_ipv6_nd_target_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_IPV6_ND_TARGET);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_ipv6_nd_target object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_ipv6_nd_target
 */

of_oxm_ipv6_nd_target_t *
of_oxm_ipv6_nd_target_new_(of_version_t version)
{
    of_oxm_ipv6_nd_target_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_IPV6_ND_TARGET] + of_object_extra_len[version][OF_OXM_IPV6_ND_TARGET];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_ipv6_nd_target_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_ipv6_nd_target_init(obj, version, bytes, 0);

    if (of_oxm_ipv6_nd_target_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_ipv6_nd_target_t *
of_oxm_ipv6_nd_target_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_ipv6_nd_target_t *obj;

    obj = of_oxm_ipv6_nd_target_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_ipv6_nd_target.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_ipv6_nd_target_init(of_oxm_ipv6_nd_target_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_IPV6_ND_TARGET] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_IPV6_ND_TARGET] + of_object_extra_len[version][OF_OXM_IPV6_ND_TARGET];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_IPV6_ND_TARGET;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_ipv6_nd_target_masked */

/**
 * \defgroup of_oxm_ipv6_nd_target_masked of_oxm_ipv6_nd_target_masked
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_ipv6_nd_target_masked_push_wire_values(of_oxm_ipv6_nd_target_masked_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_IPV6_ND_TARGET_MASKED);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_ipv6_nd_target_masked object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_ipv6_nd_target_masked
 */

of_oxm_ipv6_nd_target_masked_t *
of_oxm_ipv6_nd_target_masked_new_(of_version_t version)
{
    of_oxm_ipv6_nd_target_masked_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_IPV6_ND_TARGET_MASKED] + of_object_extra_len[version][OF_OXM_IPV6_ND_TARGET_MASKED];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_ipv6_nd_target_masked_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_ipv6_nd_target_masked_init(obj, version, bytes, 0);

    if (of_oxm_ipv6_nd_target_masked_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_ipv6_nd_target_masked_t *
of_oxm_ipv6_nd_target_masked_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_ipv6_nd_target_masked_t *obj;

    obj = of_oxm_ipv6_nd_target_masked_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_ipv6_nd_target_masked.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_ipv6_nd_target_masked_init(of_oxm_ipv6_nd_target_masked_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_IPV6_ND_TARGET_MASKED] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_IPV6_ND_TARGET_MASKED] + of_object_extra_len[version][OF_OXM_IPV6_ND_TARGET_MASKED];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_IPV6_ND_TARGET_MASKED;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_ipv6_nd_tll */

/**
 * \defgroup of_oxm_ipv6_nd_tll of_oxm_ipv6_nd_tll
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_ipv6_nd_tll_push_wire_values(of_oxm_ipv6_nd_tll_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_IPV6_ND_TLL);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_ipv6_nd_tll object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_ipv6_nd_tll
 */

of_oxm_ipv6_nd_tll_t *
of_oxm_ipv6_nd_tll_new_(of_version_t version)
{
    of_oxm_ipv6_nd_tll_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_IPV6_ND_TLL] + of_object_extra_len[version][OF_OXM_IPV6_ND_TLL];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_ipv6_nd_tll_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_ipv6_nd_tll_init(obj, version, bytes, 0);

    if (of_oxm_ipv6_nd_tll_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_ipv6_nd_tll_t *
of_oxm_ipv6_nd_tll_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_ipv6_nd_tll_t *obj;

    obj = of_oxm_ipv6_nd_tll_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_ipv6_nd_tll.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_ipv6_nd_tll_init(of_oxm_ipv6_nd_tll_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_IPV6_ND_TLL] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_IPV6_ND_TLL] + of_object_extra_len[version][OF_OXM_IPV6_ND_TLL];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_IPV6_ND_TLL;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_ipv6_nd_tll_masked */

/**
 * \defgroup of_oxm_ipv6_nd_tll_masked of_oxm_ipv6_nd_tll_masked
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_ipv6_nd_tll_masked_push_wire_values(of_oxm_ipv6_nd_tll_masked_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_IPV6_ND_TLL_MASKED);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_ipv6_nd_tll_masked object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_ipv6_nd_tll_masked
 */

of_oxm_ipv6_nd_tll_masked_t *
of_oxm_ipv6_nd_tll_masked_new_(of_version_t version)
{
    of_oxm_ipv6_nd_tll_masked_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_IPV6_ND_TLL_MASKED] + of_object_extra_len[version][OF_OXM_IPV6_ND_TLL_MASKED];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_ipv6_nd_tll_masked_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_ipv6_nd_tll_masked_init(obj, version, bytes, 0);

    if (of_oxm_ipv6_nd_tll_masked_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_ipv6_nd_tll_masked_t *
of_oxm_ipv6_nd_tll_masked_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_ipv6_nd_tll_masked_t *obj;

    obj = of_oxm_ipv6_nd_tll_masked_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_ipv6_nd_tll_masked.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_ipv6_nd_tll_masked_init(of_oxm_ipv6_nd_tll_masked_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_IPV6_ND_TLL_MASKED] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_IPV6_ND_TLL_MASKED] + of_object_extra_len[version][OF_OXM_IPV6_ND_TLL_MASKED];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_IPV6_ND_TLL_MASKED;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_ipv6_src */

/**
 * \defgroup of_oxm_ipv6_src of_oxm_ipv6_src
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_ipv6_src_push_wire_values(of_oxm_ipv6_src_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_IPV6_SRC);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_ipv6_src object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_ipv6_src
 */

of_oxm_ipv6_src_t *
of_oxm_ipv6_src_new_(of_version_t version)
{
    of_oxm_ipv6_src_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_IPV6_SRC] + of_object_extra_len[version][OF_OXM_IPV6_SRC];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_ipv6_src_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_ipv6_src_init(obj, version, bytes, 0);

    if (of_oxm_ipv6_src_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_ipv6_src_t *
of_oxm_ipv6_src_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_ipv6_src_t *obj;

    obj = of_oxm_ipv6_src_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_ipv6_src.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_ipv6_src_init(of_oxm_ipv6_src_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_IPV6_SRC] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_IPV6_SRC] + of_object_extra_len[version][OF_OXM_IPV6_SRC];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_IPV6_SRC;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_ipv6_src_masked */

/**
 * \defgroup of_oxm_ipv6_src_masked of_oxm_ipv6_src_masked
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_ipv6_src_masked_push_wire_values(of_oxm_ipv6_src_masked_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_IPV6_SRC_MASKED);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_ipv6_src_masked object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_ipv6_src_masked
 */

of_oxm_ipv6_src_masked_t *
of_oxm_ipv6_src_masked_new_(of_version_t version)
{
    of_oxm_ipv6_src_masked_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_IPV6_SRC_MASKED] + of_object_extra_len[version][OF_OXM_IPV6_SRC_MASKED];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_ipv6_src_masked_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_ipv6_src_masked_init(obj, version, bytes, 0);

    if (of_oxm_ipv6_src_masked_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_ipv6_src_masked_t *
of_oxm_ipv6_src_masked_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_ipv6_src_masked_t *obj;

    obj = of_oxm_ipv6_src_masked_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_ipv6_src_masked.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_ipv6_src_masked_init(of_oxm_ipv6_src_masked_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_IPV6_SRC_MASKED] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_IPV6_SRC_MASKED] + of_object_extra_len[version][OF_OXM_IPV6_SRC_MASKED];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_IPV6_SRC_MASKED;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_metadata */

/**
 * \defgroup of_oxm_metadata of_oxm_metadata
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_metadata_push_wire_values(of_oxm_metadata_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_METADATA);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_metadata object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_metadata
 */

of_oxm_metadata_t *
of_oxm_metadata_new_(of_version_t version)
{
    of_oxm_metadata_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_METADATA] + of_object_extra_len[version][OF_OXM_METADATA];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_metadata_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_metadata_init(obj, version, bytes, 0);

    if (of_oxm_metadata_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_metadata_t *
of_oxm_metadata_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_metadata_t *obj;

    obj = of_oxm_metadata_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_metadata.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_metadata_init(of_oxm_metadata_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_METADATA] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_METADATA] + of_object_extra_len[version][OF_OXM_METADATA];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_METADATA;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_metadata_masked */

/**
 * \defgroup of_oxm_metadata_masked of_oxm_metadata_masked
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_metadata_masked_push_wire_values(of_oxm_metadata_masked_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_METADATA_MASKED);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_metadata_masked object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_metadata_masked
 */

of_oxm_metadata_masked_t *
of_oxm_metadata_masked_new_(of_version_t version)
{
    of_oxm_metadata_masked_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_METADATA_MASKED] + of_object_extra_len[version][OF_OXM_METADATA_MASKED];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_metadata_masked_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_metadata_masked_init(obj, version, bytes, 0);

    if (of_oxm_metadata_masked_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_metadata_masked_t *
of_oxm_metadata_masked_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_metadata_masked_t *obj;

    obj = of_oxm_metadata_masked_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_metadata_masked.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_metadata_masked_init(of_oxm_metadata_masked_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_METADATA_MASKED] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_METADATA_MASKED] + of_object_extra_len[version][OF_OXM_METADATA_MASKED];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_METADATA_MASKED;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_mpls_label */

/**
 * \defgroup of_oxm_mpls_label of_oxm_mpls_label
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_mpls_label_push_wire_values(of_oxm_mpls_label_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_MPLS_LABEL);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_mpls_label object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_mpls_label
 */

of_oxm_mpls_label_t *
of_oxm_mpls_label_new_(of_version_t version)
{
    of_oxm_mpls_label_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_MPLS_LABEL] + of_object_extra_len[version][OF_OXM_MPLS_LABEL];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_mpls_label_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_mpls_label_init(obj, version, bytes, 0);

    if (of_oxm_mpls_label_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_mpls_label_t *
of_oxm_mpls_label_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_mpls_label_t *obj;

    obj = of_oxm_mpls_label_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_mpls_label.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_mpls_label_init(of_oxm_mpls_label_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_MPLS_LABEL] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_MPLS_LABEL] + of_object_extra_len[version][OF_OXM_MPLS_LABEL];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_MPLS_LABEL;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_mpls_label_masked */

/**
 * \defgroup of_oxm_mpls_label_masked of_oxm_mpls_label_masked
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_mpls_label_masked_push_wire_values(of_oxm_mpls_label_masked_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_MPLS_LABEL_MASKED);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_mpls_label_masked object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_mpls_label_masked
 */

of_oxm_mpls_label_masked_t *
of_oxm_mpls_label_masked_new_(of_version_t version)
{
    of_oxm_mpls_label_masked_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_MPLS_LABEL_MASKED] + of_object_extra_len[version][OF_OXM_MPLS_LABEL_MASKED];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_mpls_label_masked_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_mpls_label_masked_init(obj, version, bytes, 0);

    if (of_oxm_mpls_label_masked_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_mpls_label_masked_t *
of_oxm_mpls_label_masked_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_mpls_label_masked_t *obj;

    obj = of_oxm_mpls_label_masked_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_mpls_label_masked.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_mpls_label_masked_init(of_oxm_mpls_label_masked_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_MPLS_LABEL_MASKED] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_MPLS_LABEL_MASKED] + of_object_extra_len[version][OF_OXM_MPLS_LABEL_MASKED];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_MPLS_LABEL_MASKED;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_mpls_tc */

/**
 * \defgroup of_oxm_mpls_tc of_oxm_mpls_tc
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_mpls_tc_push_wire_values(of_oxm_mpls_tc_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_MPLS_TC);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_mpls_tc object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_mpls_tc
 */

of_oxm_mpls_tc_t *
of_oxm_mpls_tc_new_(of_version_t version)
{
    of_oxm_mpls_tc_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_MPLS_TC] + of_object_extra_len[version][OF_OXM_MPLS_TC];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_mpls_tc_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_mpls_tc_init(obj, version, bytes, 0);

    if (of_oxm_mpls_tc_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_mpls_tc_t *
of_oxm_mpls_tc_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_mpls_tc_t *obj;

    obj = of_oxm_mpls_tc_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_mpls_tc.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_mpls_tc_init(of_oxm_mpls_tc_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_MPLS_TC] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_MPLS_TC] + of_object_extra_len[version][OF_OXM_MPLS_TC];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_MPLS_TC;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_mpls_tc_masked */

/**
 * \defgroup of_oxm_mpls_tc_masked of_oxm_mpls_tc_masked
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_mpls_tc_masked_push_wire_values(of_oxm_mpls_tc_masked_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_MPLS_TC_MASKED);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_mpls_tc_masked object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_mpls_tc_masked
 */

of_oxm_mpls_tc_masked_t *
of_oxm_mpls_tc_masked_new_(of_version_t version)
{
    of_oxm_mpls_tc_masked_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_MPLS_TC_MASKED] + of_object_extra_len[version][OF_OXM_MPLS_TC_MASKED];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_mpls_tc_masked_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_mpls_tc_masked_init(obj, version, bytes, 0);

    if (of_oxm_mpls_tc_masked_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_mpls_tc_masked_t *
of_oxm_mpls_tc_masked_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_mpls_tc_masked_t *obj;

    obj = of_oxm_mpls_tc_masked_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_mpls_tc_masked.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_mpls_tc_masked_init(of_oxm_mpls_tc_masked_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_MPLS_TC_MASKED] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_MPLS_TC_MASKED] + of_object_extra_len[version][OF_OXM_MPLS_TC_MASKED];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_MPLS_TC_MASKED;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_sctp_dst */

/**
 * \defgroup of_oxm_sctp_dst of_oxm_sctp_dst
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_sctp_dst_push_wire_values(of_oxm_sctp_dst_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_SCTP_DST);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_sctp_dst object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_sctp_dst
 */

of_oxm_sctp_dst_t *
of_oxm_sctp_dst_new_(of_version_t version)
{
    of_oxm_sctp_dst_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_SCTP_DST] + of_object_extra_len[version][OF_OXM_SCTP_DST];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_sctp_dst_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_sctp_dst_init(obj, version, bytes, 0);

    if (of_oxm_sctp_dst_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_sctp_dst_t *
of_oxm_sctp_dst_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_sctp_dst_t *obj;

    obj = of_oxm_sctp_dst_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_sctp_dst.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_sctp_dst_init(of_oxm_sctp_dst_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_SCTP_DST] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_SCTP_DST] + of_object_extra_len[version][OF_OXM_SCTP_DST];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_SCTP_DST;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_sctp_dst_masked */

/**
 * \defgroup of_oxm_sctp_dst_masked of_oxm_sctp_dst_masked
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_sctp_dst_masked_push_wire_values(of_oxm_sctp_dst_masked_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_SCTP_DST_MASKED);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_sctp_dst_masked object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_sctp_dst_masked
 */

of_oxm_sctp_dst_masked_t *
of_oxm_sctp_dst_masked_new_(of_version_t version)
{
    of_oxm_sctp_dst_masked_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_SCTP_DST_MASKED] + of_object_extra_len[version][OF_OXM_SCTP_DST_MASKED];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_sctp_dst_masked_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_sctp_dst_masked_init(obj, version, bytes, 0);

    if (of_oxm_sctp_dst_masked_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_sctp_dst_masked_t *
of_oxm_sctp_dst_masked_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_sctp_dst_masked_t *obj;

    obj = of_oxm_sctp_dst_masked_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_sctp_dst_masked.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_sctp_dst_masked_init(of_oxm_sctp_dst_masked_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_SCTP_DST_MASKED] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_SCTP_DST_MASKED] + of_object_extra_len[version][OF_OXM_SCTP_DST_MASKED];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_SCTP_DST_MASKED;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_sctp_src */

/**
 * \defgroup of_oxm_sctp_src of_oxm_sctp_src
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_sctp_src_push_wire_values(of_oxm_sctp_src_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_SCTP_SRC);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_sctp_src object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_sctp_src
 */

of_oxm_sctp_src_t *
of_oxm_sctp_src_new_(of_version_t version)
{
    of_oxm_sctp_src_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_SCTP_SRC] + of_object_extra_len[version][OF_OXM_SCTP_SRC];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_sctp_src_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_sctp_src_init(obj, version, bytes, 0);

    if (of_oxm_sctp_src_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_sctp_src_t *
of_oxm_sctp_src_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_sctp_src_t *obj;

    obj = of_oxm_sctp_src_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_sctp_src.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_sctp_src_init(of_oxm_sctp_src_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_SCTP_SRC] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_SCTP_SRC] + of_object_extra_len[version][OF_OXM_SCTP_SRC];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_SCTP_SRC;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_sctp_src_masked */

/**
 * \defgroup of_oxm_sctp_src_masked of_oxm_sctp_src_masked
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_sctp_src_masked_push_wire_values(of_oxm_sctp_src_masked_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_SCTP_SRC_MASKED);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_sctp_src_masked object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_sctp_src_masked
 */

of_oxm_sctp_src_masked_t *
of_oxm_sctp_src_masked_new_(of_version_t version)
{
    of_oxm_sctp_src_masked_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_SCTP_SRC_MASKED] + of_object_extra_len[version][OF_OXM_SCTP_SRC_MASKED];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_sctp_src_masked_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_sctp_src_masked_init(obj, version, bytes, 0);

    if (of_oxm_sctp_src_masked_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_sctp_src_masked_t *
of_oxm_sctp_src_masked_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_sctp_src_masked_t *obj;

    obj = of_oxm_sctp_src_masked_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_sctp_src_masked.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_sctp_src_masked_init(of_oxm_sctp_src_masked_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_SCTP_SRC_MASKED] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_SCTP_SRC_MASKED] + of_object_extra_len[version][OF_OXM_SCTP_SRC_MASKED];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_SCTP_SRC_MASKED;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_tcp_dst */

/**
 * \defgroup of_oxm_tcp_dst of_oxm_tcp_dst
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_tcp_dst_push_wire_values(of_oxm_tcp_dst_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_TCP_DST);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_tcp_dst object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_tcp_dst
 */

of_oxm_tcp_dst_t *
of_oxm_tcp_dst_new_(of_version_t version)
{
    of_oxm_tcp_dst_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_TCP_DST] + of_object_extra_len[version][OF_OXM_TCP_DST];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_tcp_dst_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_tcp_dst_init(obj, version, bytes, 0);

    if (of_oxm_tcp_dst_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_tcp_dst_t *
of_oxm_tcp_dst_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_tcp_dst_t *obj;

    obj = of_oxm_tcp_dst_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_tcp_dst.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_tcp_dst_init(of_oxm_tcp_dst_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_TCP_DST] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_TCP_DST] + of_object_extra_len[version][OF_OXM_TCP_DST];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_TCP_DST;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_tcp_dst_masked */

/**
 * \defgroup of_oxm_tcp_dst_masked of_oxm_tcp_dst_masked
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_tcp_dst_masked_push_wire_values(of_oxm_tcp_dst_masked_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_TCP_DST_MASKED);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_tcp_dst_masked object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_tcp_dst_masked
 */

of_oxm_tcp_dst_masked_t *
of_oxm_tcp_dst_masked_new_(of_version_t version)
{
    of_oxm_tcp_dst_masked_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_TCP_DST_MASKED] + of_object_extra_len[version][OF_OXM_TCP_DST_MASKED];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_tcp_dst_masked_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_tcp_dst_masked_init(obj, version, bytes, 0);

    if (of_oxm_tcp_dst_masked_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_tcp_dst_masked_t *
of_oxm_tcp_dst_masked_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_tcp_dst_masked_t *obj;

    obj = of_oxm_tcp_dst_masked_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_tcp_dst_masked.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_tcp_dst_masked_init(of_oxm_tcp_dst_masked_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_TCP_DST_MASKED] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_TCP_DST_MASKED] + of_object_extra_len[version][OF_OXM_TCP_DST_MASKED];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_TCP_DST_MASKED;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_tcp_src */

/**
 * \defgroup of_oxm_tcp_src of_oxm_tcp_src
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_tcp_src_push_wire_values(of_oxm_tcp_src_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_TCP_SRC);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_tcp_src object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_tcp_src
 */

of_oxm_tcp_src_t *
of_oxm_tcp_src_new_(of_version_t version)
{
    of_oxm_tcp_src_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_TCP_SRC] + of_object_extra_len[version][OF_OXM_TCP_SRC];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_tcp_src_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_tcp_src_init(obj, version, bytes, 0);

    if (of_oxm_tcp_src_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_tcp_src_t *
of_oxm_tcp_src_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_tcp_src_t *obj;

    obj = of_oxm_tcp_src_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_tcp_src.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_tcp_src_init(of_oxm_tcp_src_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_TCP_SRC] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_TCP_SRC] + of_object_extra_len[version][OF_OXM_TCP_SRC];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_TCP_SRC;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_tcp_src_masked */

/**
 * \defgroup of_oxm_tcp_src_masked of_oxm_tcp_src_masked
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_tcp_src_masked_push_wire_values(of_oxm_tcp_src_masked_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_TCP_SRC_MASKED);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_tcp_src_masked object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_tcp_src_masked
 */

of_oxm_tcp_src_masked_t *
of_oxm_tcp_src_masked_new_(of_version_t version)
{
    of_oxm_tcp_src_masked_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_TCP_SRC_MASKED] + of_object_extra_len[version][OF_OXM_TCP_SRC_MASKED];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_tcp_src_masked_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_tcp_src_masked_init(obj, version, bytes, 0);

    if (of_oxm_tcp_src_masked_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_tcp_src_masked_t *
of_oxm_tcp_src_masked_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_tcp_src_masked_t *obj;

    obj = of_oxm_tcp_src_masked_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_tcp_src_masked.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_tcp_src_masked_init(of_oxm_tcp_src_masked_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_TCP_SRC_MASKED] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_TCP_SRC_MASKED] + of_object_extra_len[version][OF_OXM_TCP_SRC_MASKED];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_TCP_SRC_MASKED;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_udp_dst */

/**
 * \defgroup of_oxm_udp_dst of_oxm_udp_dst
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_udp_dst_push_wire_values(of_oxm_udp_dst_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_UDP_DST);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_udp_dst object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_udp_dst
 */

of_oxm_udp_dst_t *
of_oxm_udp_dst_new_(of_version_t version)
{
    of_oxm_udp_dst_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_UDP_DST] + of_object_extra_len[version][OF_OXM_UDP_DST];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_udp_dst_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_udp_dst_init(obj, version, bytes, 0);

    if (of_oxm_udp_dst_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_udp_dst_t *
of_oxm_udp_dst_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_udp_dst_t *obj;

    obj = of_oxm_udp_dst_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_udp_dst.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_udp_dst_init(of_oxm_udp_dst_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_UDP_DST] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_UDP_DST] + of_object_extra_len[version][OF_OXM_UDP_DST];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_UDP_DST;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_udp_dst_masked */

/**
 * \defgroup of_oxm_udp_dst_masked of_oxm_udp_dst_masked
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_udp_dst_masked_push_wire_values(of_oxm_udp_dst_masked_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_UDP_DST_MASKED);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_udp_dst_masked object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_udp_dst_masked
 */

of_oxm_udp_dst_masked_t *
of_oxm_udp_dst_masked_new_(of_version_t version)
{
    of_oxm_udp_dst_masked_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_UDP_DST_MASKED] + of_object_extra_len[version][OF_OXM_UDP_DST_MASKED];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_udp_dst_masked_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_udp_dst_masked_init(obj, version, bytes, 0);

    if (of_oxm_udp_dst_masked_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_udp_dst_masked_t *
of_oxm_udp_dst_masked_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_udp_dst_masked_t *obj;

    obj = of_oxm_udp_dst_masked_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_udp_dst_masked.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_udp_dst_masked_init(of_oxm_udp_dst_masked_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_UDP_DST_MASKED] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_UDP_DST_MASKED] + of_object_extra_len[version][OF_OXM_UDP_DST_MASKED];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_UDP_DST_MASKED;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_udp_src */

/**
 * \defgroup of_oxm_udp_src of_oxm_udp_src
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_udp_src_push_wire_values(of_oxm_udp_src_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_UDP_SRC);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_udp_src object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_udp_src
 */

of_oxm_udp_src_t *
of_oxm_udp_src_new_(of_version_t version)
{
    of_oxm_udp_src_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_UDP_SRC] + of_object_extra_len[version][OF_OXM_UDP_SRC];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_udp_src_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_udp_src_init(obj, version, bytes, 0);

    if (of_oxm_udp_src_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_udp_src_t *
of_oxm_udp_src_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_udp_src_t *obj;

    obj = of_oxm_udp_src_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_udp_src.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_udp_src_init(of_oxm_udp_src_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_UDP_SRC] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_UDP_SRC] + of_object_extra_len[version][OF_OXM_UDP_SRC];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_UDP_SRC;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_udp_src_masked */

/**
 * \defgroup of_oxm_udp_src_masked of_oxm_udp_src_masked
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_udp_src_masked_push_wire_values(of_oxm_udp_src_masked_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_UDP_SRC_MASKED);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_udp_src_masked object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_udp_src_masked
 */

of_oxm_udp_src_masked_t *
of_oxm_udp_src_masked_new_(of_version_t version)
{
    of_oxm_udp_src_masked_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_UDP_SRC_MASKED] + of_object_extra_len[version][OF_OXM_UDP_SRC_MASKED];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_udp_src_masked_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_udp_src_masked_init(obj, version, bytes, 0);

    if (of_oxm_udp_src_masked_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_udp_src_masked_t *
of_oxm_udp_src_masked_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_udp_src_masked_t *obj;

    obj = of_oxm_udp_src_masked_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_udp_src_masked.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_udp_src_masked_init(of_oxm_udp_src_masked_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_UDP_SRC_MASKED] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_UDP_SRC_MASKED] + of_object_extra_len[version][OF_OXM_UDP_SRC_MASKED];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_UDP_SRC_MASKED;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_vlan_pcp */

/**
 * \defgroup of_oxm_vlan_pcp of_oxm_vlan_pcp
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_vlan_pcp_push_wire_values(of_oxm_vlan_pcp_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_VLAN_PCP);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_vlan_pcp object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_vlan_pcp
 */

of_oxm_vlan_pcp_t *
of_oxm_vlan_pcp_new_(of_version_t version)
{
    of_oxm_vlan_pcp_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_VLAN_PCP] + of_object_extra_len[version][OF_OXM_VLAN_PCP];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_vlan_pcp_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_vlan_pcp_init(obj, version, bytes, 0);

    if (of_oxm_vlan_pcp_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_vlan_pcp_t *
of_oxm_vlan_pcp_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_vlan_pcp_t *obj;

    obj = of_oxm_vlan_pcp_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_vlan_pcp.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_vlan_pcp_init(of_oxm_vlan_pcp_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_VLAN_PCP] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_VLAN_PCP] + of_object_extra_len[version][OF_OXM_VLAN_PCP];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_VLAN_PCP;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_vlan_pcp_masked */

/**
 * \defgroup of_oxm_vlan_pcp_masked of_oxm_vlan_pcp_masked
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_vlan_pcp_masked_push_wire_values(of_oxm_vlan_pcp_masked_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_VLAN_PCP_MASKED);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_vlan_pcp_masked object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_vlan_pcp_masked
 */

of_oxm_vlan_pcp_masked_t *
of_oxm_vlan_pcp_masked_new_(of_version_t version)
{
    of_oxm_vlan_pcp_masked_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_VLAN_PCP_MASKED] + of_object_extra_len[version][OF_OXM_VLAN_PCP_MASKED];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_vlan_pcp_masked_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_vlan_pcp_masked_init(obj, version, bytes, 0);

    if (of_oxm_vlan_pcp_masked_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_vlan_pcp_masked_t *
of_oxm_vlan_pcp_masked_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_vlan_pcp_masked_t *obj;

    obj = of_oxm_vlan_pcp_masked_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_vlan_pcp_masked.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_vlan_pcp_masked_init(of_oxm_vlan_pcp_masked_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_VLAN_PCP_MASKED] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_VLAN_PCP_MASKED] + of_object_extra_len[version][OF_OXM_VLAN_PCP_MASKED];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_VLAN_PCP_MASKED;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_vlan_vid */

/**
 * \defgroup of_oxm_vlan_vid of_oxm_vlan_vid
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_vlan_vid_push_wire_values(of_oxm_vlan_vid_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_VLAN_VID);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_vlan_vid object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_vlan_vid
 */

of_oxm_vlan_vid_t *
of_oxm_vlan_vid_new_(of_version_t version)
{
    of_oxm_vlan_vid_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_VLAN_VID] + of_object_extra_len[version][OF_OXM_VLAN_VID];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_vlan_vid_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_vlan_vid_init(obj, version, bytes, 0);

    if (of_oxm_vlan_vid_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_vlan_vid_t *
of_oxm_vlan_vid_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_vlan_vid_t *obj;

    obj = of_oxm_vlan_vid_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_vlan_vid.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_vlan_vid_init(of_oxm_vlan_vid_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_VLAN_VID] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_VLAN_VID] + of_object_extra_len[version][OF_OXM_VLAN_VID];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_VLAN_VID;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_oxm_vlan_vid_masked */

/**
 * \defgroup of_oxm_vlan_vid_masked of_oxm_vlan_vid_masked
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_oxm_vlan_vid_masked_push_wire_values(of_oxm_vlan_vid_masked_t *obj)
{
    /* OXM obj; set length and type */
    of_oxm_wire_length_set((of_object_t *)obj, obj->length);
    of_oxm_wire_object_id_set((of_object_t *)obj, OF_OXM_VLAN_VID_MASKED);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_oxm_vlan_vid_masked object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_oxm_vlan_vid_masked
 */

of_oxm_vlan_vid_masked_t *
of_oxm_vlan_vid_masked_new_(of_version_t version)
{
    of_oxm_vlan_vid_masked_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_OXM_VLAN_VID_MASKED] + of_object_extra_len[version][OF_OXM_VLAN_VID_MASKED];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_oxm_vlan_vid_masked_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_oxm_vlan_vid_masked_init(obj, version, bytes, 0);

    if (of_oxm_vlan_vid_masked_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_oxm_vlan_vid_masked_t *
of_oxm_vlan_vid_masked_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_oxm_vlan_vid_masked_t *obj;

    obj = of_oxm_vlan_vid_masked_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_oxm_vlan_vid_masked.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_oxm_vlan_vid_masked_init(of_oxm_vlan_vid_masked_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_OXM_VLAN_VID_MASKED] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_OXM_VLAN_VID_MASKED] + of_object_extra_len[version][OF_OXM_VLAN_VID_MASKED];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_OXM_VLAN_VID_MASKED;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_oxm_wire_length_get;
    obj->wire_length_set = of_oxm_wire_length_set;
    obj->wire_type_get = of_oxm_wire_object_id_get;
    obj->wire_type_set = of_oxm_wire_object_id_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_packet_queue */

/**
 * \defgroup of_packet_queue of_packet_queue
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_packet_queue_push_wire_values(of_packet_queue_t *obj)
{

    obj->wire_length_set((of_object_t *)obj, obj->length);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_packet_queue object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_packet_queue
 */

of_packet_queue_t *
of_packet_queue_new_(of_version_t version)
{
    of_packet_queue_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_PACKET_QUEUE] + of_object_extra_len[version][OF_PACKET_QUEUE];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_packet_queue_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_packet_queue_init(obj, version, bytes, 0);

    if (of_packet_queue_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_packet_queue_t *
of_packet_queue_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_packet_queue_t *obj;

    obj = of_packet_queue_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_packet_queue.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_packet_queue_init(of_packet_queue_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_PACKET_QUEUE] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_PACKET_QUEUE] + of_object_extra_len[version][OF_PACKET_QUEUE];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_PACKET_QUEUE;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_packet_queue_wire_length_get;
    obj->wire_length_set = of_packet_queue_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_port_desc */

/**
 * \defgroup of_port_desc of_port_desc
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_port_desc_push_wire_values(of_port_desc_t *obj)
{

    return OF_ERROR_NONE;
}

/**
 * Create a new of_port_desc object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_port_desc
 */

of_port_desc_t *
of_port_desc_new_(of_version_t version)
{
    of_port_desc_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_PORT_DESC] + of_object_extra_len[version][OF_PORT_DESC];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_port_desc_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_port_desc_init(obj, version, bytes, 0);

    if (of_port_desc_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_port_desc_t *
of_port_desc_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_port_desc_t *obj;

    obj = of_port_desc_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_port_desc.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_port_desc_init(of_port_desc_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_PORT_DESC] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_PORT_DESC] + of_object_extra_len[version][OF_PORT_DESC];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_PORT_DESC;

    /* Set up the object's function pointers */

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_port_stats_entry */

/**
 * \defgroup of_port_stats_entry of_port_stats_entry
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_port_stats_entry_push_wire_values(of_port_stats_entry_t *obj)
{

    return OF_ERROR_NONE;
}

/**
 * Create a new of_port_stats_entry object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_port_stats_entry
 */

of_port_stats_entry_t *
of_port_stats_entry_new_(of_version_t version)
{
    of_port_stats_entry_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_PORT_STATS_ENTRY] + of_object_extra_len[version][OF_PORT_STATS_ENTRY];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_port_stats_entry_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_port_stats_entry_init(obj, version, bytes, 0);

    if (of_port_stats_entry_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_port_stats_entry_t *
of_port_stats_entry_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_port_stats_entry_t *obj;

    obj = of_port_stats_entry_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_port_stats_entry.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_port_stats_entry_init(of_port_stats_entry_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_PORT_STATS_ENTRY] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_PORT_STATS_ENTRY] + of_object_extra_len[version][OF_PORT_STATS_ENTRY];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_PORT_STATS_ENTRY;

    /* Set up the object's function pointers */

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_queue_prop */

/**
 * \defgroup of_queue_prop of_queue_prop
 */

/**
 * Create a new of_queue_prop object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_queue_prop
 */

of_queue_prop_t *
of_queue_prop_new_(of_version_t version)
{
    of_queue_prop_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_QUEUE_PROP] + of_object_extra_len[version][OF_QUEUE_PROP];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_queue_prop_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_queue_prop_init(obj, version, bytes, 0);

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_queue_prop_t *
of_queue_prop_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_queue_prop_t *obj;

    obj = of_queue_prop_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_queue_prop.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_queue_prop_init(of_queue_prop_t *obj_p,
    of_version_t version, int bytes, int clean_wire)
{
    of_queue_prop_header_t *obj;

    obj = &obj_p->header;  /* Need instantiable subclass */

    ASSERT(of_object_fixed_len[version][OF_QUEUE_PROP] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_QUEUE_PROP] + of_object_extra_len[version][OF_QUEUE_PROP];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_QUEUE_PROP;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_queue_prop_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_queue_prop_experimenter */

/**
 * \defgroup of_queue_prop_experimenter of_queue_prop_experimenter
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_queue_prop_experimenter_push_wire_values(of_queue_prop_experimenter_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_QUEUE_PROP_EXPERIMENTER);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_queue_prop_experimenter object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_queue_prop_experimenter
 */

of_queue_prop_experimenter_t *
of_queue_prop_experimenter_new_(of_version_t version)
{
    of_queue_prop_experimenter_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_QUEUE_PROP_EXPERIMENTER] + of_object_extra_len[version][OF_QUEUE_PROP_EXPERIMENTER];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_queue_prop_experimenter_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_queue_prop_experimenter_init(obj, version, bytes, 0);

    if (of_queue_prop_experimenter_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_queue_prop_experimenter_t *
of_queue_prop_experimenter_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_queue_prop_experimenter_t *obj;

    obj = of_queue_prop_experimenter_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_queue_prop_experimenter.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_queue_prop_experimenter_init(of_queue_prop_experimenter_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_QUEUE_PROP_EXPERIMENTER] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_QUEUE_PROP_EXPERIMENTER] + of_object_extra_len[version][OF_QUEUE_PROP_EXPERIMENTER];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_QUEUE_PROP_EXPERIMENTER;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_queue_prop_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_queue_prop_header */

/**
 * \defgroup of_queue_prop_header of_queue_prop_header
 */

/**
 * Create a new of_queue_prop_header object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_queue_prop_header
 */

of_queue_prop_header_t *
of_queue_prop_header_new_(of_version_t version)
{
    of_queue_prop_header_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_QUEUE_PROP_HEADER] + of_object_extra_len[version][OF_QUEUE_PROP_HEADER];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_queue_prop_header_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_queue_prop_header_init(obj, version, bytes, 0);

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_queue_prop_header_t *
of_queue_prop_header_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_queue_prop_header_t *obj;

    obj = of_queue_prop_header_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_queue_prop_header.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_queue_prop_header_init(of_queue_prop_header_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_QUEUE_PROP_HEADER] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_QUEUE_PROP_HEADER] + of_object_extra_len[version][OF_QUEUE_PROP_HEADER];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_QUEUE_PROP_HEADER;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_queue_prop_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_queue_prop_max_rate */

/**
 * \defgroup of_queue_prop_max_rate of_queue_prop_max_rate
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_queue_prop_max_rate_push_wire_values(of_queue_prop_max_rate_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_QUEUE_PROP_MAX_RATE);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_queue_prop_max_rate object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_queue_prop_max_rate
 */

of_queue_prop_max_rate_t *
of_queue_prop_max_rate_new_(of_version_t version)
{
    of_queue_prop_max_rate_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_QUEUE_PROP_MAX_RATE] + of_object_extra_len[version][OF_QUEUE_PROP_MAX_RATE];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_queue_prop_max_rate_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_queue_prop_max_rate_init(obj, version, bytes, 0);

    if (of_queue_prop_max_rate_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_queue_prop_max_rate_t *
of_queue_prop_max_rate_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_queue_prop_max_rate_t *obj;

    obj = of_queue_prop_max_rate_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_queue_prop_max_rate.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_queue_prop_max_rate_init(of_queue_prop_max_rate_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_QUEUE_PROP_MAX_RATE] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_QUEUE_PROP_MAX_RATE] + of_object_extra_len[version][OF_QUEUE_PROP_MAX_RATE];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_QUEUE_PROP_MAX_RATE;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_queue_prop_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_queue_prop_min_rate */

/**
 * \defgroup of_queue_prop_min_rate of_queue_prop_min_rate
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_queue_prop_min_rate_push_wire_values(of_queue_prop_min_rate_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_QUEUE_PROP_MIN_RATE);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_queue_prop_min_rate object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_queue_prop_min_rate
 */

of_queue_prop_min_rate_t *
of_queue_prop_min_rate_new_(of_version_t version)
{
    of_queue_prop_min_rate_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_QUEUE_PROP_MIN_RATE] + of_object_extra_len[version][OF_QUEUE_PROP_MIN_RATE];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_queue_prop_min_rate_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_queue_prop_min_rate_init(obj, version, bytes, 0);

    if (of_queue_prop_min_rate_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_queue_prop_min_rate_t *
of_queue_prop_min_rate_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_queue_prop_min_rate_t *obj;

    obj = of_queue_prop_min_rate_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_queue_prop_min_rate.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_queue_prop_min_rate_init(of_queue_prop_min_rate_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_QUEUE_PROP_MIN_RATE] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_QUEUE_PROP_MIN_RATE] + of_object_extra_len[version][OF_QUEUE_PROP_MIN_RATE];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_QUEUE_PROP_MIN_RATE;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_queue_prop_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_queue_stats_entry */

/**
 * \defgroup of_queue_stats_entry of_queue_stats_entry
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_queue_stats_entry_push_wire_values(of_queue_stats_entry_t *obj)
{

    return OF_ERROR_NONE;
}

/**
 * Create a new of_queue_stats_entry object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_queue_stats_entry
 */

of_queue_stats_entry_t *
of_queue_stats_entry_new_(of_version_t version)
{
    of_queue_stats_entry_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_QUEUE_STATS_ENTRY] + of_object_extra_len[version][OF_QUEUE_STATS_ENTRY];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_queue_stats_entry_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_queue_stats_entry_init(obj, version, bytes, 0);

    if (of_queue_stats_entry_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_queue_stats_entry_t *
of_queue_stats_entry_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_queue_stats_entry_t *obj;

    obj = of_queue_stats_entry_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_queue_stats_entry.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_queue_stats_entry_init(of_queue_stats_entry_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_QUEUE_STATS_ENTRY] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_QUEUE_STATS_ENTRY] + of_object_extra_len[version][OF_QUEUE_STATS_ENTRY];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_QUEUE_STATS_ENTRY;

    /* Set up the object's function pointers */

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_table_feature_prop */

/**
 * \defgroup of_table_feature_prop of_table_feature_prop
 */

/**
 * Create a new of_table_feature_prop object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_table_feature_prop
 */

of_table_feature_prop_t *
of_table_feature_prop_new_(of_version_t version)
{
    of_table_feature_prop_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_TABLE_FEATURE_PROP] + of_object_extra_len[version][OF_TABLE_FEATURE_PROP];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_table_feature_prop_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_table_feature_prop_init(obj, version, bytes, 0);

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_table_feature_prop_t *
of_table_feature_prop_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_table_feature_prop_t *obj;

    obj = of_table_feature_prop_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_table_feature_prop.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_table_feature_prop_init(of_table_feature_prop_t *obj_p,
    of_version_t version, int bytes, int clean_wire)
{
    of_table_feature_prop_header_t *obj;

    obj = &obj_p->header;  /* Need instantiable subclass */

    ASSERT(of_object_fixed_len[version][OF_TABLE_FEATURE_PROP] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_TABLE_FEATURE_PROP] + of_object_extra_len[version][OF_TABLE_FEATURE_PROP];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_TABLE_FEATURE_PROP;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_table_feature_prop_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_table_feature_prop_apply_actions */

/**
 * \defgroup of_table_feature_prop_apply_actions of_table_feature_prop_apply_actions
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_table_feature_prop_apply_actions_push_wire_values(of_table_feature_prop_apply_actions_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_TABLE_FEATURE_PROP_APPLY_ACTIONS);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_table_feature_prop_apply_actions object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_table_feature_prop_apply_actions
 */

of_table_feature_prop_apply_actions_t *
of_table_feature_prop_apply_actions_new_(of_version_t version)
{
    of_table_feature_prop_apply_actions_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_TABLE_FEATURE_PROP_APPLY_ACTIONS] + of_object_extra_len[version][OF_TABLE_FEATURE_PROP_APPLY_ACTIONS];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_table_feature_prop_apply_actions_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_table_feature_prop_apply_actions_init(obj, version, bytes, 0);

    if (of_table_feature_prop_apply_actions_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_table_feature_prop_apply_actions_t *
of_table_feature_prop_apply_actions_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_table_feature_prop_apply_actions_t *obj;

    obj = of_table_feature_prop_apply_actions_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_table_feature_prop_apply_actions.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_table_feature_prop_apply_actions_init(of_table_feature_prop_apply_actions_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_TABLE_FEATURE_PROP_APPLY_ACTIONS] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_TABLE_FEATURE_PROP_APPLY_ACTIONS] + of_object_extra_len[version][OF_TABLE_FEATURE_PROP_APPLY_ACTIONS];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_TABLE_FEATURE_PROP_APPLY_ACTIONS;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_table_feature_prop_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_table_feature_prop_apply_actions_miss */

/**
 * \defgroup of_table_feature_prop_apply_actions_miss of_table_feature_prop_apply_actions_miss
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_table_feature_prop_apply_actions_miss_push_wire_values(of_table_feature_prop_apply_actions_miss_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_TABLE_FEATURE_PROP_APPLY_ACTIONS_MISS);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_table_feature_prop_apply_actions_miss object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_table_feature_prop_apply_actions_miss
 */

of_table_feature_prop_apply_actions_miss_t *
of_table_feature_prop_apply_actions_miss_new_(of_version_t version)
{
    of_table_feature_prop_apply_actions_miss_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_TABLE_FEATURE_PROP_APPLY_ACTIONS_MISS] + of_object_extra_len[version][OF_TABLE_FEATURE_PROP_APPLY_ACTIONS_MISS];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_table_feature_prop_apply_actions_miss_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_table_feature_prop_apply_actions_miss_init(obj, version, bytes, 0);

    if (of_table_feature_prop_apply_actions_miss_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_table_feature_prop_apply_actions_miss_t *
of_table_feature_prop_apply_actions_miss_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_table_feature_prop_apply_actions_miss_t *obj;

    obj = of_table_feature_prop_apply_actions_miss_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_table_feature_prop_apply_actions_miss.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_table_feature_prop_apply_actions_miss_init(of_table_feature_prop_apply_actions_miss_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_TABLE_FEATURE_PROP_APPLY_ACTIONS_MISS] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_TABLE_FEATURE_PROP_APPLY_ACTIONS_MISS] + of_object_extra_len[version][OF_TABLE_FEATURE_PROP_APPLY_ACTIONS_MISS];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_TABLE_FEATURE_PROP_APPLY_ACTIONS_MISS;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_table_feature_prop_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_table_feature_prop_apply_setfield */

/**
 * \defgroup of_table_feature_prop_apply_setfield of_table_feature_prop_apply_setfield
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_table_feature_prop_apply_setfield_push_wire_values(of_table_feature_prop_apply_setfield_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_TABLE_FEATURE_PROP_APPLY_SETFIELD);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_table_feature_prop_apply_setfield object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_table_feature_prop_apply_setfield
 */

of_table_feature_prop_apply_setfield_t *
of_table_feature_prop_apply_setfield_new_(of_version_t version)
{
    of_table_feature_prop_apply_setfield_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_TABLE_FEATURE_PROP_APPLY_SETFIELD] + of_object_extra_len[version][OF_TABLE_FEATURE_PROP_APPLY_SETFIELD];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_table_feature_prop_apply_setfield_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_table_feature_prop_apply_setfield_init(obj, version, bytes, 0);

    if (of_table_feature_prop_apply_setfield_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_table_feature_prop_apply_setfield_t *
of_table_feature_prop_apply_setfield_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_table_feature_prop_apply_setfield_t *obj;

    obj = of_table_feature_prop_apply_setfield_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_table_feature_prop_apply_setfield.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_table_feature_prop_apply_setfield_init(of_table_feature_prop_apply_setfield_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_TABLE_FEATURE_PROP_APPLY_SETFIELD] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_TABLE_FEATURE_PROP_APPLY_SETFIELD] + of_object_extra_len[version][OF_TABLE_FEATURE_PROP_APPLY_SETFIELD];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_TABLE_FEATURE_PROP_APPLY_SETFIELD;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_table_feature_prop_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_table_feature_prop_apply_setfield_miss */

/**
 * \defgroup of_table_feature_prop_apply_setfield_miss of_table_feature_prop_apply_setfield_miss
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_table_feature_prop_apply_setfield_miss_push_wire_values(of_table_feature_prop_apply_setfield_miss_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_TABLE_FEATURE_PROP_APPLY_SETFIELD_MISS);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_table_feature_prop_apply_setfield_miss object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_table_feature_prop_apply_setfield_miss
 */

of_table_feature_prop_apply_setfield_miss_t *
of_table_feature_prop_apply_setfield_miss_new_(of_version_t version)
{
    of_table_feature_prop_apply_setfield_miss_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_TABLE_FEATURE_PROP_APPLY_SETFIELD_MISS] + of_object_extra_len[version][OF_TABLE_FEATURE_PROP_APPLY_SETFIELD_MISS];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_table_feature_prop_apply_setfield_miss_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_table_feature_prop_apply_setfield_miss_init(obj, version, bytes, 0);

    if (of_table_feature_prop_apply_setfield_miss_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_table_feature_prop_apply_setfield_miss_t *
of_table_feature_prop_apply_setfield_miss_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_table_feature_prop_apply_setfield_miss_t *obj;

    obj = of_table_feature_prop_apply_setfield_miss_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_table_feature_prop_apply_setfield_miss.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_table_feature_prop_apply_setfield_miss_init(of_table_feature_prop_apply_setfield_miss_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_TABLE_FEATURE_PROP_APPLY_SETFIELD_MISS] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_TABLE_FEATURE_PROP_APPLY_SETFIELD_MISS] + of_object_extra_len[version][OF_TABLE_FEATURE_PROP_APPLY_SETFIELD_MISS];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_TABLE_FEATURE_PROP_APPLY_SETFIELD_MISS;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_table_feature_prop_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_table_feature_prop_experimenter */

/**
 * \defgroup of_table_feature_prop_experimenter of_table_feature_prop_experimenter
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_table_feature_prop_experimenter_push_wire_values(of_table_feature_prop_experimenter_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_TABLE_FEATURE_PROP_EXPERIMENTER);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_table_feature_prop_experimenter object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_table_feature_prop_experimenter
 */

of_table_feature_prop_experimenter_t *
of_table_feature_prop_experimenter_new_(of_version_t version)
{
    of_table_feature_prop_experimenter_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_TABLE_FEATURE_PROP_EXPERIMENTER] + of_object_extra_len[version][OF_TABLE_FEATURE_PROP_EXPERIMENTER];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_table_feature_prop_experimenter_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_table_feature_prop_experimenter_init(obj, version, bytes, 0);

    if (of_table_feature_prop_experimenter_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_table_feature_prop_experimenter_t *
of_table_feature_prop_experimenter_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_table_feature_prop_experimenter_t *obj;

    obj = of_table_feature_prop_experimenter_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_table_feature_prop_experimenter.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_table_feature_prop_experimenter_init(of_table_feature_prop_experimenter_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_TABLE_FEATURE_PROP_EXPERIMENTER] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_TABLE_FEATURE_PROP_EXPERIMENTER] + of_object_extra_len[version][OF_TABLE_FEATURE_PROP_EXPERIMENTER];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_TABLE_FEATURE_PROP_EXPERIMENTER;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_table_feature_prop_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_table_feature_prop_header */

/**
 * \defgroup of_table_feature_prop_header of_table_feature_prop_header
 */

/**
 * Create a new of_table_feature_prop_header object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_table_feature_prop_header
 */

of_table_feature_prop_header_t *
of_table_feature_prop_header_new_(of_version_t version)
{
    of_table_feature_prop_header_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_TABLE_FEATURE_PROP_HEADER] + of_object_extra_len[version][OF_TABLE_FEATURE_PROP_HEADER];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_table_feature_prop_header_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_table_feature_prop_header_init(obj, version, bytes, 0);

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_table_feature_prop_header_t *
of_table_feature_prop_header_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_table_feature_prop_header_t *obj;

    obj = of_table_feature_prop_header_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_table_feature_prop_header.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_table_feature_prop_header_init(of_table_feature_prop_header_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_TABLE_FEATURE_PROP_HEADER] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_TABLE_FEATURE_PROP_HEADER] + of_object_extra_len[version][OF_TABLE_FEATURE_PROP_HEADER];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_TABLE_FEATURE_PROP_HEADER;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_table_feature_prop_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_table_feature_prop_instructions */

/**
 * \defgroup of_table_feature_prop_instructions of_table_feature_prop_instructions
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_table_feature_prop_instructions_push_wire_values(of_table_feature_prop_instructions_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_TABLE_FEATURE_PROP_INSTRUCTIONS);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_table_feature_prop_instructions object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_table_feature_prop_instructions
 */

of_table_feature_prop_instructions_t *
of_table_feature_prop_instructions_new_(of_version_t version)
{
    of_table_feature_prop_instructions_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_TABLE_FEATURE_PROP_INSTRUCTIONS] + of_object_extra_len[version][OF_TABLE_FEATURE_PROP_INSTRUCTIONS];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_table_feature_prop_instructions_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_table_feature_prop_instructions_init(obj, version, bytes, 0);

    if (of_table_feature_prop_instructions_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_table_feature_prop_instructions_t *
of_table_feature_prop_instructions_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_table_feature_prop_instructions_t *obj;

    obj = of_table_feature_prop_instructions_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_table_feature_prop_instructions.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_table_feature_prop_instructions_init(of_table_feature_prop_instructions_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_TABLE_FEATURE_PROP_INSTRUCTIONS] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_TABLE_FEATURE_PROP_INSTRUCTIONS] + of_object_extra_len[version][OF_TABLE_FEATURE_PROP_INSTRUCTIONS];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_TABLE_FEATURE_PROP_INSTRUCTIONS;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_table_feature_prop_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_table_feature_prop_instructions_miss */

/**
 * \defgroup of_table_feature_prop_instructions_miss of_table_feature_prop_instructions_miss
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_table_feature_prop_instructions_miss_push_wire_values(of_table_feature_prop_instructions_miss_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_TABLE_FEATURE_PROP_INSTRUCTIONS_MISS);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_table_feature_prop_instructions_miss object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_table_feature_prop_instructions_miss
 */

of_table_feature_prop_instructions_miss_t *
of_table_feature_prop_instructions_miss_new_(of_version_t version)
{
    of_table_feature_prop_instructions_miss_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_TABLE_FEATURE_PROP_INSTRUCTIONS_MISS] + of_object_extra_len[version][OF_TABLE_FEATURE_PROP_INSTRUCTIONS_MISS];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_table_feature_prop_instructions_miss_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_table_feature_prop_instructions_miss_init(obj, version, bytes, 0);

    if (of_table_feature_prop_instructions_miss_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_table_feature_prop_instructions_miss_t *
of_table_feature_prop_instructions_miss_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_table_feature_prop_instructions_miss_t *obj;

    obj = of_table_feature_prop_instructions_miss_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_table_feature_prop_instructions_miss.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_table_feature_prop_instructions_miss_init(of_table_feature_prop_instructions_miss_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_TABLE_FEATURE_PROP_INSTRUCTIONS_MISS] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_TABLE_FEATURE_PROP_INSTRUCTIONS_MISS] + of_object_extra_len[version][OF_TABLE_FEATURE_PROP_INSTRUCTIONS_MISS];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_TABLE_FEATURE_PROP_INSTRUCTIONS_MISS;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_table_feature_prop_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_table_feature_prop_match */

/**
 * \defgroup of_table_feature_prop_match of_table_feature_prop_match
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_table_feature_prop_match_push_wire_values(of_table_feature_prop_match_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_TABLE_FEATURE_PROP_MATCH);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_table_feature_prop_match object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_table_feature_prop_match
 */

of_table_feature_prop_match_t *
of_table_feature_prop_match_new_(of_version_t version)
{
    of_table_feature_prop_match_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_TABLE_FEATURE_PROP_MATCH] + of_object_extra_len[version][OF_TABLE_FEATURE_PROP_MATCH];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_table_feature_prop_match_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_table_feature_prop_match_init(obj, version, bytes, 0);

    if (of_table_feature_prop_match_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_table_feature_prop_match_t *
of_table_feature_prop_match_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_table_feature_prop_match_t *obj;

    obj = of_table_feature_prop_match_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_table_feature_prop_match.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_table_feature_prop_match_init(of_table_feature_prop_match_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_TABLE_FEATURE_PROP_MATCH] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_TABLE_FEATURE_PROP_MATCH] + of_object_extra_len[version][OF_TABLE_FEATURE_PROP_MATCH];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_TABLE_FEATURE_PROP_MATCH;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_table_feature_prop_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_table_feature_prop_next_tables */

/**
 * \defgroup of_table_feature_prop_next_tables of_table_feature_prop_next_tables
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_table_feature_prop_next_tables_push_wire_values(of_table_feature_prop_next_tables_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_TABLE_FEATURE_PROP_NEXT_TABLES);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_table_feature_prop_next_tables object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_table_feature_prop_next_tables
 */

of_table_feature_prop_next_tables_t *
of_table_feature_prop_next_tables_new_(of_version_t version)
{
    of_table_feature_prop_next_tables_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_TABLE_FEATURE_PROP_NEXT_TABLES] + of_object_extra_len[version][OF_TABLE_FEATURE_PROP_NEXT_TABLES];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_table_feature_prop_next_tables_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_table_feature_prop_next_tables_init(obj, version, bytes, 0);

    if (of_table_feature_prop_next_tables_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_table_feature_prop_next_tables_t *
of_table_feature_prop_next_tables_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_table_feature_prop_next_tables_t *obj;

    obj = of_table_feature_prop_next_tables_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_table_feature_prop_next_tables.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_table_feature_prop_next_tables_init(of_table_feature_prop_next_tables_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_TABLE_FEATURE_PROP_NEXT_TABLES] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_TABLE_FEATURE_PROP_NEXT_TABLES] + of_object_extra_len[version][OF_TABLE_FEATURE_PROP_NEXT_TABLES];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_TABLE_FEATURE_PROP_NEXT_TABLES;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_table_feature_prop_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_table_feature_prop_next_tables_miss */

/**
 * \defgroup of_table_feature_prop_next_tables_miss of_table_feature_prop_next_tables_miss
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_table_feature_prop_next_tables_miss_push_wire_values(of_table_feature_prop_next_tables_miss_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_TABLE_FEATURE_PROP_NEXT_TABLES_MISS);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_table_feature_prop_next_tables_miss object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_table_feature_prop_next_tables_miss
 */

of_table_feature_prop_next_tables_miss_t *
of_table_feature_prop_next_tables_miss_new_(of_version_t version)
{
    of_table_feature_prop_next_tables_miss_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_TABLE_FEATURE_PROP_NEXT_TABLES_MISS] + of_object_extra_len[version][OF_TABLE_FEATURE_PROP_NEXT_TABLES_MISS];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_table_feature_prop_next_tables_miss_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_table_feature_prop_next_tables_miss_init(obj, version, bytes, 0);

    if (of_table_feature_prop_next_tables_miss_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_table_feature_prop_next_tables_miss_t *
of_table_feature_prop_next_tables_miss_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_table_feature_prop_next_tables_miss_t *obj;

    obj = of_table_feature_prop_next_tables_miss_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_table_feature_prop_next_tables_miss.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_table_feature_prop_next_tables_miss_init(of_table_feature_prop_next_tables_miss_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_TABLE_FEATURE_PROP_NEXT_TABLES_MISS] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_TABLE_FEATURE_PROP_NEXT_TABLES_MISS] + of_object_extra_len[version][OF_TABLE_FEATURE_PROP_NEXT_TABLES_MISS];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_TABLE_FEATURE_PROP_NEXT_TABLES_MISS;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_table_feature_prop_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_table_feature_prop_wildcards */

/**
 * \defgroup of_table_feature_prop_wildcards of_table_feature_prop_wildcards
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_table_feature_prop_wildcards_push_wire_values(of_table_feature_prop_wildcards_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_TABLE_FEATURE_PROP_WILDCARDS);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_table_feature_prop_wildcards object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_table_feature_prop_wildcards
 */

of_table_feature_prop_wildcards_t *
of_table_feature_prop_wildcards_new_(of_version_t version)
{
    of_table_feature_prop_wildcards_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_TABLE_FEATURE_PROP_WILDCARDS] + of_object_extra_len[version][OF_TABLE_FEATURE_PROP_WILDCARDS];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_table_feature_prop_wildcards_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_table_feature_prop_wildcards_init(obj, version, bytes, 0);

    if (of_table_feature_prop_wildcards_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_table_feature_prop_wildcards_t *
of_table_feature_prop_wildcards_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_table_feature_prop_wildcards_t *obj;

    obj = of_table_feature_prop_wildcards_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_table_feature_prop_wildcards.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_table_feature_prop_wildcards_init(of_table_feature_prop_wildcards_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_TABLE_FEATURE_PROP_WILDCARDS] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_TABLE_FEATURE_PROP_WILDCARDS] + of_object_extra_len[version][OF_TABLE_FEATURE_PROP_WILDCARDS];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_TABLE_FEATURE_PROP_WILDCARDS;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_table_feature_prop_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_table_feature_prop_write_actions */

/**
 * \defgroup of_table_feature_prop_write_actions of_table_feature_prop_write_actions
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_table_feature_prop_write_actions_push_wire_values(of_table_feature_prop_write_actions_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_TABLE_FEATURE_PROP_WRITE_ACTIONS);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_table_feature_prop_write_actions object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_table_feature_prop_write_actions
 */

of_table_feature_prop_write_actions_t *
of_table_feature_prop_write_actions_new_(of_version_t version)
{
    of_table_feature_prop_write_actions_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_TABLE_FEATURE_PROP_WRITE_ACTIONS] + of_object_extra_len[version][OF_TABLE_FEATURE_PROP_WRITE_ACTIONS];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_table_feature_prop_write_actions_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_table_feature_prop_write_actions_init(obj, version, bytes, 0);

    if (of_table_feature_prop_write_actions_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_table_feature_prop_write_actions_t *
of_table_feature_prop_write_actions_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_table_feature_prop_write_actions_t *obj;

    obj = of_table_feature_prop_write_actions_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_table_feature_prop_write_actions.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_table_feature_prop_write_actions_init(of_table_feature_prop_write_actions_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_TABLE_FEATURE_PROP_WRITE_ACTIONS] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_TABLE_FEATURE_PROP_WRITE_ACTIONS] + of_object_extra_len[version][OF_TABLE_FEATURE_PROP_WRITE_ACTIONS];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_TABLE_FEATURE_PROP_WRITE_ACTIONS;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_table_feature_prop_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_table_feature_prop_write_actions_miss */

/**
 * \defgroup of_table_feature_prop_write_actions_miss of_table_feature_prop_write_actions_miss
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_table_feature_prop_write_actions_miss_push_wire_values(of_table_feature_prop_write_actions_miss_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_TABLE_FEATURE_PROP_WRITE_ACTIONS_MISS);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_table_feature_prop_write_actions_miss object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_table_feature_prop_write_actions_miss
 */

of_table_feature_prop_write_actions_miss_t *
of_table_feature_prop_write_actions_miss_new_(of_version_t version)
{
    of_table_feature_prop_write_actions_miss_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_TABLE_FEATURE_PROP_WRITE_ACTIONS_MISS] + of_object_extra_len[version][OF_TABLE_FEATURE_PROP_WRITE_ACTIONS_MISS];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_table_feature_prop_write_actions_miss_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_table_feature_prop_write_actions_miss_init(obj, version, bytes, 0);

    if (of_table_feature_prop_write_actions_miss_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_table_feature_prop_write_actions_miss_t *
of_table_feature_prop_write_actions_miss_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_table_feature_prop_write_actions_miss_t *obj;

    obj = of_table_feature_prop_write_actions_miss_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_table_feature_prop_write_actions_miss.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_table_feature_prop_write_actions_miss_init(of_table_feature_prop_write_actions_miss_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_TABLE_FEATURE_PROP_WRITE_ACTIONS_MISS] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_TABLE_FEATURE_PROP_WRITE_ACTIONS_MISS] + of_object_extra_len[version][OF_TABLE_FEATURE_PROP_WRITE_ACTIONS_MISS];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_TABLE_FEATURE_PROP_WRITE_ACTIONS_MISS;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_table_feature_prop_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_table_feature_prop_write_setfield */

/**
 * \defgroup of_table_feature_prop_write_setfield of_table_feature_prop_write_setfield
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_table_feature_prop_write_setfield_push_wire_values(of_table_feature_prop_write_setfield_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_TABLE_FEATURE_PROP_WRITE_SETFIELD);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_table_feature_prop_write_setfield object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_table_feature_prop_write_setfield
 */

of_table_feature_prop_write_setfield_t *
of_table_feature_prop_write_setfield_new_(of_version_t version)
{
    of_table_feature_prop_write_setfield_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_TABLE_FEATURE_PROP_WRITE_SETFIELD] + of_object_extra_len[version][OF_TABLE_FEATURE_PROP_WRITE_SETFIELD];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_table_feature_prop_write_setfield_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_table_feature_prop_write_setfield_init(obj, version, bytes, 0);

    if (of_table_feature_prop_write_setfield_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_table_feature_prop_write_setfield_t *
of_table_feature_prop_write_setfield_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_table_feature_prop_write_setfield_t *obj;

    obj = of_table_feature_prop_write_setfield_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_table_feature_prop_write_setfield.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_table_feature_prop_write_setfield_init(of_table_feature_prop_write_setfield_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_TABLE_FEATURE_PROP_WRITE_SETFIELD] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_TABLE_FEATURE_PROP_WRITE_SETFIELD] + of_object_extra_len[version][OF_TABLE_FEATURE_PROP_WRITE_SETFIELD];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_TABLE_FEATURE_PROP_WRITE_SETFIELD;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_table_feature_prop_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_table_feature_prop_write_setfield_miss */

/**
 * \defgroup of_table_feature_prop_write_setfield_miss of_table_feature_prop_write_setfield_miss
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_table_feature_prop_write_setfield_miss_push_wire_values(of_table_feature_prop_write_setfield_miss_t *obj)
{

    /* TLV obj; set length and type */
    of_tlv16_wire_length_set((of_object_t *)obj, obj->length);
    of_tlv16_wire_object_id_set((of_object_t *)obj,
           OF_TABLE_FEATURE_PROP_WRITE_SETFIELD_MISS);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_table_feature_prop_write_setfield_miss object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_table_feature_prop_write_setfield_miss
 */

of_table_feature_prop_write_setfield_miss_t *
of_table_feature_prop_write_setfield_miss_new_(of_version_t version)
{
    of_table_feature_prop_write_setfield_miss_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_TABLE_FEATURE_PROP_WRITE_SETFIELD_MISS] + of_object_extra_len[version][OF_TABLE_FEATURE_PROP_WRITE_SETFIELD_MISS];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_table_feature_prop_write_setfield_miss_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_table_feature_prop_write_setfield_miss_init(obj, version, bytes, 0);

    if (of_table_feature_prop_write_setfield_miss_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_table_feature_prop_write_setfield_miss_t *
of_table_feature_prop_write_setfield_miss_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_table_feature_prop_write_setfield_miss_t *obj;

    obj = of_table_feature_prop_write_setfield_miss_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_table_feature_prop_write_setfield_miss.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_table_feature_prop_write_setfield_miss_init(of_table_feature_prop_write_setfield_miss_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_TABLE_FEATURE_PROP_WRITE_SETFIELD_MISS] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_TABLE_FEATURE_PROP_WRITE_SETFIELD_MISS] + of_object_extra_len[version][OF_TABLE_FEATURE_PROP_WRITE_SETFIELD_MISS];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_TABLE_FEATURE_PROP_WRITE_SETFIELD_MISS;

    /* Set up the object's function pointers */

    obj->wire_length_set = of_tlv16_wire_length_set;
    obj->wire_type_set = of_tlv16_wire_object_id_set;
    obj->wire_length_get = of_tlv16_wire_length_get;

    obj->wire_type_get = of_table_feature_prop_wire_object_id_get;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_table_features */

/**
 * \defgroup of_table_features of_table_features
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_table_features_push_wire_values(of_table_features_t *obj)
{

    obj->wire_length_set((of_object_t *)obj, obj->length);

    return OF_ERROR_NONE;
}

/**
 * Create a new of_table_features object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_table_features
 */

of_table_features_t *
of_table_features_new_(of_version_t version)
{
    of_table_features_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_TABLE_FEATURES] + of_object_extra_len[version][OF_TABLE_FEATURES];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_table_features_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_table_features_init(obj, version, bytes, 0);

    if (of_table_features_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_table_features_t *
of_table_features_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_table_features_t *obj;

    obj = of_table_features_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_table_features.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_table_features_init(of_table_features_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_TABLE_FEATURES] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_TABLE_FEATURES] + of_object_extra_len[version][OF_TABLE_FEATURES];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_TABLE_FEATURES;

    /* Set up the object's function pointers */

    obj->wire_length_get = of_u16_len_wire_length_get;
    obj->wire_length_set = of_u16_len_wire_length_set;

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_table_stats_entry */

/**
 * \defgroup of_table_stats_entry of_table_stats_entry
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_table_stats_entry_push_wire_values(of_table_stats_entry_t *obj)
{

    return OF_ERROR_NONE;
}

/**
 * Create a new of_table_stats_entry object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_table_stats_entry
 */

of_table_stats_entry_t *
of_table_stats_entry_new_(of_version_t version)
{
    of_table_stats_entry_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_TABLE_STATS_ENTRY] + of_object_extra_len[version][OF_TABLE_STATS_ENTRY];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_table_stats_entry_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_table_stats_entry_init(obj, version, bytes, 0);

    if (of_table_stats_entry_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_table_stats_entry_t *
of_table_stats_entry_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_table_stats_entry_t *obj;

    obj = of_table_stats_entry_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_table_stats_entry.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_table_stats_entry_init(of_table_stats_entry_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_TABLE_STATS_ENTRY] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_TABLE_STATS_ENTRY] + of_object_extra_len[version][OF_TABLE_STATS_ENTRY];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_TABLE_STATS_ENTRY;

    /* Set up the object's function pointers */

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_uint32 */

/**
 * \defgroup of_uint32 of_uint32
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_uint32_push_wire_values(of_uint32_t *obj)
{

    return OF_ERROR_NONE;
}

/**
 * Create a new of_uint32 object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_uint32
 */

of_uint32_t *
of_uint32_new_(of_version_t version)
{
    of_uint32_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_UINT32] + of_object_extra_len[version][OF_UINT32];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_uint32_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_uint32_init(obj, version, bytes, 0);

    if (of_uint32_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_uint32_t *
of_uint32_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_uint32_t *obj;

    obj = of_uint32_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_uint32.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_uint32_init(of_uint32_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_UINT32] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_UINT32] + of_object_extra_len[version][OF_UINT32];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_UINT32;

    /* Set up the object's function pointers */

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_uint8 */

/**
 * \defgroup of_uint8 of_uint8
 */

/**
 * Helper function to push values into the wire buffer
 */
static inline int
of_uint8_push_wire_values(of_uint8_t *obj)
{

    return OF_ERROR_NONE;
}

/**
 * Create a new of_uint8 object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_uint8
 */

of_uint8_t *
of_uint8_new_(of_version_t version)
{
    of_uint8_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_UINT8] + of_object_extra_len[version][OF_UINT8];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_uint8_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_uint8_init(obj, version, bytes, 0);

    if (of_uint8_push_wire_values(obj) < 0) {
        FREE(obj);
        return NULL;
    }

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_uint8_t *
of_uint8_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_uint8_t *obj;

    obj = of_uint8_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_uint8.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_uint8_init(of_uint8_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_UINT8] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_UINT8] + of_object_extra_len[version][OF_UINT8];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_UINT8;

    /* Set up the object's function pointers */

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_list_action */

/**
 * \defgroup of_list_action of_list_action
 */

/**
 * Create a new of_list_action object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_list_action
 */

of_list_action_t *
of_list_action_new_(of_version_t version)
{
    of_list_action_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_LIST_ACTION] + of_object_extra_len[version][OF_LIST_ACTION];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_list_action_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_list_action_init(obj, version, bytes, 0);

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_list_action_t *
of_list_action_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_list_action_t *obj;

    obj = of_list_action_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_list_action.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_list_action_init(of_list_action_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_LIST_ACTION] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_LIST_ACTION] + of_object_extra_len[version][OF_LIST_ACTION];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_LIST_ACTION;

    /* Set up the object's function pointers */

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_list_action_id */

/**
 * \defgroup of_list_action_id of_list_action_id
 */

/**
 * Create a new of_list_action_id object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_list_action_id
 */

of_list_action_id_t *
of_list_action_id_new_(of_version_t version)
{
    of_list_action_id_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_LIST_ACTION_ID] + of_object_extra_len[version][OF_LIST_ACTION_ID];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_list_action_id_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_list_action_id_init(obj, version, bytes, 0);

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_list_action_id_t *
of_list_action_id_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_list_action_id_t *obj;

    obj = of_list_action_id_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_list_action_id.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_list_action_id_init(of_list_action_id_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_LIST_ACTION_ID] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_LIST_ACTION_ID] + of_object_extra_len[version][OF_LIST_ACTION_ID];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_LIST_ACTION_ID;

    /* Set up the object's function pointers */

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_list_bsn_interface */

/**
 * \defgroup of_list_bsn_interface of_list_bsn_interface
 */

/**
 * Create a new of_list_bsn_interface object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_list_bsn_interface
 */

of_list_bsn_interface_t *
of_list_bsn_interface_new_(of_version_t version)
{
    of_list_bsn_interface_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_LIST_BSN_INTERFACE] + of_object_extra_len[version][OF_LIST_BSN_INTERFACE];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_list_bsn_interface_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_list_bsn_interface_init(obj, version, bytes, 0);

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_list_bsn_interface_t *
of_list_bsn_interface_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_list_bsn_interface_t *obj;

    obj = of_list_bsn_interface_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_list_bsn_interface.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_list_bsn_interface_init(of_list_bsn_interface_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_LIST_BSN_INTERFACE] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_LIST_BSN_INTERFACE] + of_object_extra_len[version][OF_LIST_BSN_INTERFACE];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_LIST_BSN_INTERFACE;

    /* Set up the object's function pointers */

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_list_bucket */

/**
 * \defgroup of_list_bucket of_list_bucket
 */

/**
 * Create a new of_list_bucket object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_list_bucket
 */

of_list_bucket_t *
of_list_bucket_new_(of_version_t version)
{
    of_list_bucket_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_LIST_BUCKET] + of_object_extra_len[version][OF_LIST_BUCKET];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_list_bucket_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_list_bucket_init(obj, version, bytes, 0);

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_list_bucket_t *
of_list_bucket_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_list_bucket_t *obj;

    obj = of_list_bucket_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_list_bucket.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_list_bucket_init(of_list_bucket_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_LIST_BUCKET] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_LIST_BUCKET] + of_object_extra_len[version][OF_LIST_BUCKET];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_LIST_BUCKET;

    /* Set up the object's function pointers */

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_list_bucket_counter */

/**
 * \defgroup of_list_bucket_counter of_list_bucket_counter
 */

/**
 * Create a new of_list_bucket_counter object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_list_bucket_counter
 */

of_list_bucket_counter_t *
of_list_bucket_counter_new_(of_version_t version)
{
    of_list_bucket_counter_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_LIST_BUCKET_COUNTER] + of_object_extra_len[version][OF_LIST_BUCKET_COUNTER];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_list_bucket_counter_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_list_bucket_counter_init(obj, version, bytes, 0);

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_list_bucket_counter_t *
of_list_bucket_counter_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_list_bucket_counter_t *obj;

    obj = of_list_bucket_counter_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_list_bucket_counter.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_list_bucket_counter_init(of_list_bucket_counter_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_LIST_BUCKET_COUNTER] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_LIST_BUCKET_COUNTER] + of_object_extra_len[version][OF_LIST_BUCKET_COUNTER];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_LIST_BUCKET_COUNTER;

    /* Set up the object's function pointers */

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_list_flow_stats_entry */

/**
 * \defgroup of_list_flow_stats_entry of_list_flow_stats_entry
 */

/**
 * Create a new of_list_flow_stats_entry object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_list_flow_stats_entry
 */

of_list_flow_stats_entry_t *
of_list_flow_stats_entry_new_(of_version_t version)
{
    of_list_flow_stats_entry_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_LIST_FLOW_STATS_ENTRY] + of_object_extra_len[version][OF_LIST_FLOW_STATS_ENTRY];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_list_flow_stats_entry_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_list_flow_stats_entry_init(obj, version, bytes, 0);

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_list_flow_stats_entry_t *
of_list_flow_stats_entry_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_list_flow_stats_entry_t *obj;

    obj = of_list_flow_stats_entry_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_list_flow_stats_entry.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_list_flow_stats_entry_init(of_list_flow_stats_entry_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_LIST_FLOW_STATS_ENTRY] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_LIST_FLOW_STATS_ENTRY] + of_object_extra_len[version][OF_LIST_FLOW_STATS_ENTRY];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_LIST_FLOW_STATS_ENTRY;

    /* Set up the object's function pointers */

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_list_group_desc_stats_entry */

/**
 * \defgroup of_list_group_desc_stats_entry of_list_group_desc_stats_entry
 */

/**
 * Create a new of_list_group_desc_stats_entry object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_list_group_desc_stats_entry
 */

of_list_group_desc_stats_entry_t *
of_list_group_desc_stats_entry_new_(of_version_t version)
{
    of_list_group_desc_stats_entry_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_LIST_GROUP_DESC_STATS_ENTRY] + of_object_extra_len[version][OF_LIST_GROUP_DESC_STATS_ENTRY];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_list_group_desc_stats_entry_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_list_group_desc_stats_entry_init(obj, version, bytes, 0);

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_list_group_desc_stats_entry_t *
of_list_group_desc_stats_entry_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_list_group_desc_stats_entry_t *obj;

    obj = of_list_group_desc_stats_entry_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_list_group_desc_stats_entry.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_list_group_desc_stats_entry_init(of_list_group_desc_stats_entry_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_LIST_GROUP_DESC_STATS_ENTRY] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_LIST_GROUP_DESC_STATS_ENTRY] + of_object_extra_len[version][OF_LIST_GROUP_DESC_STATS_ENTRY];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_LIST_GROUP_DESC_STATS_ENTRY;

    /* Set up the object's function pointers */

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_list_group_stats_entry */

/**
 * \defgroup of_list_group_stats_entry of_list_group_stats_entry
 */

/**
 * Create a new of_list_group_stats_entry object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_list_group_stats_entry
 */

of_list_group_stats_entry_t *
of_list_group_stats_entry_new_(of_version_t version)
{
    of_list_group_stats_entry_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_LIST_GROUP_STATS_ENTRY] + of_object_extra_len[version][OF_LIST_GROUP_STATS_ENTRY];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_list_group_stats_entry_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_list_group_stats_entry_init(obj, version, bytes, 0);

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_list_group_stats_entry_t *
of_list_group_stats_entry_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_list_group_stats_entry_t *obj;

    obj = of_list_group_stats_entry_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_list_group_stats_entry.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_list_group_stats_entry_init(of_list_group_stats_entry_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_LIST_GROUP_STATS_ENTRY] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_LIST_GROUP_STATS_ENTRY] + of_object_extra_len[version][OF_LIST_GROUP_STATS_ENTRY];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_LIST_GROUP_STATS_ENTRY;

    /* Set up the object's function pointers */

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_list_hello_elem */

/**
 * \defgroup of_list_hello_elem of_list_hello_elem
 */

/**
 * Create a new of_list_hello_elem object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_list_hello_elem
 */

of_list_hello_elem_t *
of_list_hello_elem_new_(of_version_t version)
{
    of_list_hello_elem_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_LIST_HELLO_ELEM] + of_object_extra_len[version][OF_LIST_HELLO_ELEM];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_list_hello_elem_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_list_hello_elem_init(obj, version, bytes, 0);

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_list_hello_elem_t *
of_list_hello_elem_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_list_hello_elem_t *obj;

    obj = of_list_hello_elem_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_list_hello_elem.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_list_hello_elem_init(of_list_hello_elem_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_LIST_HELLO_ELEM] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_LIST_HELLO_ELEM] + of_object_extra_len[version][OF_LIST_HELLO_ELEM];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_LIST_HELLO_ELEM;

    /* Set up the object's function pointers */

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_list_instruction */

/**
 * \defgroup of_list_instruction of_list_instruction
 */

/**
 * Create a new of_list_instruction object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_list_instruction
 */

of_list_instruction_t *
of_list_instruction_new_(of_version_t version)
{
    of_list_instruction_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_LIST_INSTRUCTION] + of_object_extra_len[version][OF_LIST_INSTRUCTION];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_list_instruction_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_list_instruction_init(obj, version, bytes, 0);

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_list_instruction_t *
of_list_instruction_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_list_instruction_t *obj;

    obj = of_list_instruction_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_list_instruction.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_list_instruction_init(of_list_instruction_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_LIST_INSTRUCTION] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_LIST_INSTRUCTION] + of_object_extra_len[version][OF_LIST_INSTRUCTION];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_LIST_INSTRUCTION;

    /* Set up the object's function pointers */

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_list_meter_band */

/**
 * \defgroup of_list_meter_band of_list_meter_band
 */

/**
 * Create a new of_list_meter_band object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_list_meter_band
 */

of_list_meter_band_t *
of_list_meter_band_new_(of_version_t version)
{
    of_list_meter_band_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_LIST_METER_BAND] + of_object_extra_len[version][OF_LIST_METER_BAND];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_list_meter_band_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_list_meter_band_init(obj, version, bytes, 0);

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_list_meter_band_t *
of_list_meter_band_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_list_meter_band_t *obj;

    obj = of_list_meter_band_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_list_meter_band.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_list_meter_band_init(of_list_meter_band_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_LIST_METER_BAND] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_LIST_METER_BAND] + of_object_extra_len[version][OF_LIST_METER_BAND];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_LIST_METER_BAND;

    /* Set up the object's function pointers */

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_list_meter_band_stats */

/**
 * \defgroup of_list_meter_band_stats of_list_meter_band_stats
 */

/**
 * Create a new of_list_meter_band_stats object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_list_meter_band_stats
 */

of_list_meter_band_stats_t *
of_list_meter_band_stats_new_(of_version_t version)
{
    of_list_meter_band_stats_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_LIST_METER_BAND_STATS] + of_object_extra_len[version][OF_LIST_METER_BAND_STATS];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_list_meter_band_stats_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_list_meter_band_stats_init(obj, version, bytes, 0);

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_list_meter_band_stats_t *
of_list_meter_band_stats_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_list_meter_band_stats_t *obj;

    obj = of_list_meter_band_stats_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_list_meter_band_stats.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_list_meter_band_stats_init(of_list_meter_band_stats_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_LIST_METER_BAND_STATS] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_LIST_METER_BAND_STATS] + of_object_extra_len[version][OF_LIST_METER_BAND_STATS];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_LIST_METER_BAND_STATS;

    /* Set up the object's function pointers */

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_list_meter_stats */

/**
 * \defgroup of_list_meter_stats of_list_meter_stats
 */

/**
 * Create a new of_list_meter_stats object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_list_meter_stats
 */

of_list_meter_stats_t *
of_list_meter_stats_new_(of_version_t version)
{
    of_list_meter_stats_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_LIST_METER_STATS] + of_object_extra_len[version][OF_LIST_METER_STATS];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_list_meter_stats_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_list_meter_stats_init(obj, version, bytes, 0);

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_list_meter_stats_t *
of_list_meter_stats_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_list_meter_stats_t *obj;

    obj = of_list_meter_stats_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_list_meter_stats.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_list_meter_stats_init(of_list_meter_stats_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_LIST_METER_STATS] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_LIST_METER_STATS] + of_object_extra_len[version][OF_LIST_METER_STATS];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_LIST_METER_STATS;

    /* Set up the object's function pointers */

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_list_oxm */

/**
 * \defgroup of_list_oxm of_list_oxm
 */

/**
 * Create a new of_list_oxm object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_list_oxm
 */

of_list_oxm_t *
of_list_oxm_new_(of_version_t version)
{
    of_list_oxm_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_LIST_OXM] + of_object_extra_len[version][OF_LIST_OXM];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_list_oxm_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_list_oxm_init(obj, version, bytes, 0);

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_list_oxm_t *
of_list_oxm_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_list_oxm_t *obj;

    obj = of_list_oxm_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_list_oxm.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_list_oxm_init(of_list_oxm_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_LIST_OXM] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_LIST_OXM] + of_object_extra_len[version][OF_LIST_OXM];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_LIST_OXM;

    /* Set up the object's function pointers */

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_list_packet_queue */

/**
 * \defgroup of_list_packet_queue of_list_packet_queue
 */

/**
 * Create a new of_list_packet_queue object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_list_packet_queue
 */

of_list_packet_queue_t *
of_list_packet_queue_new_(of_version_t version)
{
    of_list_packet_queue_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_LIST_PACKET_QUEUE] + of_object_extra_len[version][OF_LIST_PACKET_QUEUE];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_list_packet_queue_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_list_packet_queue_init(obj, version, bytes, 0);

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_list_packet_queue_t *
of_list_packet_queue_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_list_packet_queue_t *obj;

    obj = of_list_packet_queue_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_list_packet_queue.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_list_packet_queue_init(of_list_packet_queue_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_LIST_PACKET_QUEUE] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_LIST_PACKET_QUEUE] + of_object_extra_len[version][OF_LIST_PACKET_QUEUE];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_LIST_PACKET_QUEUE;

    /* Set up the object's function pointers */

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_list_port_desc */

/**
 * \defgroup of_list_port_desc of_list_port_desc
 */

/**
 * Create a new of_list_port_desc object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_list_port_desc
 */

of_list_port_desc_t *
of_list_port_desc_new_(of_version_t version)
{
    of_list_port_desc_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_LIST_PORT_DESC] + of_object_extra_len[version][OF_LIST_PORT_DESC];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_list_port_desc_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_list_port_desc_init(obj, version, bytes, 0);

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_list_port_desc_t *
of_list_port_desc_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_list_port_desc_t *obj;

    obj = of_list_port_desc_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_list_port_desc.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_list_port_desc_init(of_list_port_desc_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_LIST_PORT_DESC] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_LIST_PORT_DESC] + of_object_extra_len[version][OF_LIST_PORT_DESC];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_LIST_PORT_DESC;

    /* Set up the object's function pointers */

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_list_port_stats_entry */

/**
 * \defgroup of_list_port_stats_entry of_list_port_stats_entry
 */

/**
 * Create a new of_list_port_stats_entry object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_list_port_stats_entry
 */

of_list_port_stats_entry_t *
of_list_port_stats_entry_new_(of_version_t version)
{
    of_list_port_stats_entry_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_LIST_PORT_STATS_ENTRY] + of_object_extra_len[version][OF_LIST_PORT_STATS_ENTRY];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_list_port_stats_entry_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_list_port_stats_entry_init(obj, version, bytes, 0);

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_list_port_stats_entry_t *
of_list_port_stats_entry_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_list_port_stats_entry_t *obj;

    obj = of_list_port_stats_entry_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_list_port_stats_entry.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_list_port_stats_entry_init(of_list_port_stats_entry_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_LIST_PORT_STATS_ENTRY] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_LIST_PORT_STATS_ENTRY] + of_object_extra_len[version][OF_LIST_PORT_STATS_ENTRY];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_LIST_PORT_STATS_ENTRY;

    /* Set up the object's function pointers */

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_list_queue_prop */

/**
 * \defgroup of_list_queue_prop of_list_queue_prop
 */

/**
 * Create a new of_list_queue_prop object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_list_queue_prop
 */

of_list_queue_prop_t *
of_list_queue_prop_new_(of_version_t version)
{
    of_list_queue_prop_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_LIST_QUEUE_PROP] + of_object_extra_len[version][OF_LIST_QUEUE_PROP];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_list_queue_prop_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_list_queue_prop_init(obj, version, bytes, 0);

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_list_queue_prop_t *
of_list_queue_prop_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_list_queue_prop_t *obj;

    obj = of_list_queue_prop_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_list_queue_prop.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_list_queue_prop_init(of_list_queue_prop_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_LIST_QUEUE_PROP] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_LIST_QUEUE_PROP] + of_object_extra_len[version][OF_LIST_QUEUE_PROP];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_LIST_QUEUE_PROP;

    /* Set up the object's function pointers */

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_list_queue_stats_entry */

/**
 * \defgroup of_list_queue_stats_entry of_list_queue_stats_entry
 */

/**
 * Create a new of_list_queue_stats_entry object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_list_queue_stats_entry
 */

of_list_queue_stats_entry_t *
of_list_queue_stats_entry_new_(of_version_t version)
{
    of_list_queue_stats_entry_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_LIST_QUEUE_STATS_ENTRY] + of_object_extra_len[version][OF_LIST_QUEUE_STATS_ENTRY];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_list_queue_stats_entry_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_list_queue_stats_entry_init(obj, version, bytes, 0);

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_list_queue_stats_entry_t *
of_list_queue_stats_entry_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_list_queue_stats_entry_t *obj;

    obj = of_list_queue_stats_entry_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_list_queue_stats_entry.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_list_queue_stats_entry_init(of_list_queue_stats_entry_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_LIST_QUEUE_STATS_ENTRY] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_LIST_QUEUE_STATS_ENTRY] + of_object_extra_len[version][OF_LIST_QUEUE_STATS_ENTRY];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_LIST_QUEUE_STATS_ENTRY;

    /* Set up the object's function pointers */

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_list_table_feature_prop */

/**
 * \defgroup of_list_table_feature_prop of_list_table_feature_prop
 */

/**
 * Create a new of_list_table_feature_prop object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_list_table_feature_prop
 */

of_list_table_feature_prop_t *
of_list_table_feature_prop_new_(of_version_t version)
{
    of_list_table_feature_prop_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_LIST_TABLE_FEATURE_PROP] + of_object_extra_len[version][OF_LIST_TABLE_FEATURE_PROP];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_list_table_feature_prop_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_list_table_feature_prop_init(obj, version, bytes, 0);

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_list_table_feature_prop_t *
of_list_table_feature_prop_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_list_table_feature_prop_t *obj;

    obj = of_list_table_feature_prop_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_list_table_feature_prop.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_list_table_feature_prop_init(of_list_table_feature_prop_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_LIST_TABLE_FEATURE_PROP] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_LIST_TABLE_FEATURE_PROP] + of_object_extra_len[version][OF_LIST_TABLE_FEATURE_PROP];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_LIST_TABLE_FEATURE_PROP;

    /* Set up the object's function pointers */

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_list_table_features */

/**
 * \defgroup of_list_table_features of_list_table_features
 */

/**
 * Create a new of_list_table_features object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_list_table_features
 */

of_list_table_features_t *
of_list_table_features_new_(of_version_t version)
{
    of_list_table_features_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_LIST_TABLE_FEATURES] + of_object_extra_len[version][OF_LIST_TABLE_FEATURES];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_list_table_features_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_list_table_features_init(obj, version, bytes, 0);

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_list_table_features_t *
of_list_table_features_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_list_table_features_t *obj;

    obj = of_list_table_features_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_list_table_features.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_list_table_features_init(of_list_table_features_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_LIST_TABLE_FEATURES] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_LIST_TABLE_FEATURES] + of_object_extra_len[version][OF_LIST_TABLE_FEATURES];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_LIST_TABLE_FEATURES;

    /* Set up the object's function pointers */

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_list_table_stats_entry */

/**
 * \defgroup of_list_table_stats_entry of_list_table_stats_entry
 */

/**
 * Create a new of_list_table_stats_entry object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_list_table_stats_entry
 */

of_list_table_stats_entry_t *
of_list_table_stats_entry_new_(of_version_t version)
{
    of_list_table_stats_entry_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_LIST_TABLE_STATS_ENTRY] + of_object_extra_len[version][OF_LIST_TABLE_STATS_ENTRY];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_list_table_stats_entry_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_list_table_stats_entry_init(obj, version, bytes, 0);

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_list_table_stats_entry_t *
of_list_table_stats_entry_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_list_table_stats_entry_t *obj;

    obj = of_list_table_stats_entry_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_list_table_stats_entry.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_list_table_stats_entry_init(of_list_table_stats_entry_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_LIST_TABLE_STATS_ENTRY] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_LIST_TABLE_STATS_ENTRY] + of_object_extra_len[version][OF_LIST_TABLE_STATS_ENTRY];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_LIST_TABLE_STATS_ENTRY;

    /* Set up the object's function pointers */

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_list_uint32 */

/**
 * \defgroup of_list_uint32 of_list_uint32
 */

/**
 * Create a new of_list_uint32 object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_list_uint32
 */

of_list_uint32_t *
of_list_uint32_new_(of_version_t version)
{
    of_list_uint32_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_LIST_UINT32] + of_object_extra_len[version][OF_LIST_UINT32];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_list_uint32_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_list_uint32_init(obj, version, bytes, 0);

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_list_uint32_t *
of_list_uint32_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_list_uint32_t *obj;

    obj = of_list_uint32_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_list_uint32.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_list_uint32_init(of_list_uint32_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_LIST_UINT32] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_LIST_UINT32] + of_object_extra_len[version][OF_LIST_UINT32];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_LIST_UINT32;

    /* Set up the object's function pointers */

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/* New operators for of_list_uint8 */

/**
 * \defgroup of_list_uint8 of_list_uint8
 */

/**
 * Create a new of_list_uint8 object
 *
 * @param version The wire version to use for the object
 * @return Pointer to the newly create object or NULL on error
 *
 * Initializes the new object with it's default fixed length associating
 * a new underlying wire buffer.
 *
 * Use new_from_message to bind an existing message to a message object,
 * or a _get function for non-message objects.
 *
 * \ingroup of_list_uint8
 */

of_list_uint8_t *
of_list_uint8_new_(of_version_t version)
{
    of_list_uint8_t *obj;
    int bytes;

    bytes = of_object_fixed_len[version][OF_LIST_UINT8] + of_object_extra_len[version][OF_LIST_UINT8];

    /* Allocate a maximum-length wire buffer assuming we'll be appending to it. */
    if ((obj = (of_list_uint8_t *)of_object_new(OF_WIRE_BUFFER_MAX_LENGTH)) == NULL) {
        return NULL;
    }

    of_list_uint8_init(obj, version, bytes, 0);

    return obj;
}

#if defined(OF_OBJECT_TRACKING)

/*
 * Tracking objects.  Call the new function and then record location
 */

of_list_uint8_t *
of_list_uint8_new_tracking(of_version_t version,
     const char *file, int line)
{
    of_list_uint8_t *obj;

    obj = of_list_uint8_new_(version);
    of_object_track((of_object_t *)obj, file, line);

    return obj;
}
#endif

/**
 * Initialize an object of type of_list_uint8.
 *
 * @param obj Pointer to the object to initialize
 * @param version The wire version to use for the object
 * @param bytes How many bytes in the object
 * @param clean_wire Boolean: If true, clear the wire object control struct
 *
 * If bytes < 0, then the default fixed length is used for the object
 *
 * This is a "coerce" function that sets up the pointers for the
 * accessors properly.
 *
 * If anything other than 0 is passed in for the buffer size, the underlying
 * wire buffer will have 'grow' called.
 */

void
of_list_uint8_init(of_list_uint8_t *obj,
    of_version_t version, int bytes, int clean_wire)
{

    ASSERT(of_object_fixed_len[version][OF_LIST_UINT8] >= 0);
    if (clean_wire) {
        MEMSET(obj, 0, sizeof(*obj));
    }
    if (bytes < 0) {
        bytes = of_object_fixed_len[version][OF_LIST_UINT8] + of_object_extra_len[version][OF_LIST_UINT8];
    }
    obj->version = version;
    obj->length = bytes;
    obj->object_id = OF_LIST_UINT8;

    /* Set up the object's function pointers */

    /* Grow the wire buffer */
    if (obj->wire_object.wbuf != NULL) {
        int tot_bytes;

        tot_bytes = bytes + obj->wire_object.obj_offset;
        of_wire_buffer_grow(obj->wire_object.wbuf, tot_bytes);
    }
}


/**
 * Map from object ID to type coerce function
 */
const of_object_init_f of_object_init_map[] = {
    (of_object_init_f)NULL,
    (of_object_init_f)of_aggregate_stats_reply_init,                  /* 1 */
    (of_object_init_f)of_aggregate_stats_request_init,                /* 2 */
    (of_object_init_f)of_async_get_reply_init,                        /* 3 */
    (of_object_init_f)of_async_get_request_init,                      /* 4 */
    (of_object_init_f)of_async_set_init,                              /* 5 */
    (of_object_init_f)of_barrier_reply_init,                          /* 6 */
    (of_object_init_f)of_barrier_request_init,                        /* 7 */
    (of_object_init_f)of_bsn_bw_clear_data_reply_init,                /* 8 */
    (of_object_init_f)of_bsn_bw_clear_data_request_init,              /* 9 */
    (of_object_init_f)of_bsn_bw_enable_get_reply_init,                /* 10 */
    (of_object_init_f)of_bsn_bw_enable_get_request_init,              /* 11 */
    (of_object_init_f)of_bsn_bw_enable_set_reply_init,                /* 12 */
    (of_object_init_f)of_bsn_bw_enable_set_request_init,              /* 13 */
    (of_object_init_f)of_bsn_get_interfaces_reply_init,               /* 14 */
    (of_object_init_f)of_bsn_get_interfaces_request_init,             /* 15 */
    (of_object_init_f)of_bsn_get_ip_mask_reply_init,                  /* 16 */
    (of_object_init_f)of_bsn_get_ip_mask_request_init,                /* 17 */
    (of_object_init_f)of_bsn_get_l2_table_reply_init,                 /* 18 */
    (of_object_init_f)of_bsn_get_l2_table_request_init,               /* 19 */
    (of_object_init_f)of_bsn_get_mirroring_reply_init,                /* 20 */
    (of_object_init_f)of_bsn_get_mirroring_request_init,              /* 21 */
    (of_object_init_f)of_bsn_set_ip_mask_init,                        /* 22 */
    (of_object_init_f)of_bsn_set_l2_table_reply_init,                 /* 23 */
    (of_object_init_f)of_bsn_set_l2_table_request_init,               /* 24 */
    (of_object_init_f)of_bsn_set_mirroring_init,                      /* 25 */
    (of_object_init_f)of_bsn_set_pktin_suppression_reply_init,        /* 26 */
    (of_object_init_f)of_bsn_set_pktin_suppression_request_init,      /* 27 */
    (of_object_init_f)of_bsn_shell_command_init,                      /* 28 */
    (of_object_init_f)of_bsn_shell_output_init,                       /* 29 */
    (of_object_init_f)of_bsn_shell_status_init,                       /* 30 */
    (of_object_init_f)of_bsn_virtual_port_create_reply_init,          /* 31 */
    (of_object_init_f)of_bsn_virtual_port_create_request_init,        /* 32 */
    (of_object_init_f)of_bsn_virtual_port_remove_reply_init,          /* 33 */
    (of_object_init_f)of_bsn_virtual_port_remove_request_init,        /* 34 */
    (of_object_init_f)of_desc_stats_reply_init,                       /* 35 */
    (of_object_init_f)of_desc_stats_request_init,                     /* 36 */
    (of_object_init_f)of_echo_reply_init,                             /* 37 */
    (of_object_init_f)of_echo_request_init,                           /* 38 */
    (of_object_init_f)of_error_msg_init,                              /* 39 */
    (of_object_init_f)of_experimenter_init,                           /* 40 */
    (of_object_init_f)of_experimenter_stats_reply_init,               /* 41 */
    (of_object_init_f)of_experimenter_stats_request_init,             /* 42 */
    (of_object_init_f)of_features_reply_init,                         /* 43 */
    (of_object_init_f)of_features_request_init,                       /* 44 */
    (of_object_init_f)of_flow_add_init,                               /* 45 */
    (of_object_init_f)of_flow_delete_init,                            /* 46 */
    (of_object_init_f)of_flow_delete_strict_init,                     /* 47 */
    (of_object_init_f)of_flow_modify_init,                            /* 48 */
    (of_object_init_f)of_flow_modify_strict_init,                     /* 49 */
    (of_object_init_f)of_flow_removed_init,                           /* 50 */
    (of_object_init_f)of_flow_stats_reply_init,                       /* 51 */
    (of_object_init_f)of_flow_stats_request_init,                     /* 52 */
    (of_object_init_f)of_get_config_reply_init,                       /* 53 */
    (of_object_init_f)of_get_config_request_init,                     /* 54 */
    (of_object_init_f)of_group_desc_stats_reply_init,                 /* 55 */
    (of_object_init_f)of_group_desc_stats_request_init,               /* 56 */
    (of_object_init_f)of_group_features_stats_reply_init,             /* 57 */
    (of_object_init_f)of_group_features_stats_request_init,           /* 58 */
    (of_object_init_f)of_group_mod_init,                              /* 59 */
    (of_object_init_f)of_group_stats_reply_init,                      /* 60 */
    (of_object_init_f)of_group_stats_request_init,                    /* 61 */
    (of_object_init_f)of_hello_init,                                  /* 62 */
    (of_object_init_f)of_meter_config_stats_reply_init,               /* 63 */
    (of_object_init_f)of_meter_config_stats_request_init,             /* 64 */
    (of_object_init_f)of_meter_features_stats_reply_init,             /* 65 */
    (of_object_init_f)of_meter_features_stats_request_init,           /* 66 */
    (of_object_init_f)of_meter_mod_init,                              /* 67 */
    (of_object_init_f)of_meter_stats_reply_init,                      /* 68 */
    (of_object_init_f)of_meter_stats_request_init,                    /* 69 */
    (of_object_init_f)of_nicira_controller_role_reply_init,           /* 70 */
    (of_object_init_f)of_nicira_controller_role_request_init,         /* 71 */
    (of_object_init_f)of_packet_in_init,                              /* 72 */
    (of_object_init_f)of_packet_out_init,                             /* 73 */
    (of_object_init_f)of_port_desc_stats_reply_init,                  /* 74 */
    (of_object_init_f)of_port_desc_stats_request_init,                /* 75 */
    (of_object_init_f)of_port_mod_init,                               /* 76 */
    (of_object_init_f)of_port_stats_reply_init,                       /* 77 */
    (of_object_init_f)of_port_stats_request_init,                     /* 78 */
    (of_object_init_f)of_port_status_init,                            /* 79 */
    (of_object_init_f)of_queue_get_config_reply_init,                 /* 80 */
    (of_object_init_f)of_queue_get_config_request_init,               /* 81 */
    (of_object_init_f)of_queue_stats_reply_init,                      /* 82 */
    (of_object_init_f)of_queue_stats_request_init,                    /* 83 */
    (of_object_init_f)of_role_reply_init,                             /* 84 */
    (of_object_init_f)of_role_request_init,                           /* 85 */
    (of_object_init_f)of_set_config_init,                             /* 86 */
    (of_object_init_f)of_table_features_stats_reply_init,             /* 87 */
    (of_object_init_f)of_table_features_stats_request_init,           /* 88 */
    (of_object_init_f)of_table_mod_init,                              /* 89 */
    (of_object_init_f)of_table_stats_reply_init,                      /* 90 */
    (of_object_init_f)of_table_stats_request_init,                    /* 91 */
    (of_object_init_f)of_action_header_init,                          /* 92 */
    (of_object_init_f)of_action_bsn_mirror_init,                      /* 93 */
    (of_object_init_f)of_action_bsn_set_tunnel_dst_init,              /* 94 */
    (of_object_init_f)of_action_copy_ttl_in_init,                     /* 95 */
    (of_object_init_f)of_action_copy_ttl_out_init,                    /* 96 */
    (of_object_init_f)of_action_dec_mpls_ttl_init,                    /* 97 */
    (of_object_init_f)of_action_dec_nw_ttl_init,                      /* 98 */
    (of_object_init_f)of_action_enqueue_init,                         /* 99 */
    (of_object_init_f)of_action_experimenter_init,                    /* 100 */
    (of_object_init_f)of_action_group_init,                           /* 101 */
    (of_object_init_f)of_action_header_init,                          /* 102 */
    (of_object_init_f)of_action_id_header_init,                       /* 103 */
    (of_object_init_f)of_action_id_bsn_mirror_init,                   /* 104 */
    (of_object_init_f)of_action_id_bsn_set_tunnel_dst_init,           /* 105 */
    (of_object_init_f)of_action_id_copy_ttl_in_init,                  /* 106 */
    (of_object_init_f)of_action_id_copy_ttl_out_init,                 /* 107 */
    (of_object_init_f)of_action_id_dec_mpls_ttl_init,                 /* 108 */
    (of_object_init_f)of_action_id_dec_nw_ttl_init,                   /* 109 */
    (of_object_init_f)of_action_id_experimenter_init,                 /* 110 */
    (of_object_init_f)of_action_id_group_init,                        /* 111 */
    (of_object_init_f)of_action_id_header_init,                       /* 112 */
    (of_object_init_f)of_action_id_nicira_dec_ttl_init,               /* 113 */
    (of_object_init_f)of_action_id_output_init,                       /* 114 */
    (of_object_init_f)of_action_id_pop_mpls_init,                     /* 115 */
    (of_object_init_f)of_action_id_pop_pbb_init,                      /* 116 */
    (of_object_init_f)of_action_id_pop_vlan_init,                     /* 117 */
    (of_object_init_f)of_action_id_push_mpls_init,                    /* 118 */
    (of_object_init_f)of_action_id_push_pbb_init,                     /* 119 */
    (of_object_init_f)of_action_id_push_vlan_init,                    /* 120 */
    (of_object_init_f)of_action_id_set_field_init,                    /* 121 */
    (of_object_init_f)of_action_id_set_mpls_ttl_init,                 /* 122 */
    (of_object_init_f)of_action_id_set_nw_ttl_init,                   /* 123 */
    (of_object_init_f)of_action_id_set_queue_init,                    /* 124 */
    (of_object_init_f)of_action_nicira_dec_ttl_init,                  /* 125 */
    (of_object_init_f)of_action_output_init,                          /* 126 */
    (of_object_init_f)of_action_pop_mpls_init,                        /* 127 */
    (of_object_init_f)of_action_pop_pbb_init,                         /* 128 */
    (of_object_init_f)of_action_pop_vlan_init,                        /* 129 */
    (of_object_init_f)of_action_push_mpls_init,                       /* 130 */
    (of_object_init_f)of_action_push_pbb_init,                        /* 131 */
    (of_object_init_f)of_action_push_vlan_init,                       /* 132 */
    (of_object_init_f)of_action_set_dl_dst_init,                      /* 133 */
    (of_object_init_f)of_action_set_dl_src_init,                      /* 134 */
    (of_object_init_f)of_action_set_field_init,                       /* 135 */
    (of_object_init_f)of_action_set_mpls_label_init,                  /* 136 */
    (of_object_init_f)of_action_set_mpls_tc_init,                     /* 137 */
    (of_object_init_f)of_action_set_mpls_ttl_init,                    /* 138 */
    (of_object_init_f)of_action_set_nw_dst_init,                      /* 139 */
    (of_object_init_f)of_action_set_nw_ecn_init,                      /* 140 */
    (of_object_init_f)of_action_set_nw_src_init,                      /* 141 */
    (of_object_init_f)of_action_set_nw_tos_init,                      /* 142 */
    (of_object_init_f)of_action_set_nw_ttl_init,                      /* 143 */
    (of_object_init_f)of_action_set_queue_init,                       /* 144 */
    (of_object_init_f)of_action_set_tp_dst_init,                      /* 145 */
    (of_object_init_f)of_action_set_tp_src_init,                      /* 146 */
    (of_object_init_f)of_action_set_vlan_pcp_init,                    /* 147 */
    (of_object_init_f)of_action_set_vlan_vid_init,                    /* 148 */
    (of_object_init_f)of_action_strip_vlan_init,                      /* 149 */
    (of_object_init_f)of_bsn_interface_init,                          /* 150 */
    (of_object_init_f)of_bsn_vport_header_init,                       /* 151 */
    (of_object_init_f)of_bsn_vport_header_init,                       /* 152 */
    (of_object_init_f)of_bsn_vport_q_in_q_init,                       /* 153 */
    (of_object_init_f)of_bucket_init,                                 /* 154 */
    (of_object_init_f)of_bucket_counter_init,                         /* 155 */
    (of_object_init_f)of_experimenter_multipart_header_init,          /* 156 */
    (of_object_init_f)of_flow_stats_entry_init,                       /* 157 */
    (of_object_init_f)of_group_desc_stats_entry_init,                 /* 158 */
    (of_object_init_f)of_group_stats_entry_init,                      /* 159 */
    (of_object_init_f)of_header_init,                                 /* 160 */
    (of_object_init_f)of_hello_elem_header_init,                      /* 161 */
    (of_object_init_f)of_hello_elem_header_init,                      /* 162 */
    (of_object_init_f)of_hello_elem_versionbitmap_init,               /* 163 */
    (of_object_init_f)of_instruction_header_init,                     /* 164 */
    (of_object_init_f)of_instruction_apply_actions_init,              /* 165 */
    (of_object_init_f)of_instruction_clear_actions_init,              /* 166 */
    (of_object_init_f)of_instruction_experimenter_init,               /* 167 */
    (of_object_init_f)of_instruction_goto_table_init,                 /* 168 */
    (of_object_init_f)of_instruction_header_init,                     /* 169 */
    (of_object_init_f)of_instruction_meter_init,                      /* 170 */
    (of_object_init_f)of_instruction_write_actions_init,              /* 171 */
    (of_object_init_f)of_instruction_write_metadata_init,             /* 172 */
    (of_object_init_f)of_match_v1_init,                               /* 173 */
    (of_object_init_f)of_match_v2_init,                               /* 174 */
    (of_object_init_f)of_match_v3_init,                               /* 175 */
    (of_object_init_f)of_meter_band_header_init,                      /* 176 */
    (of_object_init_f)of_meter_band_drop_init,                        /* 177 */
    (of_object_init_f)of_meter_band_dscp_remark_init,                 /* 178 */
    (of_object_init_f)of_meter_band_experimenter_init,                /* 179 */
    (of_object_init_f)of_meter_band_header_init,                      /* 180 */
    (of_object_init_f)of_meter_band_stats_init,                       /* 181 */
    (of_object_init_f)of_meter_config_init,                           /* 182 */
    (of_object_init_f)of_meter_features_init,                         /* 183 */
    (of_object_init_f)of_meter_stats_init,                            /* 184 */
    (of_object_init_f)of_oxm_header_init,                             /* 185 */
    (of_object_init_f)of_oxm_arp_op_init,                             /* 186 */
    (of_object_init_f)of_oxm_arp_op_masked_init,                      /* 187 */
    (of_object_init_f)of_oxm_arp_sha_init,                            /* 188 */
    (of_object_init_f)of_oxm_arp_sha_masked_init,                     /* 189 */
    (of_object_init_f)of_oxm_arp_spa_init,                            /* 190 */
    (of_object_init_f)of_oxm_arp_spa_masked_init,                     /* 191 */
    (of_object_init_f)of_oxm_arp_tha_init,                            /* 192 */
    (of_object_init_f)of_oxm_arp_tha_masked_init,                     /* 193 */
    (of_object_init_f)of_oxm_arp_tpa_init,                            /* 194 */
    (of_object_init_f)of_oxm_arp_tpa_masked_init,                     /* 195 */
    (of_object_init_f)of_oxm_eth_dst_init,                            /* 196 */
    (of_object_init_f)of_oxm_eth_dst_masked_init,                     /* 197 */
    (of_object_init_f)of_oxm_eth_src_init,                            /* 198 */
    (of_object_init_f)of_oxm_eth_src_masked_init,                     /* 199 */
    (of_object_init_f)of_oxm_eth_type_init,                           /* 200 */
    (of_object_init_f)of_oxm_eth_type_masked_init,                    /* 201 */
    (of_object_init_f)of_oxm_header_init,                             /* 202 */
    (of_object_init_f)of_oxm_icmpv4_code_init,                        /* 203 */
    (of_object_init_f)of_oxm_icmpv4_code_masked_init,                 /* 204 */
    (of_object_init_f)of_oxm_icmpv4_type_init,                        /* 205 */
    (of_object_init_f)of_oxm_icmpv4_type_masked_init,                 /* 206 */
    (of_object_init_f)of_oxm_icmpv6_code_init,                        /* 207 */
    (of_object_init_f)of_oxm_icmpv6_code_masked_init,                 /* 208 */
    (of_object_init_f)of_oxm_icmpv6_type_init,                        /* 209 */
    (of_object_init_f)of_oxm_icmpv6_type_masked_init,                 /* 210 */
    (of_object_init_f)of_oxm_in_phy_port_init,                        /* 211 */
    (of_object_init_f)of_oxm_in_phy_port_masked_init,                 /* 212 */
    (of_object_init_f)of_oxm_in_port_init,                            /* 213 */
    (of_object_init_f)of_oxm_in_port_masked_init,                     /* 214 */
    (of_object_init_f)of_oxm_ip_dscp_init,                            /* 215 */
    (of_object_init_f)of_oxm_ip_dscp_masked_init,                     /* 216 */
    (of_object_init_f)of_oxm_ip_ecn_init,                             /* 217 */
    (of_object_init_f)of_oxm_ip_ecn_masked_init,                      /* 218 */
    (of_object_init_f)of_oxm_ip_proto_init,                           /* 219 */
    (of_object_init_f)of_oxm_ip_proto_masked_init,                    /* 220 */
    (of_object_init_f)of_oxm_ipv4_dst_init,                           /* 221 */
    (of_object_init_f)of_oxm_ipv4_dst_masked_init,                    /* 222 */
    (of_object_init_f)of_oxm_ipv4_src_init,                           /* 223 */
    (of_object_init_f)of_oxm_ipv4_src_masked_init,                    /* 224 */
    (of_object_init_f)of_oxm_ipv6_dst_init,                           /* 225 */
    (of_object_init_f)of_oxm_ipv6_dst_masked_init,                    /* 226 */
    (of_object_init_f)of_oxm_ipv6_flabel_init,                        /* 227 */
    (of_object_init_f)of_oxm_ipv6_flabel_masked_init,                 /* 228 */
    (of_object_init_f)of_oxm_ipv6_nd_sll_init,                        /* 229 */
    (of_object_init_f)of_oxm_ipv6_nd_sll_masked_init,                 /* 230 */
    (of_object_init_f)of_oxm_ipv6_nd_target_init,                     /* 231 */
    (of_object_init_f)of_oxm_ipv6_nd_target_masked_init,              /* 232 */
    (of_object_init_f)of_oxm_ipv6_nd_tll_init,                        /* 233 */
    (of_object_init_f)of_oxm_ipv6_nd_tll_masked_init,                 /* 234 */
    (of_object_init_f)of_oxm_ipv6_src_init,                           /* 235 */
    (of_object_init_f)of_oxm_ipv6_src_masked_init,                    /* 236 */
    (of_object_init_f)of_oxm_metadata_init,                           /* 237 */
    (of_object_init_f)of_oxm_metadata_masked_init,                    /* 238 */
    (of_object_init_f)of_oxm_mpls_label_init,                         /* 239 */
    (of_object_init_f)of_oxm_mpls_label_masked_init,                  /* 240 */
    (of_object_init_f)of_oxm_mpls_tc_init,                            /* 241 */
    (of_object_init_f)of_oxm_mpls_tc_masked_init,                     /* 242 */
    (of_object_init_f)of_oxm_sctp_dst_init,                           /* 243 */
    (of_object_init_f)of_oxm_sctp_dst_masked_init,                    /* 244 */
    (of_object_init_f)of_oxm_sctp_src_init,                           /* 245 */
    (of_object_init_f)of_oxm_sctp_src_masked_init,                    /* 246 */
    (of_object_init_f)of_oxm_tcp_dst_init,                            /* 247 */
    (of_object_init_f)of_oxm_tcp_dst_masked_init,                     /* 248 */
    (of_object_init_f)of_oxm_tcp_src_init,                            /* 249 */
    (of_object_init_f)of_oxm_tcp_src_masked_init,                     /* 250 */
    (of_object_init_f)of_oxm_udp_dst_init,                            /* 251 */
    (of_object_init_f)of_oxm_udp_dst_masked_init,                     /* 252 */
    (of_object_init_f)of_oxm_udp_src_init,                            /* 253 */
    (of_object_init_f)of_oxm_udp_src_masked_init,                     /* 254 */
    (of_object_init_f)of_oxm_vlan_pcp_init,                           /* 255 */
    (of_object_init_f)of_oxm_vlan_pcp_masked_init,                    /* 256 */
    (of_object_init_f)of_oxm_vlan_vid_init,                           /* 257 */
    (of_object_init_f)of_oxm_vlan_vid_masked_init,                    /* 258 */
    (of_object_init_f)of_packet_queue_init,                           /* 259 */
    (of_object_init_f)of_port_desc_init,                              /* 260 */
    (of_object_init_f)of_port_stats_entry_init,                       /* 261 */
    (of_object_init_f)of_queue_prop_header_init,                      /* 262 */
    (of_object_init_f)of_queue_prop_experimenter_init,                /* 263 */
    (of_object_init_f)of_queue_prop_header_init,                      /* 264 */
    (of_object_init_f)of_queue_prop_max_rate_init,                    /* 265 */
    (of_object_init_f)of_queue_prop_min_rate_init,                    /* 266 */
    (of_object_init_f)of_queue_stats_entry_init,                      /* 267 */
    (of_object_init_f)of_table_feature_prop_header_init,              /* 268 */
    (of_object_init_f)of_table_feature_prop_apply_actions_init,       /* 269 */
    (of_object_init_f)of_table_feature_prop_apply_actions_miss_init,  /* 270 */
    (of_object_init_f)of_table_feature_prop_apply_setfield_init,      /* 271 */
    (of_object_init_f)of_table_feature_prop_apply_setfield_miss_init, /* 272 */
    (of_object_init_f)of_table_feature_prop_experimenter_init,        /* 273 */
    (of_object_init_f)of_table_feature_prop_header_init,              /* 274 */
    (of_object_init_f)of_table_feature_prop_instructions_init,        /* 275 */
    (of_object_init_f)of_table_feature_prop_instructions_miss_init,   /* 276 */
    (of_object_init_f)of_table_feature_prop_match_init,               /* 277 */
    (of_object_init_f)of_table_feature_prop_next_tables_init,         /* 278 */
    (of_object_init_f)of_table_feature_prop_next_tables_miss_init,    /* 279 */
    (of_object_init_f)of_table_feature_prop_wildcards_init,           /* 280 */
    (of_object_init_f)of_table_feature_prop_write_actions_init,       /* 281 */
    (of_object_init_f)of_table_feature_prop_write_actions_miss_init,  /* 282 */
    (of_object_init_f)of_table_feature_prop_write_setfield_init,      /* 283 */
    (of_object_init_f)of_table_feature_prop_write_setfield_miss_init, /* 284 */
    (of_object_init_f)of_table_features_init,                         /* 285 */
    (of_object_init_f)of_table_stats_entry_init,                      /* 286 */
    (of_object_init_f)of_uint32_init,                                 /* 287 */
    (of_object_init_f)of_uint8_init,                                  /* 288 */
    (of_object_init_f)of_list_action_init,                            /* 289 */
    (of_object_init_f)of_list_action_id_init,                         /* 290 */
    (of_object_init_f)of_list_bsn_interface_init,                     /* 291 */
    (of_object_init_f)of_list_bucket_init,                            /* 292 */
    (of_object_init_f)of_list_bucket_counter_init,                    /* 293 */
    (of_object_init_f)of_list_flow_stats_entry_init,                  /* 294 */
    (of_object_init_f)of_list_group_desc_stats_entry_init,            /* 295 */
    (of_object_init_f)of_list_group_stats_entry_init,                 /* 296 */
    (of_object_init_f)of_list_hello_elem_init,                        /* 297 */
    (of_object_init_f)of_list_instruction_init,                       /* 298 */
    (of_object_init_f)of_list_meter_band_init,                        /* 299 */
    (of_object_init_f)of_list_meter_band_stats_init,                  /* 300 */
    (of_object_init_f)of_list_meter_stats_init,                       /* 301 */
    (of_object_init_f)of_list_oxm_init,                               /* 302 */
    (of_object_init_f)of_list_packet_queue_init,                      /* 303 */
    (of_object_init_f)of_list_port_desc_init,                         /* 304 */
    (of_object_init_f)of_list_port_stats_entry_init,                  /* 305 */
    (of_object_init_f)of_list_queue_prop_init,                        /* 306 */
    (of_object_init_f)of_list_queue_stats_entry_init,                 /* 307 */
    (of_object_init_f)of_list_table_feature_prop_init,                /* 308 */
    (of_object_init_f)of_list_table_features_init,                    /* 309 */
    (of_object_init_f)of_list_table_stats_entry_init,                 /* 310 */
    (of_object_init_f)of_list_uint32_init,                            /* 311 */
    (of_object_init_f)of_list_uint8_init                              /* 312 */
};

/* This code should be broken out to a different file */


/* Flow stats entry setup for all versions */

static int
flow_stats_entry_setup_from_flow_add_common(of_flow_stats_entry_t *obj,
                                            of_flow_add_t *flow_add,
                                            of_object_t *effects,
                                            int entry_match_offset,
                                            int add_match_offset)
{
    int entry_len, add_len;
    of_wire_buffer_t *wbuf;
    int abs_offset;
    int delta;
    uint16_t val16;
    uint64_t cookie;
    of_octets_t match_octets;

    /* Transfer the match underlying object from add to stats entry */
    wbuf = OF_OBJECT_TO_WBUF(obj);
    entry_len = _WIRE_MATCH_PADDED_LEN(obj, entry_match_offset);
    add_len = _WIRE_MATCH_PADDED_LEN(flow_add, add_match_offset);

    match_octets.bytes = add_len;
    match_octets.data = OF_OBJECT_BUFFER_INDEX(flow_add, add_match_offset);

    /* Copy data into flow entry */
    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, entry_match_offset);
    of_wire_buffer_replace_data(wbuf, abs_offset, entry_len,
                                match_octets.data, add_len);

    /* Not scalar, update lengths if needed */
    delta = add_len - entry_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    of_flow_add_cookie_get(flow_add, &cookie);
    of_flow_stats_entry_cookie_set(obj, cookie);

    of_flow_add_priority_get(flow_add, &val16);
    of_flow_stats_entry_priority_set(obj, val16);

    of_flow_add_idle_timeout_get(flow_add, &val16);
    of_flow_stats_entry_idle_timeout_set(obj, val16);

    of_flow_add_hard_timeout_get(flow_add, &val16);
    of_flow_stats_entry_hard_timeout_set(obj, val16);

    /* Effects may come from different places */
    if (effects != NULL) {
        if (obj->version == OF_VERSION_1_0) {
            OF_TRY(of_flow_stats_entry_actions_set(obj,
                (of_list_action_t *)effects));
        } else {
            OF_TRY(of_flow_stats_entry_instructions_set(obj,
                (of_list_instruction_t *)effects));
        }
    } else {
        if (obj->version == OF_VERSION_1_0) {
            of_list_action_t actions;
            of_flow_add_actions_bind(flow_add, &actions);
            OF_TRY(of_flow_stats_entry_actions_set(obj, &actions));
        } else {
            of_list_instruction_t instructions;
            of_flow_add_instructions_bind(flow_add, &instructions);
            OF_TRY(of_flow_stats_entry_instructions_set(obj, &instructions));
        }
    }

    return OF_ERROR_NONE;
}

/* Flow removed setup for all versions */

static int
flow_removed_setup_from_flow_add_common(of_flow_removed_t *obj,
                                        of_flow_add_t *flow_add,
                                        int removed_match_offset,
                                        int add_match_offset)
{
    int add_len, removed_len;
    of_wire_buffer_t *wbuf;
    int abs_offset;
    int delta;
    uint16_t val16;
    uint64_t cookie;
    of_octets_t match_octets;

    /* Transfer the match underlying object from add to removed obj */
    wbuf = OF_OBJECT_TO_WBUF(obj);
    removed_len = _WIRE_MATCH_PADDED_LEN(obj, removed_match_offset);
    add_len = _WIRE_MATCH_PADDED_LEN(flow_add, add_match_offset);

    match_octets.bytes = add_len;
    match_octets.data = OF_OBJECT_BUFFER_INDEX(flow_add, add_match_offset);

    /* Copy data into flow removed */
    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, removed_match_offset);
    of_wire_buffer_replace_data(wbuf, abs_offset, removed_len,
                                match_octets.data, add_len);

    /* Not scalar, update lengths if needed */
    delta = add_len - removed_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    of_flow_add_cookie_get(flow_add, &cookie);
    of_flow_removed_cookie_set(obj, cookie);

    of_flow_add_priority_get(flow_add, &val16);
    of_flow_removed_priority_set(obj, val16);

    of_flow_add_idle_timeout_get(flow_add, &val16);
    of_flow_removed_idle_timeout_set(obj, val16);

    if (obj->version >= OF_VERSION_1_2) {
        of_flow_add_hard_timeout_get(flow_add, &val16);
        of_flow_removed_hard_timeout_set(obj, val16);
    }

    return OF_ERROR_NONE;
}

/* Set up a flow removed message from the original add */

int
of_flow_removed_setup_from_flow_add(of_flow_removed_t *obj,
                                    of_flow_add_t *flow_add)
{
    switch (obj->version) {
    case OF_VERSION_1_0:
        return flow_removed_setup_from_flow_add_common(obj, flow_add,
                                                       8, 8);
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        return flow_removed_setup_from_flow_add_common(obj, flow_add,
                                                       48, 48);
        break;
    default:
        return OF_ERROR_VERSION;
        break;
    }

    return OF_ERROR_NONE;
}


/* Set up a packet in message from the original add */

int
of_packet_in_setup_from_flow_add(of_packet_in_t *obj,
                                 of_flow_add_t *flow_add)
{
    int add_len, pkt_in_len;
    of_wire_buffer_t *wbuf;
    int abs_offset;
    int delta;
    const int pkt_in_match_offset = 16;
    const int add_match_offset = 48;
    of_octets_t match_octets;

    if (obj->version < OF_VERSION_1_2) {
        /* Nothing to be done before OF 1.2 */
        return OF_ERROR_NONE;
    }

    /* Transfer match struct from flow add to packet in object */
    wbuf = OF_OBJECT_TO_WBUF(obj);
    pkt_in_len = _WIRE_MATCH_PADDED_LEN(obj, pkt_in_match_offset);
    add_len = _WIRE_MATCH_PADDED_LEN(flow_add, add_match_offset);

    match_octets.bytes = add_len;
    match_octets.data = OF_OBJECT_BUFFER_INDEX(flow_add, add_match_offset);

    /* Copy data into pkt_in msg */
    abs_offset = OF_OBJECT_ABSOLUTE_OFFSET(obj, pkt_in_match_offset);
    of_wire_buffer_replace_data(wbuf, abs_offset, pkt_in_len,
                                match_octets.data, add_len);

    /* Not scalar, update lengths if needed */
    delta = add_len - pkt_in_len;
    if (delta != 0) {
        /* Update parent(s) */
        of_object_parent_length_update((of_object_t *)obj, delta);
    }

    return OF_ERROR_NONE;
}

/* Set up a stats entry from the original add */

int
of_flow_stats_entry_setup_from_flow_add(of_flow_stats_entry_t *obj,
                                        of_flow_add_t *flow_add,
                                        of_object_t *effects)
{
    switch (obj->version) {
    case OF_VERSION_1_0:
        return flow_stats_entry_setup_from_flow_add_common(obj, flow_add,
                                                           effects, 4, 8);
        break;
    case OF_VERSION_1_1:
    case OF_VERSION_1_2:
    case OF_VERSION_1_3:
        return flow_stats_entry_setup_from_flow_add_common(obj, flow_add,
                                                           effects, 48, 48);
        break;
    default:
        return OF_ERROR_VERSION;
    }

    return OF_ERROR_NONE;
}
