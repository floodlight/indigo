/* Copyright (c) 2008 The Board of Trustees of The Leland Stanford Junior University */
/* Copyright (c) 2011, 2012 Open Networking Foundation */
/* Copyright (c) 2012, 2013 Big Switch Networks, Inc. */
/* See the file LICENSE.loci which should have been included in the source distribution */

/****************************************************************
 * File: of_match.c
 *
 * DO NOT EDIT
 *
 * This file is automatically generated
 *
 ****************************************************************/

#include "loci_log.h"
#include <loci/loci.h>


/* Some internal macros and utility functions */

/* For counting bits in a uint32 */
#define _VAL_AND_5s(v)  ((v) & 0x55555555)
#define _VAL_EVERY_OTHER(v)  (_VAL_AND_5s(v) + _VAL_AND_5s(v >> 1))
#define _VAL_AND_3s(v)  ((v) & 0x33333333)
#define _VAL_PAIRS(v)  (_VAL_AND_3s(v) + _VAL_AND_3s(v >> 2))
#define _VAL_QUADS(v)  (((val) + ((val) >> 4)) & 0x0F0F0F0F)
#define _VAL_BYTES(v)  ((val) + ((val) >> 8))

/**
 * Counts the number of bits set in an integer
 */
static inline int
_COUNT_BITS(unsigned int val)
{
    val = _VAL_EVERY_OTHER(val);
    val = _VAL_PAIRS(val);
    val = _VAL_QUADS(val);
    val = _VAL_BYTES(val);

    return (val & 0XFF) + ((val >> 16) & 0xFF);
}

/* Indexed by version number */
const uint64_t of_match_incompat[4] = {
    -1,
    OF_MATCH_V1_INCOMPAT,
    OF_MATCH_V2_INCOMPAT,
    0
};


/**
 * IP Mask map.  IP maks wildcards from OF 1.0 are interpretted as
 * indices into the map below.
 */

int of_ip_mask_map_init_done = 0;
uint32_t of_ip_mask_map[OF_IP_MASK_MAP_COUNT];
void
of_ip_mask_map_init(void)
{
    int idx;

    MEMSET(of_ip_mask_map, 0, sizeof(of_ip_mask_map));
    for (idx = 0; idx < 32; idx++) {
        of_ip_mask_map[idx] = ~((1U << idx) - 1);
    }

    of_ip_mask_map_init_done = 1;
}

/**
 * @brief Set non-default IP mask for given index
 */
int
of_ip_mask_map_set(int index, uint32_t mask)
{
    OF_IP_MASK_INIT_CHECK;

    if ((index < 0) || (index >= OF_IP_MASK_MAP_COUNT)) {
        return OF_ERROR_RANGE;
    }
    of_ip_mask_map[index] = mask;

    return OF_ERROR_NONE;
}

/**
 * @brief Get a non-default IP mask for given index
 */
int
of_ip_mask_map_get(int index, uint32_t *mask)
{
    OF_IP_MASK_INIT_CHECK;

    if ((mask == NULL) || (index < 0) || (index >= OF_IP_MASK_MAP_COUNT)) {
        return OF_ERROR_RANGE;
    }
    *mask = of_ip_mask_map[index];

    return OF_ERROR_NONE;
}

/**
 * @brief Return the index (used as the WC field in 1.0 match) given the mask
 */

int
of_ip_mask_to_index(uint32_t mask)
{
    int idx;

    OF_IP_MASK_INIT_CHECK;

    /* Handle most common cases directly */
    if ((mask == 0) && (of_ip_mask_map[63] == 0)) {
        return 63;
    }
    if ((mask == 0xffffffff) && (of_ip_mask_map[0] == 0xffffffff)) {
        return 0;
    }

    for (idx = 0; idx < OF_IP_MASK_MAP_COUNT; idx++) {
        if (mask == of_ip_mask_map[idx]) {
            return idx;
        }
    }

    LOCI_LOG_INFO("OF 1.0: Could not map IP addr mask 0x%x", mask);
    return 0x3f;
}

/**
 * @brief Return the mask for the given index
 */

uint32_t
of_ip_index_to_mask(int index)
{
    OF_IP_MASK_INIT_CHECK;

    if (index >= OF_IP_MASK_MAP_COUNT) {
        LOCI_LOG_INFO("IP index to map: bad index %d", index);
        return 0;
    }

    return of_ip_mask_map[index];
}


/**
 * Check if match is compatible with OF 1.0
 * @param match The match being checked
 */
static inline int
of_match_v1_compat_check(of_match_t *match)
{

    if (OF_MATCH_MASK_IPV6_FLABEL_ACTIVE_TEST(match)) {
        return 0;
    }

    if (OF_MATCH_MASK_IPV6_DST_ACTIVE_TEST(match)) {
        return 0;
    }

    if (OF_MATCH_MASK_ARP_TPA_ACTIVE_TEST(match)) {
        return 0;
    }

    if (OF_MATCH_MASK_ICMPV6_TYPE_ACTIVE_TEST(match)) {
        return 0;
    }

    if (OF_MATCH_MASK_ARP_SHA_ACTIVE_TEST(match)) {
        return 0;
    }

    if (OF_MATCH_MASK_IPV6_SRC_ACTIVE_TEST(match)) {
        return 0;
    }

    if (OF_MATCH_MASK_SCTP_SRC_ACTIVE_TEST(match)) {
        return 0;
    }

    if (OF_MATCH_MASK_ICMPV6_CODE_ACTIVE_TEST(match)) {
        return 0;
    }

    if (OF_MATCH_MASK_IPV6_ND_SLL_ACTIVE_TEST(match)) {
        return 0;
    }

    if (OF_MATCH_MASK_MPLS_TC_ACTIVE_TEST(match)) {
        return 0;
    }

    if (OF_MATCH_MASK_ARP_OP_ACTIVE_TEST(match)) {
        return 0;
    }

    if (OF_MATCH_MASK_ARP_THA_ACTIVE_TEST(match)) {
        return 0;
    }

    if (OF_MATCH_MASK_SCTP_DST_ACTIVE_TEST(match)) {
        return 0;
    }

    if (OF_MATCH_MASK_ICMPV4_CODE_ACTIVE_TEST(match)) {
        return 0;
    }

    if (OF_MATCH_MASK_ARP_SPA_ACTIVE_TEST(match)) {
        return 0;
    }

    if (OF_MATCH_MASK_IP_ECN_ACTIVE_TEST(match)) {
        return 0;
    }

    if (OF_MATCH_MASK_UDP_DST_ACTIVE_TEST(match)) {
        return 0;
    }

    if (OF_MATCH_MASK_IPV6_ND_TARGET_ACTIVE_TEST(match)) {
        return 0;
    }

    if (OF_MATCH_MASK_IN_PHY_PORT_ACTIVE_TEST(match)) {
        return 0;
    }

    if (OF_MATCH_MASK_UDP_SRC_ACTIVE_TEST(match)) {
        return 0;
    }

    if (OF_MATCH_MASK_IPV6_ND_TLL_ACTIVE_TEST(match)) {
        return 0;
    }

    if (OF_MATCH_MASK_ICMPV4_TYPE_ACTIVE_TEST(match)) {
        return 0;
    }

    if (OF_MATCH_MASK_MPLS_LABEL_ACTIVE_TEST(match)) {
        return 0;
    }

    if (OF_MATCH_MASK_METADATA_ACTIVE_TEST(match)) {
        return 0;
    }

    return 1;
}

/**
 * Convert a generic match object to an OF_VERSION_1_0 object
 * @param src Pointer to the generic match object source
 * @param dst Pointer to the OF 1.0 wire structure
 *
 * The wire structure is initialized by this function if it doesn't
 * not have the proper object ID.
 */

int
of_match_to_wire_match_v1(of_match_t *src, of_match_v1_t *dst)
{
    of_wc_bmap_t wildcards = 0;
    int ip_mask_index;

    if ((src == NULL) || (dst == NULL)) {
        return OF_ERROR_PARAM;
    }
    if (!of_match_v1_compat_check(src)) {
        return OF_ERROR_COMPAT;
    }
    if (dst->object_id != OF_MATCH_V1) {
        of_match_v1_init(dst, OF_VERSION_1_0, 0, 0);
    }

    if (OF_MATCH_MASK_DST_META_ID_ACTIVE_TEST(src)) {
        of_match_v1_dst_meta_id_set(dst, src->fields.dst_meta_id);
    } else {
        OF_MATCH_V1_WC_DST_META_ID_SET(wildcards);
    }

    if (OF_MATCH_MASK_ETH_DST_ACTIVE_TEST(src)) {
        of_match_v1_eth_dst_set(dst, src->fields.eth_dst);
    } else {
        OF_MATCH_V1_WC_ETH_DST_SET(wildcards);
    }

    if (OF_MATCH_MASK_ETH_SRC_ACTIVE_TEST(src)) {
        of_match_v1_eth_src_set(dst, src->fields.eth_src);
    } else {
        OF_MATCH_V1_WC_ETH_SRC_SET(wildcards);
    }

    if (OF_MATCH_MASK_ETH_TYPE_ACTIVE_TEST(src)) {
        of_match_v1_eth_type_set(dst, src->fields.eth_type);
    } else {
        OF_MATCH_V1_WC_ETH_TYPE_SET(wildcards);
    }

    if (OF_MATCH_MASK_IN_PORT_ACTIVE_TEST(src)) {
        of_match_v1_in_port_set(dst, src->fields.in_port);
    } else {
        OF_MATCH_V1_WC_IN_PORT_SET(wildcards);
    }

    if (OF_MATCH_MASK_IP_DSCP_ACTIVE_TEST(src)) {
        of_match_v1_ip_dscp_set(dst, src->fields.ip_dscp);
    } else {
        OF_MATCH_V1_WC_IP_DSCP_SET(wildcards);
    }

    if (OF_MATCH_MASK_IP_PROTO_ACTIVE_TEST(src)) {
        of_match_v1_ip_proto_set(dst, src->fields.ip_proto);
    } else {
        OF_MATCH_V1_WC_IP_PROTO_SET(wildcards);
    }

    if (OF_MATCH_MASK_IPV4_DST_ACTIVE_TEST(src)) {
        ip_mask_index = of_ip_mask_to_index(src->masks.ipv4_dst);
        of_match_v1_ipv4_dst_set(dst, src->fields.ipv4_dst);
    } else { /* Wildcarded, look for 0 mask */
        ip_mask_index = of_ip_mask_to_index(0);
    }
    OF_MATCH_V1_WC_IPV4_DST_SET(wildcards, ip_mask_index);

    if (OF_MATCH_MASK_IPV4_SRC_ACTIVE_TEST(src)) {
        ip_mask_index = of_ip_mask_to_index(src->masks.ipv4_src);
        of_match_v1_ipv4_src_set(dst, src->fields.ipv4_src);
    } else { /* Wildcarded, look for 0 mask */
        ip_mask_index = of_ip_mask_to_index(0);
    }
    OF_MATCH_V1_WC_IPV4_SRC_SET(wildcards, ip_mask_index);

    if (OF_MATCH_MASK_SRC_META_ID_ACTIVE_TEST(src)) {
        of_match_v1_src_meta_id_set(dst, src->fields.src_meta_id);
    } else {
        OF_MATCH_V1_WC_SRC_META_ID_SET(wildcards);
    }

    if (OF_MATCH_MASK_TCP_DST_ACTIVE_TEST(src)) {
        of_match_v1_tcp_dst_set(dst, src->fields.tcp_dst);
    } else {
        OF_MATCH_V1_WC_TCP_DST_SET(wildcards);
    }

    if (OF_MATCH_MASK_TCP_SRC_ACTIVE_TEST(src)) {
        of_match_v1_tcp_src_set(dst, src->fields.tcp_src);
    } else {
        OF_MATCH_V1_WC_TCP_SRC_SET(wildcards);
    }

    if (OF_MATCH_MASK_VLAN_PCP_ACTIVE_TEST(src)) {
        of_match_v1_vlan_pcp_set(dst, src->fields.vlan_pcp);
    } else {
        OF_MATCH_V1_WC_VLAN_PCP_SET(wildcards);
    }

    if (OF_MATCH_MASK_VLAN_VID_ACTIVE_TEST(src)) {
        of_match_v1_vlan_vid_set(dst, src->fields.vlan_vid);
    } else {
        OF_MATCH_V1_WC_VLAN_VID_SET(wildcards);
    }

    of_match_v1_wildcards_set(dst, wildcards);

    return OF_ERROR_NONE;
}

/**
 * Check if match is compatible with OF 1.0
 * @param match The match being checked
 */
static inline int
of_match_v2_compat_check(of_match_t *match)
{

    if (OF_MATCH_MASK_IPV6_FLABEL_ACTIVE_TEST(match)) {
        return 0;
    }

    if (OF_MATCH_MASK_IPV6_DST_ACTIVE_TEST(match)) {
        return 0;
    }

    if (OF_MATCH_MASK_ARP_TPA_ACTIVE_TEST(match)) {
        return 0;
    }

    if (OF_MATCH_MASK_ICMPV6_TYPE_ACTIVE_TEST(match)) {
        return 0;
    }

    if (OF_MATCH_MASK_ARP_SHA_ACTIVE_TEST(match)) {
        return 0;
    }

    if (OF_MATCH_MASK_IPV6_SRC_ACTIVE_TEST(match)) {
        return 0;
    }

    if (OF_MATCH_MASK_SCTP_SRC_ACTIVE_TEST(match)) {
        return 0;
    }

    if (OF_MATCH_MASK_ICMPV6_CODE_ACTIVE_TEST(match)) {
        return 0;
    }

    if (OF_MATCH_MASK_IPV6_ND_SLL_ACTIVE_TEST(match)) {
        return 0;
    }

    if (OF_MATCH_MASK_ARP_OP_ACTIVE_TEST(match)) {
        return 0;
    }

    if (OF_MATCH_MASK_DST_META_ID_ACTIVE_TEST(match)) {
        return 0;
    }

    if (OF_MATCH_MASK_ARP_THA_ACTIVE_TEST(match)) {
        return 0;
    }

    if (OF_MATCH_MASK_SCTP_DST_ACTIVE_TEST(match)) {
        return 0;
    }

    if (OF_MATCH_MASK_ICMPV4_CODE_ACTIVE_TEST(match)) {
        return 0;
    }

    if (OF_MATCH_MASK_ARP_SPA_ACTIVE_TEST(match)) {
        return 0;
    }

    if (OF_MATCH_MASK_IP_ECN_ACTIVE_TEST(match)) {
        return 0;
    }

    if (OF_MATCH_MASK_SRC_META_ID_ACTIVE_TEST(match)) {
        return 0;
    }

    if (OF_MATCH_MASK_UDP_DST_ACTIVE_TEST(match)) {
        return 0;
    }

    if (OF_MATCH_MASK_IPV6_ND_TARGET_ACTIVE_TEST(match)) {
        return 0;
    }

    if (OF_MATCH_MASK_IN_PHY_PORT_ACTIVE_TEST(match)) {
        return 0;
    }

    if (OF_MATCH_MASK_UDP_SRC_ACTIVE_TEST(match)) {
        return 0;
    }

    if (OF_MATCH_MASK_IPV6_ND_TLL_ACTIVE_TEST(match)) {
        return 0;
    }

    if (OF_MATCH_MASK_ICMPV4_TYPE_ACTIVE_TEST(match)) {
        return 0;
    }

    return 1;
}

/**
 * Convert a generic match object to an OF_VERSION_1_1 object
 * @param src Pointer to the generic match object source
 * @param dst Pointer to the OF 1.1 wire structure
 *
 * The wire structure is initialized by this function.
 */

int
of_match_to_wire_match_v2(of_match_t *src, of_match_v2_t *dst)
{
    of_wc_bmap_t wildcards = 0;

    if ((src == NULL) || (dst == NULL)) {
        return OF_ERROR_PARAM;
    }
    if (!of_match_v2_compat_check(src)) {
        return OF_ERROR_COMPAT;
    }
    if (dst->object_id != OF_MATCH_V2) {
        of_match_v2_init(dst, OF_VERSION_1_1, 0, 0);
    }

    if (OF_MATCH_MASK_ETH_DST_ACTIVE_TEST(src)) {
        if (!OF_MATCH_MASK_ETH_DST_EXACT_TEST(src)) {
            of_match_v2_eth_dst_mask_set(dst,
                src->masks.eth_dst);
        } else { /* Exact match; use all ones mask */
            of_match_v2_eth_dst_mask_set(dst,
                of_mac_addr_all_ones);
        }
        of_match_v2_eth_dst_set(dst, src->fields.eth_dst);
    }


    if (OF_MATCH_MASK_ETH_SRC_ACTIVE_TEST(src)) {
        if (!OF_MATCH_MASK_ETH_SRC_EXACT_TEST(src)) {
            of_match_v2_eth_src_mask_set(dst,
                src->masks.eth_src);
        } else { /* Exact match; use all ones mask */
            of_match_v2_eth_src_mask_set(dst,
                of_mac_addr_all_ones);
        }
        of_match_v2_eth_src_set(dst, src->fields.eth_src);
    }


    if (!OF_MATCH_MASK_ETH_TYPE_EXACT_TEST(src)) {
        return OF_ERROR_COMPAT;
    }
    if (OF_MATCH_MASK_ETH_TYPE_ACTIVE_TEST(src)) {
        of_match_v2_eth_type_set(dst, src->fields.eth_type);
    } else {
        OF_MATCH_V2_WC_ETH_TYPE_SET(wildcards);
    }

    if (!OF_MATCH_MASK_IN_PORT_EXACT_TEST(src)) {
        return OF_ERROR_COMPAT;
    }
    if (OF_MATCH_MASK_IN_PORT_ACTIVE_TEST(src)) {
        of_match_v2_in_port_set(dst, src->fields.in_port);
    } else {
        OF_MATCH_V2_WC_IN_PORT_SET(wildcards);
    }

    if (OF_MATCH_MASK_IPV4_DST_ACTIVE_TEST(src)) {
        if (!OF_MATCH_MASK_IPV4_DST_EXACT_TEST(src)) {
            of_match_v2_ipv4_dst_mask_set(dst,
                src->masks.ipv4_dst);
        } else { /* Exact match; use all ones mask */
            of_match_v2_ipv4_dst_mask_set(dst,
                ((uint32_t) -1));
        }
        of_match_v2_ipv4_dst_set(dst, src->fields.ipv4_dst);
    }


    if (!OF_MATCH_MASK_IP_PROTO_EXACT_TEST(src)) {
        return OF_ERROR_COMPAT;
    }
    if (OF_MATCH_MASK_IP_PROTO_ACTIVE_TEST(src)) {
        of_match_v2_ip_proto_set(dst, src->fields.ip_proto);
    } else {
        OF_MATCH_V2_WC_IP_PROTO_SET(wildcards);
    }

    if (OF_MATCH_MASK_IPV4_SRC_ACTIVE_TEST(src)) {
        if (!OF_MATCH_MASK_IPV4_SRC_EXACT_TEST(src)) {
            of_match_v2_ipv4_src_mask_set(dst,
                src->masks.ipv4_src);
        } else { /* Exact match; use all ones mask */
            of_match_v2_ipv4_src_mask_set(dst,
                ((uint32_t) -1));
        }
        of_match_v2_ipv4_src_set(dst, src->fields.ipv4_src);
    }


    if (!OF_MATCH_MASK_IP_DSCP_EXACT_TEST(src)) {
        return OF_ERROR_COMPAT;
    }
    if (OF_MATCH_MASK_IP_DSCP_ACTIVE_TEST(src)) {
        of_match_v2_ip_dscp_set(dst, src->fields.ip_dscp);
    } else {
        OF_MATCH_V2_WC_IP_DSCP_SET(wildcards);
    }

    if (!OF_MATCH_MASK_TCP_DST_EXACT_TEST(src)) {
        return OF_ERROR_COMPAT;
    }
    if (OF_MATCH_MASK_TCP_DST_ACTIVE_TEST(src)) {
        of_match_v2_tcp_dst_set(dst, src->fields.tcp_dst);
    } else {
        OF_MATCH_V2_WC_TCP_DST_SET(wildcards);
    }

    if (!OF_MATCH_MASK_TCP_SRC_EXACT_TEST(src)) {
        return OF_ERROR_COMPAT;
    }
    if (OF_MATCH_MASK_TCP_SRC_ACTIVE_TEST(src)) {
        of_match_v2_tcp_src_set(dst, src->fields.tcp_src);
    } else {
        OF_MATCH_V2_WC_TCP_SRC_SET(wildcards);
    }

    if (!OF_MATCH_MASK_VLAN_PCP_EXACT_TEST(src)) {
        return OF_ERROR_COMPAT;
    }
    if (OF_MATCH_MASK_VLAN_PCP_ACTIVE_TEST(src)) {
        of_match_v2_vlan_pcp_set(dst, src->fields.vlan_pcp);
    } else {
        OF_MATCH_V2_WC_VLAN_PCP_SET(wildcards);
    }

    if (!OF_MATCH_MASK_VLAN_VID_EXACT_TEST(src)) {
        return OF_ERROR_COMPAT;
    }
    if (OF_MATCH_MASK_VLAN_VID_ACTIVE_TEST(src)) {
        of_match_v2_vlan_vid_set(dst, src->fields.vlan_vid);
    } else {
        OF_MATCH_V2_WC_VLAN_VID_SET(wildcards);
    }

    if (!OF_MATCH_MASK_MPLS_LABEL_EXACT_TEST(src)) {
        return OF_ERROR_COMPAT;
    }
    if (OF_MATCH_MASK_MPLS_LABEL_ACTIVE_TEST(src)) {
        of_match_v2_mpls_label_set(dst, src->fields.mpls_label);
    } else {
        OF_MATCH_V2_WC_MPLS_LABEL_SET(wildcards);
    }

    if (!OF_MATCH_MASK_MPLS_TC_EXACT_TEST(src)) {
        return OF_ERROR_COMPAT;
    }
    if (OF_MATCH_MASK_MPLS_TC_ACTIVE_TEST(src)) {
        of_match_v2_mpls_tc_set(dst, src->fields.mpls_tc);
    } else {
        OF_MATCH_V2_WC_MPLS_TC_SET(wildcards);
    }

    if (OF_MATCH_MASK_METADATA_ACTIVE_TEST(src)) {
        if (!OF_MATCH_MASK_METADATA_EXACT_TEST(src)) {
            of_match_v2_metadata_mask_set(dst,
                src->masks.metadata);
        } else { /* Exact match; use all ones mask */
            of_match_v2_metadata_mask_set(dst,
                ((uint64_t) -1));
        }
        of_match_v2_metadata_set(dst, src->fields.metadata);
    }


    of_match_v2_wildcards_set(dst, wildcards);

    return OF_ERROR_NONE;
}

static int
populate_oxm_list(of_match_t *src, of_list_oxm_t *oxm_list)
{
    of_oxm_t oxm_entry;

    /* For each active member, add an OXM entry to the list */
    if (OF_MATCH_MASK_IPV6_FLABEL_ACTIVE_TEST(src)) {
        if (!OF_MATCH_MASK_IPV6_FLABEL_EXACT_TEST(src)) {
            of_oxm_ipv6_flabel_masked_t *elt;
            elt = &oxm_entry.ipv6_flabel_masked;

            of_oxm_ipv6_flabel_masked_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_ipv6_flabel_masked_value_set(elt,
                   src->fields.ipv6_flabel);
            of_oxm_ipv6_flabel_masked_value_mask_set(elt,
                   src->masks.ipv6_flabel);
        } else {  /* Active, but not masked */
            of_oxm_ipv6_flabel_t *elt;
            elt = &oxm_entry.ipv6_flabel;
            of_oxm_ipv6_flabel_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_ipv6_flabel_value_set(elt, src->fields.ipv6_flabel);
        }
    }
    if (OF_MATCH_MASK_VLAN_PCP_ACTIVE_TEST(src)) {
        if (!OF_MATCH_MASK_VLAN_PCP_EXACT_TEST(src)) {
            of_oxm_vlan_pcp_masked_t *elt;
            elt = &oxm_entry.vlan_pcp_masked;

            of_oxm_vlan_pcp_masked_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_vlan_pcp_masked_value_set(elt,
                   src->fields.vlan_pcp);
            of_oxm_vlan_pcp_masked_value_mask_set(elt,
                   src->masks.vlan_pcp);
        } else {  /* Active, but not masked */
            of_oxm_vlan_pcp_t *elt;
            elt = &oxm_entry.vlan_pcp;
            of_oxm_vlan_pcp_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_vlan_pcp_value_set(elt, src->fields.vlan_pcp);
        }
    }
    if (OF_MATCH_MASK_IPV4_SRC_ACTIVE_TEST(src)) {
        if (!OF_MATCH_MASK_IPV4_SRC_EXACT_TEST(src)) {
            of_oxm_ipv4_src_masked_t *elt;
            elt = &oxm_entry.ipv4_src_masked;

            of_oxm_ipv4_src_masked_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_ipv4_src_masked_value_set(elt,
                   src->fields.ipv4_src);
            of_oxm_ipv4_src_masked_value_mask_set(elt,
                   src->masks.ipv4_src);
        } else {  /* Active, but not masked */
            of_oxm_ipv4_src_t *elt;
            elt = &oxm_entry.ipv4_src;
            of_oxm_ipv4_src_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_ipv4_src_value_set(elt, src->fields.ipv4_src);
        }
    }
    if (OF_MATCH_MASK_IPV6_DST_ACTIVE_TEST(src)) {
        if (!OF_MATCH_MASK_IPV6_DST_EXACT_TEST(src)) {
            of_oxm_ipv6_dst_masked_t *elt;
            elt = &oxm_entry.ipv6_dst_masked;

            of_oxm_ipv6_dst_masked_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_ipv6_dst_masked_value_set(elt,
                   src->fields.ipv6_dst);
            of_oxm_ipv6_dst_masked_value_mask_set(elt,
                   src->masks.ipv6_dst);
        } else {  /* Active, but not masked */
            of_oxm_ipv6_dst_t *elt;
            elt = &oxm_entry.ipv6_dst;
            of_oxm_ipv6_dst_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_ipv6_dst_value_set(elt, src->fields.ipv6_dst);
        }
    }
    if (OF_MATCH_MASK_ARP_TPA_ACTIVE_TEST(src)) {
        if (!OF_MATCH_MASK_ARP_TPA_EXACT_TEST(src)) {
            of_oxm_arp_tpa_masked_t *elt;
            elt = &oxm_entry.arp_tpa_masked;

            of_oxm_arp_tpa_masked_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_arp_tpa_masked_value_set(elt,
                   src->fields.arp_tpa);
            of_oxm_arp_tpa_masked_value_mask_set(elt,
                   src->masks.arp_tpa);
        } else {  /* Active, but not masked */
            of_oxm_arp_tpa_t *elt;
            elt = &oxm_entry.arp_tpa;
            of_oxm_arp_tpa_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_arp_tpa_value_set(elt, src->fields.arp_tpa);
        }
    }
    if (OF_MATCH_MASK_ICMPV6_TYPE_ACTIVE_TEST(src)) {
        if (!OF_MATCH_MASK_ICMPV6_TYPE_EXACT_TEST(src)) {
            of_oxm_icmpv6_type_masked_t *elt;
            elt = &oxm_entry.icmpv6_type_masked;

            of_oxm_icmpv6_type_masked_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_icmpv6_type_masked_value_set(elt,
                   src->fields.icmpv6_type);
            of_oxm_icmpv6_type_masked_value_mask_set(elt,
                   src->masks.icmpv6_type);
        } else {  /* Active, but not masked */
            of_oxm_icmpv6_type_t *elt;
            elt = &oxm_entry.icmpv6_type;
            of_oxm_icmpv6_type_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_icmpv6_type_value_set(elt, src->fields.icmpv6_type);
        }
    }
    if (OF_MATCH_MASK_ARP_SHA_ACTIVE_TEST(src)) {
        if (!OF_MATCH_MASK_ARP_SHA_EXACT_TEST(src)) {
            of_oxm_arp_sha_masked_t *elt;
            elt = &oxm_entry.arp_sha_masked;

            of_oxm_arp_sha_masked_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_arp_sha_masked_value_set(elt,
                   src->fields.arp_sha);
            of_oxm_arp_sha_masked_value_mask_set(elt,
                   src->masks.arp_sha);
        } else {  /* Active, but not masked */
            of_oxm_arp_sha_t *elt;
            elt = &oxm_entry.arp_sha;
            of_oxm_arp_sha_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_arp_sha_value_set(elt, src->fields.arp_sha);
        }
    }
    if (OF_MATCH_MASK_IPV6_SRC_ACTIVE_TEST(src)) {
        if (!OF_MATCH_MASK_IPV6_SRC_EXACT_TEST(src)) {
            of_oxm_ipv6_src_masked_t *elt;
            elt = &oxm_entry.ipv6_src_masked;

            of_oxm_ipv6_src_masked_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_ipv6_src_masked_value_set(elt,
                   src->fields.ipv6_src);
            of_oxm_ipv6_src_masked_value_mask_set(elt,
                   src->masks.ipv6_src);
        } else {  /* Active, but not masked */
            of_oxm_ipv6_src_t *elt;
            elt = &oxm_entry.ipv6_src;
            of_oxm_ipv6_src_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_ipv6_src_value_set(elt, src->fields.ipv6_src);
        }
    }
    if (OF_MATCH_MASK_SCTP_SRC_ACTIVE_TEST(src)) {
        if (!OF_MATCH_MASK_SCTP_SRC_EXACT_TEST(src)) {
            of_oxm_sctp_src_masked_t *elt;
            elt = &oxm_entry.sctp_src_masked;

            of_oxm_sctp_src_masked_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_sctp_src_masked_value_set(elt,
                   src->fields.sctp_src);
            of_oxm_sctp_src_masked_value_mask_set(elt,
                   src->masks.sctp_src);
        } else {  /* Active, but not masked */
            of_oxm_sctp_src_t *elt;
            elt = &oxm_entry.sctp_src;
            of_oxm_sctp_src_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_sctp_src_value_set(elt, src->fields.sctp_src);
        }
    }
    if (OF_MATCH_MASK_ICMPV6_CODE_ACTIVE_TEST(src)) {
        if (!OF_MATCH_MASK_ICMPV6_CODE_EXACT_TEST(src)) {
            of_oxm_icmpv6_code_masked_t *elt;
            elt = &oxm_entry.icmpv6_code_masked;

            of_oxm_icmpv6_code_masked_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_icmpv6_code_masked_value_set(elt,
                   src->fields.icmpv6_code);
            of_oxm_icmpv6_code_masked_value_mask_set(elt,
                   src->masks.icmpv6_code);
        } else {  /* Active, but not masked */
            of_oxm_icmpv6_code_t *elt;
            elt = &oxm_entry.icmpv6_code;
            of_oxm_icmpv6_code_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_icmpv6_code_value_set(elt, src->fields.icmpv6_code);
        }
    }
    if (OF_MATCH_MASK_ETH_DST_ACTIVE_TEST(src)) {
        if (!OF_MATCH_MASK_ETH_DST_EXACT_TEST(src)) {
            of_oxm_eth_dst_masked_t *elt;
            elt = &oxm_entry.eth_dst_masked;

            of_oxm_eth_dst_masked_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_eth_dst_masked_value_set(elt,
                   src->fields.eth_dst);
            of_oxm_eth_dst_masked_value_mask_set(elt,
                   src->masks.eth_dst);
        } else {  /* Active, but not masked */
            of_oxm_eth_dst_t *elt;
            elt = &oxm_entry.eth_dst;
            of_oxm_eth_dst_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_eth_dst_value_set(elt, src->fields.eth_dst);
        }
    }
    if (OF_MATCH_MASK_IPV6_ND_SLL_ACTIVE_TEST(src)) {
        if (!OF_MATCH_MASK_IPV6_ND_SLL_EXACT_TEST(src)) {
            of_oxm_ipv6_nd_sll_masked_t *elt;
            elt = &oxm_entry.ipv6_nd_sll_masked;

            of_oxm_ipv6_nd_sll_masked_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_ipv6_nd_sll_masked_value_set(elt,
                   src->fields.ipv6_nd_sll);
            of_oxm_ipv6_nd_sll_masked_value_mask_set(elt,
                   src->masks.ipv6_nd_sll);
        } else {  /* Active, but not masked */
            of_oxm_ipv6_nd_sll_t *elt;
            elt = &oxm_entry.ipv6_nd_sll;
            of_oxm_ipv6_nd_sll_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_ipv6_nd_sll_value_set(elt, src->fields.ipv6_nd_sll);
        }
    }
    if (OF_MATCH_MASK_MPLS_TC_ACTIVE_TEST(src)) {
        if (!OF_MATCH_MASK_MPLS_TC_EXACT_TEST(src)) {
            of_oxm_mpls_tc_masked_t *elt;
            elt = &oxm_entry.mpls_tc_masked;

            of_oxm_mpls_tc_masked_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_mpls_tc_masked_value_set(elt,
                   src->fields.mpls_tc);
            of_oxm_mpls_tc_masked_value_mask_set(elt,
                   src->masks.mpls_tc);
        } else {  /* Active, but not masked */
            of_oxm_mpls_tc_t *elt;
            elt = &oxm_entry.mpls_tc;
            of_oxm_mpls_tc_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_mpls_tc_value_set(elt, src->fields.mpls_tc);
        }
    }
    if (OF_MATCH_MASK_ARP_OP_ACTIVE_TEST(src)) {
        if (!OF_MATCH_MASK_ARP_OP_EXACT_TEST(src)) {
            of_oxm_arp_op_masked_t *elt;
            elt = &oxm_entry.arp_op_masked;

            of_oxm_arp_op_masked_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_arp_op_masked_value_set(elt,
                   src->fields.arp_op);
            of_oxm_arp_op_masked_value_mask_set(elt,
                   src->masks.arp_op);
        } else {  /* Active, but not masked */
            of_oxm_arp_op_t *elt;
            elt = &oxm_entry.arp_op;
            of_oxm_arp_op_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_arp_op_value_set(elt, src->fields.arp_op);
        }
    }
    if (OF_MATCH_MASK_ETH_TYPE_ACTIVE_TEST(src)) {
        if (!OF_MATCH_MASK_ETH_TYPE_EXACT_TEST(src)) {
            of_oxm_eth_type_masked_t *elt;
            elt = &oxm_entry.eth_type_masked;

            of_oxm_eth_type_masked_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_eth_type_masked_value_set(elt,
                   src->fields.eth_type);
            of_oxm_eth_type_masked_value_mask_set(elt,
                   src->masks.eth_type);
        } else {  /* Active, but not masked */
            of_oxm_eth_type_t *elt;
            elt = &oxm_entry.eth_type;
            of_oxm_eth_type_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_eth_type_value_set(elt, src->fields.eth_type);
        }
    }
    if (OF_MATCH_MASK_DST_META_ID_ACTIVE_TEST(src)) {
        if (!OF_MATCH_MASK_DST_META_ID_EXACT_TEST(src)) {
            of_oxm_dst_meta_id_masked_t *elt;
            elt = &oxm_entry.dst_meta_id_masked;

            of_oxm_dst_meta_id_masked_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_dst_meta_id_masked_value_set(elt,
                   src->fields.dst_meta_id);
            of_oxm_dst_meta_id_masked_value_mask_set(elt,
                   src->masks.dst_meta_id);
        } else {  /* Active, but not masked */
            of_oxm_dst_meta_id_t *elt;
            elt = &oxm_entry.dst_meta_id;
            of_oxm_dst_meta_id_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_dst_meta_id_value_set(elt, src->fields.dst_meta_id);
        }
    }
    if (OF_MATCH_MASK_VLAN_VID_ACTIVE_TEST(src)) {
        if (!OF_MATCH_MASK_VLAN_VID_EXACT_TEST(src)) {
            of_oxm_vlan_vid_masked_t *elt;
            elt = &oxm_entry.vlan_vid_masked;

            of_oxm_vlan_vid_masked_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_vlan_vid_masked_value_set(elt,
                   src->fields.vlan_vid);
            of_oxm_vlan_vid_masked_value_mask_set(elt,
                   src->masks.vlan_vid);
        } else {  /* Active, but not masked */
            of_oxm_vlan_vid_t *elt;
            elt = &oxm_entry.vlan_vid;
            of_oxm_vlan_vid_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_vlan_vid_value_set(elt, src->fields.vlan_vid);
        }
    }
    if (OF_MATCH_MASK_ARP_THA_ACTIVE_TEST(src)) {
        if (!OF_MATCH_MASK_ARP_THA_EXACT_TEST(src)) {
            of_oxm_arp_tha_masked_t *elt;
            elt = &oxm_entry.arp_tha_masked;

            of_oxm_arp_tha_masked_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_arp_tha_masked_value_set(elt,
                   src->fields.arp_tha);
            of_oxm_arp_tha_masked_value_mask_set(elt,
                   src->masks.arp_tha);
        } else {  /* Active, but not masked */
            of_oxm_arp_tha_t *elt;
            elt = &oxm_entry.arp_tha;
            of_oxm_arp_tha_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_arp_tha_value_set(elt, src->fields.arp_tha);
        }
    }
    if (OF_MATCH_MASK_IN_PORT_ACTIVE_TEST(src)) {
        if (!OF_MATCH_MASK_IN_PORT_EXACT_TEST(src)) {
            of_oxm_in_port_masked_t *elt;
            elt = &oxm_entry.in_port_masked;

            of_oxm_in_port_masked_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_in_port_masked_value_set(elt,
                   src->fields.in_port);
            of_oxm_in_port_masked_value_mask_set(elt,
                   src->masks.in_port);
        } else {  /* Active, but not masked */
            of_oxm_in_port_t *elt;
            elt = &oxm_entry.in_port;
            of_oxm_in_port_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_in_port_value_set(elt, src->fields.in_port);
        }
    }
    if (OF_MATCH_MASK_IP_DSCP_ACTIVE_TEST(src)) {
        if (!OF_MATCH_MASK_IP_DSCP_EXACT_TEST(src)) {
            of_oxm_ip_dscp_masked_t *elt;
            elt = &oxm_entry.ip_dscp_masked;

            of_oxm_ip_dscp_masked_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_ip_dscp_masked_value_set(elt,
                   src->fields.ip_dscp);
            of_oxm_ip_dscp_masked_value_mask_set(elt,
                   src->masks.ip_dscp);
        } else {  /* Active, but not masked */
            of_oxm_ip_dscp_t *elt;
            elt = &oxm_entry.ip_dscp;
            of_oxm_ip_dscp_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_ip_dscp_value_set(elt, src->fields.ip_dscp);
        }
    }
    if (OF_MATCH_MASK_SCTP_DST_ACTIVE_TEST(src)) {
        if (!OF_MATCH_MASK_SCTP_DST_EXACT_TEST(src)) {
            of_oxm_sctp_dst_masked_t *elt;
            elt = &oxm_entry.sctp_dst_masked;

            of_oxm_sctp_dst_masked_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_sctp_dst_masked_value_set(elt,
                   src->fields.sctp_dst);
            of_oxm_sctp_dst_masked_value_mask_set(elt,
                   src->masks.sctp_dst);
        } else {  /* Active, but not masked */
            of_oxm_sctp_dst_t *elt;
            elt = &oxm_entry.sctp_dst;
            of_oxm_sctp_dst_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_sctp_dst_value_set(elt, src->fields.sctp_dst);
        }
    }
    if (OF_MATCH_MASK_ICMPV4_CODE_ACTIVE_TEST(src)) {
        if (!OF_MATCH_MASK_ICMPV4_CODE_EXACT_TEST(src)) {
            of_oxm_icmpv4_code_masked_t *elt;
            elt = &oxm_entry.icmpv4_code_masked;

            of_oxm_icmpv4_code_masked_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_icmpv4_code_masked_value_set(elt,
                   src->fields.icmpv4_code);
            of_oxm_icmpv4_code_masked_value_mask_set(elt,
                   src->masks.icmpv4_code);
        } else {  /* Active, but not masked */
            of_oxm_icmpv4_code_t *elt;
            elt = &oxm_entry.icmpv4_code;
            of_oxm_icmpv4_code_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_icmpv4_code_value_set(elt, src->fields.icmpv4_code);
        }
    }
    if (OF_MATCH_MASK_TCP_SRC_ACTIVE_TEST(src)) {
        if (!OF_MATCH_MASK_TCP_SRC_EXACT_TEST(src)) {
            of_oxm_tcp_src_masked_t *elt;
            elt = &oxm_entry.tcp_src_masked;

            of_oxm_tcp_src_masked_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_tcp_src_masked_value_set(elt,
                   src->fields.tcp_src);
            of_oxm_tcp_src_masked_value_mask_set(elt,
                   src->masks.tcp_src);
        } else {  /* Active, but not masked */
            of_oxm_tcp_src_t *elt;
            elt = &oxm_entry.tcp_src;
            of_oxm_tcp_src_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_tcp_src_value_set(elt, src->fields.tcp_src);
        }
    }
    if (OF_MATCH_MASK_ARP_SPA_ACTIVE_TEST(src)) {
        if (!OF_MATCH_MASK_ARP_SPA_EXACT_TEST(src)) {
            of_oxm_arp_spa_masked_t *elt;
            elt = &oxm_entry.arp_spa_masked;

            of_oxm_arp_spa_masked_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_arp_spa_masked_value_set(elt,
                   src->fields.arp_spa);
            of_oxm_arp_spa_masked_value_mask_set(elt,
                   src->masks.arp_spa);
        } else {  /* Active, but not masked */
            of_oxm_arp_spa_t *elt;
            elt = &oxm_entry.arp_spa;
            of_oxm_arp_spa_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_arp_spa_value_set(elt, src->fields.arp_spa);
        }
    }
    if (OF_MATCH_MASK_IP_ECN_ACTIVE_TEST(src)) {
        if (!OF_MATCH_MASK_IP_ECN_EXACT_TEST(src)) {
            of_oxm_ip_ecn_masked_t *elt;
            elt = &oxm_entry.ip_ecn_masked;

            of_oxm_ip_ecn_masked_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_ip_ecn_masked_value_set(elt,
                   src->fields.ip_ecn);
            of_oxm_ip_ecn_masked_value_mask_set(elt,
                   src->masks.ip_ecn);
        } else {  /* Active, but not masked */
            of_oxm_ip_ecn_t *elt;
            elt = &oxm_entry.ip_ecn;
            of_oxm_ip_ecn_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_ip_ecn_value_set(elt, src->fields.ip_ecn);
        }
    }
    if (OF_MATCH_MASK_SRC_META_ID_ACTIVE_TEST(src)) {
        if (!OF_MATCH_MASK_SRC_META_ID_EXACT_TEST(src)) {
            of_oxm_src_meta_id_masked_t *elt;
            elt = &oxm_entry.src_meta_id_masked;

            of_oxm_src_meta_id_masked_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_src_meta_id_masked_value_set(elt,
                   src->fields.src_meta_id);
            of_oxm_src_meta_id_masked_value_mask_set(elt,
                   src->masks.src_meta_id);
        } else {  /* Active, but not masked */
            of_oxm_src_meta_id_t *elt;
            elt = &oxm_entry.src_meta_id;
            of_oxm_src_meta_id_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_src_meta_id_value_set(elt, src->fields.src_meta_id);
        }
    }
    if (OF_MATCH_MASK_UDP_DST_ACTIVE_TEST(src)) {
        if (!OF_MATCH_MASK_UDP_DST_EXACT_TEST(src)) {
            of_oxm_udp_dst_masked_t *elt;
            elt = &oxm_entry.udp_dst_masked;

            of_oxm_udp_dst_masked_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_udp_dst_masked_value_set(elt,
                   src->fields.udp_dst);
            of_oxm_udp_dst_masked_value_mask_set(elt,
                   src->masks.udp_dst);
        } else {  /* Active, but not masked */
            of_oxm_udp_dst_t *elt;
            elt = &oxm_entry.udp_dst;
            of_oxm_udp_dst_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_udp_dst_value_set(elt, src->fields.udp_dst);
        }
    }
    if (OF_MATCH_MASK_IPV6_ND_TARGET_ACTIVE_TEST(src)) {
        if (!OF_MATCH_MASK_IPV6_ND_TARGET_EXACT_TEST(src)) {
            of_oxm_ipv6_nd_target_masked_t *elt;
            elt = &oxm_entry.ipv6_nd_target_masked;

            of_oxm_ipv6_nd_target_masked_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_ipv6_nd_target_masked_value_set(elt,
                   src->fields.ipv6_nd_target);
            of_oxm_ipv6_nd_target_masked_value_mask_set(elt,
                   src->masks.ipv6_nd_target);
        } else {  /* Active, but not masked */
            of_oxm_ipv6_nd_target_t *elt;
            elt = &oxm_entry.ipv6_nd_target;
            of_oxm_ipv6_nd_target_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_ipv6_nd_target_value_set(elt, src->fields.ipv6_nd_target);
        }
    }
    if (OF_MATCH_MASK_IN_PHY_PORT_ACTIVE_TEST(src)) {
        if (!OF_MATCH_MASK_IN_PHY_PORT_EXACT_TEST(src)) {
            of_oxm_in_phy_port_masked_t *elt;
            elt = &oxm_entry.in_phy_port_masked;

            of_oxm_in_phy_port_masked_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_in_phy_port_masked_value_set(elt,
                   src->fields.in_phy_port);
            of_oxm_in_phy_port_masked_value_mask_set(elt,
                   src->masks.in_phy_port);
        } else {  /* Active, but not masked */
            of_oxm_in_phy_port_t *elt;
            elt = &oxm_entry.in_phy_port;
            of_oxm_in_phy_port_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_in_phy_port_value_set(elt, src->fields.in_phy_port);
        }
    }
    if (OF_MATCH_MASK_IPV4_DST_ACTIVE_TEST(src)) {
        if (!OF_MATCH_MASK_IPV4_DST_EXACT_TEST(src)) {
            of_oxm_ipv4_dst_masked_t *elt;
            elt = &oxm_entry.ipv4_dst_masked;

            of_oxm_ipv4_dst_masked_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_ipv4_dst_masked_value_set(elt,
                   src->fields.ipv4_dst);
            of_oxm_ipv4_dst_masked_value_mask_set(elt,
                   src->masks.ipv4_dst);
        } else {  /* Active, but not masked */
            of_oxm_ipv4_dst_t *elt;
            elt = &oxm_entry.ipv4_dst;
            of_oxm_ipv4_dst_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_ipv4_dst_value_set(elt, src->fields.ipv4_dst);
        }
    }
    if (OF_MATCH_MASK_ETH_SRC_ACTIVE_TEST(src)) {
        if (!OF_MATCH_MASK_ETH_SRC_EXACT_TEST(src)) {
            of_oxm_eth_src_masked_t *elt;
            elt = &oxm_entry.eth_src_masked;

            of_oxm_eth_src_masked_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_eth_src_masked_value_set(elt,
                   src->fields.eth_src);
            of_oxm_eth_src_masked_value_mask_set(elt,
                   src->masks.eth_src);
        } else {  /* Active, but not masked */
            of_oxm_eth_src_t *elt;
            elt = &oxm_entry.eth_src;
            of_oxm_eth_src_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_eth_src_value_set(elt, src->fields.eth_src);
        }
    }
    if (OF_MATCH_MASK_UDP_SRC_ACTIVE_TEST(src)) {
        if (!OF_MATCH_MASK_UDP_SRC_EXACT_TEST(src)) {
            of_oxm_udp_src_masked_t *elt;
            elt = &oxm_entry.udp_src_masked;

            of_oxm_udp_src_masked_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_udp_src_masked_value_set(elt,
                   src->fields.udp_src);
            of_oxm_udp_src_masked_value_mask_set(elt,
                   src->masks.udp_src);
        } else {  /* Active, but not masked */
            of_oxm_udp_src_t *elt;
            elt = &oxm_entry.udp_src;
            of_oxm_udp_src_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_udp_src_value_set(elt, src->fields.udp_src);
        }
    }
    if (OF_MATCH_MASK_IPV6_ND_TLL_ACTIVE_TEST(src)) {
        if (!OF_MATCH_MASK_IPV6_ND_TLL_EXACT_TEST(src)) {
            of_oxm_ipv6_nd_tll_masked_t *elt;
            elt = &oxm_entry.ipv6_nd_tll_masked;

            of_oxm_ipv6_nd_tll_masked_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_ipv6_nd_tll_masked_value_set(elt,
                   src->fields.ipv6_nd_tll);
            of_oxm_ipv6_nd_tll_masked_value_mask_set(elt,
                   src->masks.ipv6_nd_tll);
        } else {  /* Active, but not masked */
            of_oxm_ipv6_nd_tll_t *elt;
            elt = &oxm_entry.ipv6_nd_tll;
            of_oxm_ipv6_nd_tll_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_ipv6_nd_tll_value_set(elt, src->fields.ipv6_nd_tll);
        }
    }
    if (OF_MATCH_MASK_ICMPV4_TYPE_ACTIVE_TEST(src)) {
        if (!OF_MATCH_MASK_ICMPV4_TYPE_EXACT_TEST(src)) {
            of_oxm_icmpv4_type_masked_t *elt;
            elt = &oxm_entry.icmpv4_type_masked;

            of_oxm_icmpv4_type_masked_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_icmpv4_type_masked_value_set(elt,
                   src->fields.icmpv4_type);
            of_oxm_icmpv4_type_masked_value_mask_set(elt,
                   src->masks.icmpv4_type);
        } else {  /* Active, but not masked */
            of_oxm_icmpv4_type_t *elt;
            elt = &oxm_entry.icmpv4_type;
            of_oxm_icmpv4_type_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_icmpv4_type_value_set(elt, src->fields.icmpv4_type);
        }
    }
    if (OF_MATCH_MASK_MPLS_LABEL_ACTIVE_TEST(src)) {
        if (!OF_MATCH_MASK_MPLS_LABEL_EXACT_TEST(src)) {
            of_oxm_mpls_label_masked_t *elt;
            elt = &oxm_entry.mpls_label_masked;

            of_oxm_mpls_label_masked_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_mpls_label_masked_value_set(elt,
                   src->fields.mpls_label);
            of_oxm_mpls_label_masked_value_mask_set(elt,
                   src->masks.mpls_label);
        } else {  /* Active, but not masked */
            of_oxm_mpls_label_t *elt;
            elt = &oxm_entry.mpls_label;
            of_oxm_mpls_label_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_mpls_label_value_set(elt, src->fields.mpls_label);
        }
    }
    if (OF_MATCH_MASK_TCP_DST_ACTIVE_TEST(src)) {
        if (!OF_MATCH_MASK_TCP_DST_EXACT_TEST(src)) {
            of_oxm_tcp_dst_masked_t *elt;
            elt = &oxm_entry.tcp_dst_masked;

            of_oxm_tcp_dst_masked_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_tcp_dst_masked_value_set(elt,
                   src->fields.tcp_dst);
            of_oxm_tcp_dst_masked_value_mask_set(elt,
                   src->masks.tcp_dst);
        } else {  /* Active, but not masked */
            of_oxm_tcp_dst_t *elt;
            elt = &oxm_entry.tcp_dst;
            of_oxm_tcp_dst_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_tcp_dst_value_set(elt, src->fields.tcp_dst);
        }
    }
    if (OF_MATCH_MASK_IP_PROTO_ACTIVE_TEST(src)) {
        if (!OF_MATCH_MASK_IP_PROTO_EXACT_TEST(src)) {
            of_oxm_ip_proto_masked_t *elt;
            elt = &oxm_entry.ip_proto_masked;

            of_oxm_ip_proto_masked_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_ip_proto_masked_value_set(elt,
                   src->fields.ip_proto);
            of_oxm_ip_proto_masked_value_mask_set(elt,
                   src->masks.ip_proto);
        } else {  /* Active, but not masked */
            of_oxm_ip_proto_t *elt;
            elt = &oxm_entry.ip_proto;
            of_oxm_ip_proto_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_ip_proto_value_set(elt, src->fields.ip_proto);
        }
    }
    if (OF_MATCH_MASK_METADATA_ACTIVE_TEST(src)) {
        if (!OF_MATCH_MASK_METADATA_EXACT_TEST(src)) {
            of_oxm_metadata_masked_t *elt;
            elt = &oxm_entry.metadata_masked;

            of_oxm_metadata_masked_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_metadata_masked_value_set(elt,
                   src->fields.metadata);
            of_oxm_metadata_masked_value_mask_set(elt,
                   src->masks.metadata);
        } else {  /* Active, but not masked */
            of_oxm_metadata_t *elt;
            elt = &oxm_entry.metadata;
            of_oxm_metadata_init(elt,
                src->version, -1, 1);
            of_list_oxm_append_bind(oxm_list, &oxm_entry);
            of_oxm_metadata_value_set(elt, src->fields.metadata);
        }
    }

    return OF_ERROR_NONE;
}

/**
 * Convert a generic match object to an OF_VERSION_1_2 object
 * @param src Pointer to the generic match object source
 * @param dst Pointer to the OF 1.2 wire structure
 *
 * The wire structure is initialized by this function if the object
 * id is not correct in the object
 */

int
of_match_to_wire_match_v3(of_match_t *src, of_match_v3_t *dst)
{
    int rv = OF_ERROR_NONE;
    of_list_oxm_t *oxm_list;

    if ((src == NULL) || (dst == NULL)) {
        return OF_ERROR_PARAM;
    }
    if (dst->object_id != OF_MATCH_V3) {
        of_match_v3_init(dst, src->version, 0, 0);
    }
    if ((oxm_list = of_list_oxm_new(src->version)) == NULL) {
        return OF_ERROR_RESOURCE;
    }

    rv = populate_oxm_list(src, oxm_list);

    if (rv == OF_ERROR_NONE) {
        rv = of_match_v3_oxm_list_set(dst, oxm_list);
    }

    of_list_oxm_delete(oxm_list);

    return rv;
}


/**
 * Convert an OF_VERSION_1_0 object to a generic match object
 * @param src Pointer to the OF 1.0 wire structure source
 * @param dst Pointer to the generic match object destination
 *
 * The wire structure is initialized by this function.
 */

int
of_match_v1_to_match(of_match_v1_t *src, of_match_t *dst)
{
    of_wc_bmap_t wc;
    int count;

    MEMSET(dst, 0, sizeof(*dst));
    dst->version = src->version;

    of_match_v1_wildcards_get(src, &wc);

    /* Handle L3 src and dst wildcarding first */
    /* @fixme Check mask values are properly treated for ipv4 src/dst */
    if ((count = OF_MATCH_V1_WC_IPV4_DST_GET(wc)) < 32) {
        of_match_v1_ipv4_dst_get(src, &dst->fields.ipv4_dst);
        if (count > 0) { /* Not exact match */
            dst->masks.ipv4_dst = ~(((uint32_t)1 << count) - 1);
        } else {
            OF_MATCH_MASK_IPV4_DST_EXACT_SET(dst);
        }
    }

    if (!(OF_MATCH_V1_WC_DST_META_ID_TEST(wc))) {
        of_match_v1_dst_meta_id_get(src, &dst->fields.dst_meta_id);
        OF_MATCH_MASK_DST_META_ID_EXACT_SET(dst);
    }

    if (!(OF_MATCH_V1_WC_ETH_DST_TEST(wc))) {
        of_match_v1_eth_dst_get(src, &dst->fields.eth_dst);
        OF_MATCH_MASK_ETH_DST_EXACT_SET(dst);
    }

    if (!(OF_MATCH_V1_WC_ETH_SRC_TEST(wc))) {
        of_match_v1_eth_src_get(src, &dst->fields.eth_src);
        OF_MATCH_MASK_ETH_SRC_EXACT_SET(dst);
    }

    if (!(OF_MATCH_V1_WC_ETH_TYPE_TEST(wc))) {
        of_match_v1_eth_type_get(src, &dst->fields.eth_type);
        OF_MATCH_MASK_ETH_TYPE_EXACT_SET(dst);
    }

    if (!(OF_MATCH_V1_WC_IN_PORT_TEST(wc))) {
        of_match_v1_in_port_get(src, &dst->fields.in_port);
        OF_MATCH_MASK_IN_PORT_EXACT_SET(dst);
    }

    if (!(OF_MATCH_V1_WC_IP_DSCP_TEST(wc))) {
        of_match_v1_ip_dscp_get(src, &dst->fields.ip_dscp);
        OF_MATCH_MASK_IP_DSCP_EXACT_SET(dst);
    }

    if (!(OF_MATCH_V1_WC_IP_PROTO_TEST(wc))) {
        of_match_v1_ip_proto_get(src, &dst->fields.ip_proto);
        OF_MATCH_MASK_IP_PROTO_EXACT_SET(dst);
    }

    count = OF_MATCH_V1_WC_IPV4_DST_GET(wc);
    dst->masks.ipv4_dst = of_ip_index_to_mask(count);
    /* @todo Review if we should only get the addr when masks.ipv4_dst != 0 */
    of_match_v1_ipv4_dst_get(src, &dst->fields.ipv4_dst);

    count = OF_MATCH_V1_WC_IPV4_SRC_GET(wc);
    dst->masks.ipv4_src = of_ip_index_to_mask(count);
    /* @todo Review if we should only get the addr when masks.ipv4_src != 0 */
    of_match_v1_ipv4_src_get(src, &dst->fields.ipv4_src);

    if (!(OF_MATCH_V1_WC_SRC_META_ID_TEST(wc))) {
        of_match_v1_src_meta_id_get(src, &dst->fields.src_meta_id);
        OF_MATCH_MASK_SRC_META_ID_EXACT_SET(dst);
    }

    if (!(OF_MATCH_V1_WC_TCP_DST_TEST(wc))) {
        of_match_v1_tcp_dst_get(src, &dst->fields.tcp_dst);
        OF_MATCH_MASK_TCP_DST_EXACT_SET(dst);
    }

    if (!(OF_MATCH_V1_WC_TCP_SRC_TEST(wc))) {
        of_match_v1_tcp_src_get(src, &dst->fields.tcp_src);
        OF_MATCH_MASK_TCP_SRC_EXACT_SET(dst);
    }

    if (!(OF_MATCH_V1_WC_VLAN_PCP_TEST(wc))) {
        of_match_v1_vlan_pcp_get(src, &dst->fields.vlan_pcp);
        OF_MATCH_MASK_VLAN_PCP_EXACT_SET(dst);
    }

    if (!(OF_MATCH_V1_WC_VLAN_VID_TEST(wc))) {
        of_match_v1_vlan_vid_get(src, &dst->fields.vlan_vid);
        OF_MATCH_MASK_VLAN_VID_EXACT_SET(dst);
    }

    return OF_ERROR_NONE;
}

int
of_match_v2_to_match(of_match_v2_t *src, of_match_t *dst)
{
    of_wc_bmap_t wc;

    MEMSET(dst, 0, sizeof(*dst));
    dst->version = src->version;

    of_match_v2_wildcards_get(src, &wc);

    of_match_v2_eth_dst_mask_get(src, &dst->masks.eth_dst);
    if (OF_VARIABLE_IS_NON_ZERO(&dst->masks.eth_dst)) { /* Matching something */
        of_match_v2_eth_dst_get(src, &dst->fields.eth_dst);
    }

    of_match_v2_eth_src_mask_get(src, &dst->masks.eth_src);
    if (OF_VARIABLE_IS_NON_ZERO(&dst->masks.eth_src)) { /* Matching something */
        of_match_v2_eth_src_get(src, &dst->fields.eth_src);
    }

    if (!(OF_MATCH_V2_WC_ETH_TYPE_TEST(wc))) {
        of_match_v2_eth_type_get(src, &dst->fields.eth_type);
        OF_MATCH_MASK_ETH_TYPE_EXACT_SET(dst);
    }

    if (!(OF_MATCH_V2_WC_IN_PORT_TEST(wc))) {
        of_match_v2_in_port_get(src, &dst->fields.in_port);
        OF_MATCH_MASK_IN_PORT_EXACT_SET(dst);
    }

    of_match_v2_ipv4_dst_mask_get(src, &dst->masks.ipv4_dst);
    if (OF_VARIABLE_IS_NON_ZERO(&dst->masks.ipv4_dst)) { /* Matching something */
        of_match_v2_ipv4_dst_get(src, &dst->fields.ipv4_dst);
    }

    if (!(OF_MATCH_V2_WC_IP_PROTO_TEST(wc))) {
        of_match_v2_ip_proto_get(src, &dst->fields.ip_proto);
        OF_MATCH_MASK_IP_PROTO_EXACT_SET(dst);
    }

    of_match_v2_ipv4_src_mask_get(src, &dst->masks.ipv4_src);
    if (OF_VARIABLE_IS_NON_ZERO(&dst->masks.ipv4_src)) { /* Matching something */
        of_match_v2_ipv4_src_get(src, &dst->fields.ipv4_src);
    }

    if (!(OF_MATCH_V2_WC_IP_DSCP_TEST(wc))) {
        of_match_v2_ip_dscp_get(src, &dst->fields.ip_dscp);
        OF_MATCH_MASK_IP_DSCP_EXACT_SET(dst);
    }

    if (!(OF_MATCH_V2_WC_TCP_DST_TEST(wc))) {
        of_match_v2_tcp_dst_get(src, &dst->fields.tcp_dst);
        OF_MATCH_MASK_TCP_DST_EXACT_SET(dst);
    }

    if (!(OF_MATCH_V2_WC_TCP_SRC_TEST(wc))) {
        of_match_v2_tcp_src_get(src, &dst->fields.tcp_src);
        OF_MATCH_MASK_TCP_SRC_EXACT_SET(dst);
    }

    if (!(OF_MATCH_V2_WC_VLAN_PCP_TEST(wc))) {
        of_match_v2_vlan_pcp_get(src, &dst->fields.vlan_pcp);
        OF_MATCH_MASK_VLAN_PCP_EXACT_SET(dst);
    }

    if (!(OF_MATCH_V2_WC_VLAN_VID_TEST(wc))) {
        of_match_v2_vlan_vid_get(src, &dst->fields.vlan_vid);
        OF_MATCH_MASK_VLAN_VID_EXACT_SET(dst);
    }

    if (!(OF_MATCH_V2_WC_MPLS_LABEL_TEST(wc))) {
        of_match_v2_mpls_label_get(src, &dst->fields.mpls_label);
        OF_MATCH_MASK_MPLS_LABEL_EXACT_SET(dst);
    }

    if (!(OF_MATCH_V2_WC_MPLS_TC_TEST(wc))) {
        of_match_v2_mpls_tc_get(src, &dst->fields.mpls_tc);
        OF_MATCH_MASK_MPLS_TC_EXACT_SET(dst);
    }

    of_match_v2_metadata_mask_get(src, &dst->masks.metadata);
    if (OF_VARIABLE_IS_NON_ZERO(&dst->masks.metadata)) { /* Matching something */
        of_match_v2_metadata_get(src, &dst->fields.metadata);
    }

    return OF_ERROR_NONE;
}

int
of_match_v3_to_match(of_match_v3_t *src, of_match_t *dst)
{
    int rv;
    of_list_oxm_t oxm_list;
    of_oxm_t oxm_entry;

    MEMSET(dst, 0, sizeof(*dst));
    dst->version = src->version;

    of_match_v3_oxm_list_bind(src, &oxm_list);
    rv = of_list_oxm_first(&oxm_list, &oxm_entry);

    while (rv == OF_ERROR_NONE) {
        switch (oxm_entry.header.object_id) { /* What kind of entry is this */

        case OF_OXM_IPV6_FLABEL_MASKED:
            of_oxm_ipv6_flabel_masked_value_mask_get(
                &oxm_entry.ipv6_flabel_masked,
                &dst->masks.ipv6_flabel);
            of_oxm_ipv6_flabel_masked_value_get(
                &oxm_entry.ipv6_flabel,
                &dst->fields.ipv6_flabel);
            break;
        case OF_OXM_IPV6_FLABEL:
            OF_MATCH_MASK_IPV6_FLABEL_EXACT_SET(dst);
            of_oxm_ipv6_flabel_value_get(
                &oxm_entry.ipv6_flabel,
                &dst->fields.ipv6_flabel);
            break;

        case OF_OXM_VLAN_PCP_MASKED:
            of_oxm_vlan_pcp_masked_value_mask_get(
                &oxm_entry.vlan_pcp_masked,
                &dst->masks.vlan_pcp);
            of_oxm_vlan_pcp_masked_value_get(
                &oxm_entry.vlan_pcp,
                &dst->fields.vlan_pcp);
            break;
        case OF_OXM_VLAN_PCP:
            OF_MATCH_MASK_VLAN_PCP_EXACT_SET(dst);
            of_oxm_vlan_pcp_value_get(
                &oxm_entry.vlan_pcp,
                &dst->fields.vlan_pcp);
            break;

        case OF_OXM_IPV4_SRC_MASKED:
            of_oxm_ipv4_src_masked_value_mask_get(
                &oxm_entry.ipv4_src_masked,
                &dst->masks.ipv4_src);
            of_oxm_ipv4_src_masked_value_get(
                &oxm_entry.ipv4_src,
                &dst->fields.ipv4_src);
            break;
        case OF_OXM_IPV4_SRC:
            OF_MATCH_MASK_IPV4_SRC_EXACT_SET(dst);
            of_oxm_ipv4_src_value_get(
                &oxm_entry.ipv4_src,
                &dst->fields.ipv4_src);
            break;

        case OF_OXM_IPV6_DST_MASKED:
            of_oxm_ipv6_dst_masked_value_mask_get(
                &oxm_entry.ipv6_dst_masked,
                &dst->masks.ipv6_dst);
            of_oxm_ipv6_dst_masked_value_get(
                &oxm_entry.ipv6_dst,
                &dst->fields.ipv6_dst);
            break;
        case OF_OXM_IPV6_DST:
            OF_MATCH_MASK_IPV6_DST_EXACT_SET(dst);
            of_oxm_ipv6_dst_value_get(
                &oxm_entry.ipv6_dst,
                &dst->fields.ipv6_dst);
            break;

        case OF_OXM_ARP_TPA_MASKED:
            of_oxm_arp_tpa_masked_value_mask_get(
                &oxm_entry.arp_tpa_masked,
                &dst->masks.arp_tpa);
            of_oxm_arp_tpa_masked_value_get(
                &oxm_entry.arp_tpa,
                &dst->fields.arp_tpa);
            break;
        case OF_OXM_ARP_TPA:
            OF_MATCH_MASK_ARP_TPA_EXACT_SET(dst);
            of_oxm_arp_tpa_value_get(
                &oxm_entry.arp_tpa,
                &dst->fields.arp_tpa);
            break;

        case OF_OXM_ICMPV6_TYPE_MASKED:
            of_oxm_icmpv6_type_masked_value_mask_get(
                &oxm_entry.icmpv6_type_masked,
                &dst->masks.icmpv6_type);
            of_oxm_icmpv6_type_masked_value_get(
                &oxm_entry.icmpv6_type,
                &dst->fields.icmpv6_type);
            break;
        case OF_OXM_ICMPV6_TYPE:
            OF_MATCH_MASK_ICMPV6_TYPE_EXACT_SET(dst);
            of_oxm_icmpv6_type_value_get(
                &oxm_entry.icmpv6_type,
                &dst->fields.icmpv6_type);
            break;

        case OF_OXM_ARP_SHA_MASKED:
            of_oxm_arp_sha_masked_value_mask_get(
                &oxm_entry.arp_sha_masked,
                &dst->masks.arp_sha);
            of_oxm_arp_sha_masked_value_get(
                &oxm_entry.arp_sha,
                &dst->fields.arp_sha);
            break;
        case OF_OXM_ARP_SHA:
            OF_MATCH_MASK_ARP_SHA_EXACT_SET(dst);
            of_oxm_arp_sha_value_get(
                &oxm_entry.arp_sha,
                &dst->fields.arp_sha);
            break;

        case OF_OXM_IPV6_SRC_MASKED:
            of_oxm_ipv6_src_masked_value_mask_get(
                &oxm_entry.ipv6_src_masked,
                &dst->masks.ipv6_src);
            of_oxm_ipv6_src_masked_value_get(
                &oxm_entry.ipv6_src,
                &dst->fields.ipv6_src);
            break;
        case OF_OXM_IPV6_SRC:
            OF_MATCH_MASK_IPV6_SRC_EXACT_SET(dst);
            of_oxm_ipv6_src_value_get(
                &oxm_entry.ipv6_src,
                &dst->fields.ipv6_src);
            break;

        case OF_OXM_SCTP_SRC_MASKED:
            of_oxm_sctp_src_masked_value_mask_get(
                &oxm_entry.sctp_src_masked,
                &dst->masks.sctp_src);
            of_oxm_sctp_src_masked_value_get(
                &oxm_entry.sctp_src,
                &dst->fields.sctp_src);
            break;
        case OF_OXM_SCTP_SRC:
            OF_MATCH_MASK_SCTP_SRC_EXACT_SET(dst);
            of_oxm_sctp_src_value_get(
                &oxm_entry.sctp_src,
                &dst->fields.sctp_src);
            break;

        case OF_OXM_ICMPV6_CODE_MASKED:
            of_oxm_icmpv6_code_masked_value_mask_get(
                &oxm_entry.icmpv6_code_masked,
                &dst->masks.icmpv6_code);
            of_oxm_icmpv6_code_masked_value_get(
                &oxm_entry.icmpv6_code,
                &dst->fields.icmpv6_code);
            break;
        case OF_OXM_ICMPV6_CODE:
            OF_MATCH_MASK_ICMPV6_CODE_EXACT_SET(dst);
            of_oxm_icmpv6_code_value_get(
                &oxm_entry.icmpv6_code,
                &dst->fields.icmpv6_code);
            break;

        case OF_OXM_ETH_DST_MASKED:
            of_oxm_eth_dst_masked_value_mask_get(
                &oxm_entry.eth_dst_masked,
                &dst->masks.eth_dst);
            of_oxm_eth_dst_masked_value_get(
                &oxm_entry.eth_dst,
                &dst->fields.eth_dst);
            break;
        case OF_OXM_ETH_DST:
            OF_MATCH_MASK_ETH_DST_EXACT_SET(dst);
            of_oxm_eth_dst_value_get(
                &oxm_entry.eth_dst,
                &dst->fields.eth_dst);
            break;

        case OF_OXM_IPV6_ND_SLL_MASKED:
            of_oxm_ipv6_nd_sll_masked_value_mask_get(
                &oxm_entry.ipv6_nd_sll_masked,
                &dst->masks.ipv6_nd_sll);
            of_oxm_ipv6_nd_sll_masked_value_get(
                &oxm_entry.ipv6_nd_sll,
                &dst->fields.ipv6_nd_sll);
            break;
        case OF_OXM_IPV6_ND_SLL:
            OF_MATCH_MASK_IPV6_ND_SLL_EXACT_SET(dst);
            of_oxm_ipv6_nd_sll_value_get(
                &oxm_entry.ipv6_nd_sll,
                &dst->fields.ipv6_nd_sll);
            break;

        case OF_OXM_MPLS_TC_MASKED:
            of_oxm_mpls_tc_masked_value_mask_get(
                &oxm_entry.mpls_tc_masked,
                &dst->masks.mpls_tc);
            of_oxm_mpls_tc_masked_value_get(
                &oxm_entry.mpls_tc,
                &dst->fields.mpls_tc);
            break;
        case OF_OXM_MPLS_TC:
            OF_MATCH_MASK_MPLS_TC_EXACT_SET(dst);
            of_oxm_mpls_tc_value_get(
                &oxm_entry.mpls_tc,
                &dst->fields.mpls_tc);
            break;

        case OF_OXM_ARP_OP_MASKED:
            of_oxm_arp_op_masked_value_mask_get(
                &oxm_entry.arp_op_masked,
                &dst->masks.arp_op);
            of_oxm_arp_op_masked_value_get(
                &oxm_entry.arp_op,
                &dst->fields.arp_op);
            break;
        case OF_OXM_ARP_OP:
            OF_MATCH_MASK_ARP_OP_EXACT_SET(dst);
            of_oxm_arp_op_value_get(
                &oxm_entry.arp_op,
                &dst->fields.arp_op);
            break;

        case OF_OXM_ETH_TYPE_MASKED:
            of_oxm_eth_type_masked_value_mask_get(
                &oxm_entry.eth_type_masked,
                &dst->masks.eth_type);
            of_oxm_eth_type_masked_value_get(
                &oxm_entry.eth_type,
                &dst->fields.eth_type);
            break;
        case OF_OXM_ETH_TYPE:
            OF_MATCH_MASK_ETH_TYPE_EXACT_SET(dst);
            of_oxm_eth_type_value_get(
                &oxm_entry.eth_type,
                &dst->fields.eth_type);
            break;

        case OF_OXM_DST_META_ID_MASKED:
            of_oxm_dst_meta_id_masked_value_mask_get(
                &oxm_entry.dst_meta_id_masked,
                &dst->masks.dst_meta_id);
            of_oxm_dst_meta_id_masked_value_get(
                &oxm_entry.dst_meta_id,
                &dst->fields.dst_meta_id);
            break;
        case OF_OXM_DST_META_ID:
            OF_MATCH_MASK_DST_META_ID_EXACT_SET(dst);
            of_oxm_dst_meta_id_value_get(
                &oxm_entry.dst_meta_id,
                &dst->fields.dst_meta_id);
            break;

        case OF_OXM_VLAN_VID_MASKED:
            of_oxm_vlan_vid_masked_value_mask_get(
                &oxm_entry.vlan_vid_masked,
                &dst->masks.vlan_vid);
            of_oxm_vlan_vid_masked_value_get(
                &oxm_entry.vlan_vid,
                &dst->fields.vlan_vid);
            break;
        case OF_OXM_VLAN_VID:
            OF_MATCH_MASK_VLAN_VID_EXACT_SET(dst);
            of_oxm_vlan_vid_value_get(
                &oxm_entry.vlan_vid,
                &dst->fields.vlan_vid);
            break;

        case OF_OXM_ARP_THA_MASKED:
            of_oxm_arp_tha_masked_value_mask_get(
                &oxm_entry.arp_tha_masked,
                &dst->masks.arp_tha);
            of_oxm_arp_tha_masked_value_get(
                &oxm_entry.arp_tha,
                &dst->fields.arp_tha);
            break;
        case OF_OXM_ARP_THA:
            OF_MATCH_MASK_ARP_THA_EXACT_SET(dst);
            of_oxm_arp_tha_value_get(
                &oxm_entry.arp_tha,
                &dst->fields.arp_tha);
            break;

        case OF_OXM_IN_PORT_MASKED:
            of_oxm_in_port_masked_value_mask_get(
                &oxm_entry.in_port_masked,
                &dst->masks.in_port);
            of_oxm_in_port_masked_value_get(
                &oxm_entry.in_port,
                &dst->fields.in_port);
            break;
        case OF_OXM_IN_PORT:
            OF_MATCH_MASK_IN_PORT_EXACT_SET(dst);
            of_oxm_in_port_value_get(
                &oxm_entry.in_port,
                &dst->fields.in_port);
            break;

        case OF_OXM_IP_DSCP_MASKED:
            of_oxm_ip_dscp_masked_value_mask_get(
                &oxm_entry.ip_dscp_masked,
                &dst->masks.ip_dscp);
            of_oxm_ip_dscp_masked_value_get(
                &oxm_entry.ip_dscp,
                &dst->fields.ip_dscp);
            break;
        case OF_OXM_IP_DSCP:
            OF_MATCH_MASK_IP_DSCP_EXACT_SET(dst);
            of_oxm_ip_dscp_value_get(
                &oxm_entry.ip_dscp,
                &dst->fields.ip_dscp);
            break;

        case OF_OXM_SCTP_DST_MASKED:
            of_oxm_sctp_dst_masked_value_mask_get(
                &oxm_entry.sctp_dst_masked,
                &dst->masks.sctp_dst);
            of_oxm_sctp_dst_masked_value_get(
                &oxm_entry.sctp_dst,
                &dst->fields.sctp_dst);
            break;
        case OF_OXM_SCTP_DST:
            OF_MATCH_MASK_SCTP_DST_EXACT_SET(dst);
            of_oxm_sctp_dst_value_get(
                &oxm_entry.sctp_dst,
                &dst->fields.sctp_dst);
            break;

        case OF_OXM_ICMPV4_CODE_MASKED:
            of_oxm_icmpv4_code_masked_value_mask_get(
                &oxm_entry.icmpv4_code_masked,
                &dst->masks.icmpv4_code);
            of_oxm_icmpv4_code_masked_value_get(
                &oxm_entry.icmpv4_code,
                &dst->fields.icmpv4_code);
            break;
        case OF_OXM_ICMPV4_CODE:
            OF_MATCH_MASK_ICMPV4_CODE_EXACT_SET(dst);
            of_oxm_icmpv4_code_value_get(
                &oxm_entry.icmpv4_code,
                &dst->fields.icmpv4_code);
            break;

        case OF_OXM_TCP_SRC_MASKED:
            of_oxm_tcp_src_masked_value_mask_get(
                &oxm_entry.tcp_src_masked,
                &dst->masks.tcp_src);
            of_oxm_tcp_src_masked_value_get(
                &oxm_entry.tcp_src,
                &dst->fields.tcp_src);
            break;
        case OF_OXM_TCP_SRC:
            OF_MATCH_MASK_TCP_SRC_EXACT_SET(dst);
            of_oxm_tcp_src_value_get(
                &oxm_entry.tcp_src,
                &dst->fields.tcp_src);
            break;

        case OF_OXM_ARP_SPA_MASKED:
            of_oxm_arp_spa_masked_value_mask_get(
                &oxm_entry.arp_spa_masked,
                &dst->masks.arp_spa);
            of_oxm_arp_spa_masked_value_get(
                &oxm_entry.arp_spa,
                &dst->fields.arp_spa);
            break;
        case OF_OXM_ARP_SPA:
            OF_MATCH_MASK_ARP_SPA_EXACT_SET(dst);
            of_oxm_arp_spa_value_get(
                &oxm_entry.arp_spa,
                &dst->fields.arp_spa);
            break;

        case OF_OXM_IP_ECN_MASKED:
            of_oxm_ip_ecn_masked_value_mask_get(
                &oxm_entry.ip_ecn_masked,
                &dst->masks.ip_ecn);
            of_oxm_ip_ecn_masked_value_get(
                &oxm_entry.ip_ecn,
                &dst->fields.ip_ecn);
            break;
        case OF_OXM_IP_ECN:
            OF_MATCH_MASK_IP_ECN_EXACT_SET(dst);
            of_oxm_ip_ecn_value_get(
                &oxm_entry.ip_ecn,
                &dst->fields.ip_ecn);
            break;

        case OF_OXM_SRC_META_ID_MASKED:
            of_oxm_src_meta_id_masked_value_mask_get(
                &oxm_entry.src_meta_id_masked,
                &dst->masks.src_meta_id);
            of_oxm_src_meta_id_masked_value_get(
                &oxm_entry.src_meta_id,
                &dst->fields.src_meta_id);
            break;
        case OF_OXM_SRC_META_ID:
            OF_MATCH_MASK_SRC_META_ID_EXACT_SET(dst);
            of_oxm_src_meta_id_value_get(
                &oxm_entry.src_meta_id,
                &dst->fields.src_meta_id);
            break;

        case OF_OXM_UDP_DST_MASKED:
            of_oxm_udp_dst_masked_value_mask_get(
                &oxm_entry.udp_dst_masked,
                &dst->masks.udp_dst);
            of_oxm_udp_dst_masked_value_get(
                &oxm_entry.udp_dst,
                &dst->fields.udp_dst);
            break;
        case OF_OXM_UDP_DST:
            OF_MATCH_MASK_UDP_DST_EXACT_SET(dst);
            of_oxm_udp_dst_value_get(
                &oxm_entry.udp_dst,
                &dst->fields.udp_dst);
            break;

        case OF_OXM_IPV6_ND_TARGET_MASKED:
            of_oxm_ipv6_nd_target_masked_value_mask_get(
                &oxm_entry.ipv6_nd_target_masked,
                &dst->masks.ipv6_nd_target);
            of_oxm_ipv6_nd_target_masked_value_get(
                &oxm_entry.ipv6_nd_target,
                &dst->fields.ipv6_nd_target);
            break;
        case OF_OXM_IPV6_ND_TARGET:
            OF_MATCH_MASK_IPV6_ND_TARGET_EXACT_SET(dst);
            of_oxm_ipv6_nd_target_value_get(
                &oxm_entry.ipv6_nd_target,
                &dst->fields.ipv6_nd_target);
            break;

        case OF_OXM_IN_PHY_PORT_MASKED:
            of_oxm_in_phy_port_masked_value_mask_get(
                &oxm_entry.in_phy_port_masked,
                &dst->masks.in_phy_port);
            of_oxm_in_phy_port_masked_value_get(
                &oxm_entry.in_phy_port,
                &dst->fields.in_phy_port);
            break;
        case OF_OXM_IN_PHY_PORT:
            OF_MATCH_MASK_IN_PHY_PORT_EXACT_SET(dst);
            of_oxm_in_phy_port_value_get(
                &oxm_entry.in_phy_port,
                &dst->fields.in_phy_port);
            break;

        case OF_OXM_IPV4_DST_MASKED:
            of_oxm_ipv4_dst_masked_value_mask_get(
                &oxm_entry.ipv4_dst_masked,
                &dst->masks.ipv4_dst);
            of_oxm_ipv4_dst_masked_value_get(
                &oxm_entry.ipv4_dst,
                &dst->fields.ipv4_dst);
            break;
        case OF_OXM_IPV4_DST:
            OF_MATCH_MASK_IPV4_DST_EXACT_SET(dst);
            of_oxm_ipv4_dst_value_get(
                &oxm_entry.ipv4_dst,
                &dst->fields.ipv4_dst);
            break;

        case OF_OXM_ETH_SRC_MASKED:
            of_oxm_eth_src_masked_value_mask_get(
                &oxm_entry.eth_src_masked,
                &dst->masks.eth_src);
            of_oxm_eth_src_masked_value_get(
                &oxm_entry.eth_src,
                &dst->fields.eth_src);
            break;
        case OF_OXM_ETH_SRC:
            OF_MATCH_MASK_ETH_SRC_EXACT_SET(dst);
            of_oxm_eth_src_value_get(
                &oxm_entry.eth_src,
                &dst->fields.eth_src);
            break;

        case OF_OXM_UDP_SRC_MASKED:
            of_oxm_udp_src_masked_value_mask_get(
                &oxm_entry.udp_src_masked,
                &dst->masks.udp_src);
            of_oxm_udp_src_masked_value_get(
                &oxm_entry.udp_src,
                &dst->fields.udp_src);
            break;
        case OF_OXM_UDP_SRC:
            OF_MATCH_MASK_UDP_SRC_EXACT_SET(dst);
            of_oxm_udp_src_value_get(
                &oxm_entry.udp_src,
                &dst->fields.udp_src);
            break;

        case OF_OXM_IPV6_ND_TLL_MASKED:
            of_oxm_ipv6_nd_tll_masked_value_mask_get(
                &oxm_entry.ipv6_nd_tll_masked,
                &dst->masks.ipv6_nd_tll);
            of_oxm_ipv6_nd_tll_masked_value_get(
                &oxm_entry.ipv6_nd_tll,
                &dst->fields.ipv6_nd_tll);
            break;
        case OF_OXM_IPV6_ND_TLL:
            OF_MATCH_MASK_IPV6_ND_TLL_EXACT_SET(dst);
            of_oxm_ipv6_nd_tll_value_get(
                &oxm_entry.ipv6_nd_tll,
                &dst->fields.ipv6_nd_tll);
            break;

        case OF_OXM_ICMPV4_TYPE_MASKED:
            of_oxm_icmpv4_type_masked_value_mask_get(
                &oxm_entry.icmpv4_type_masked,
                &dst->masks.icmpv4_type);
            of_oxm_icmpv4_type_masked_value_get(
                &oxm_entry.icmpv4_type,
                &dst->fields.icmpv4_type);
            break;
        case OF_OXM_ICMPV4_TYPE:
            OF_MATCH_MASK_ICMPV4_TYPE_EXACT_SET(dst);
            of_oxm_icmpv4_type_value_get(
                &oxm_entry.icmpv4_type,
                &dst->fields.icmpv4_type);
            break;

        case OF_OXM_MPLS_LABEL_MASKED:
            of_oxm_mpls_label_masked_value_mask_get(
                &oxm_entry.mpls_label_masked,
                &dst->masks.mpls_label);
            of_oxm_mpls_label_masked_value_get(
                &oxm_entry.mpls_label,
                &dst->fields.mpls_label);
            break;
        case OF_OXM_MPLS_LABEL:
            OF_MATCH_MASK_MPLS_LABEL_EXACT_SET(dst);
            of_oxm_mpls_label_value_get(
                &oxm_entry.mpls_label,
                &dst->fields.mpls_label);
            break;

        case OF_OXM_TCP_DST_MASKED:
            of_oxm_tcp_dst_masked_value_mask_get(
                &oxm_entry.tcp_dst_masked,
                &dst->masks.tcp_dst);
            of_oxm_tcp_dst_masked_value_get(
                &oxm_entry.tcp_dst,
                &dst->fields.tcp_dst);
            break;
        case OF_OXM_TCP_DST:
            OF_MATCH_MASK_TCP_DST_EXACT_SET(dst);
            of_oxm_tcp_dst_value_get(
                &oxm_entry.tcp_dst,
                &dst->fields.tcp_dst);
            break;

        case OF_OXM_IP_PROTO_MASKED:
            of_oxm_ip_proto_masked_value_mask_get(
                &oxm_entry.ip_proto_masked,
                &dst->masks.ip_proto);
            of_oxm_ip_proto_masked_value_get(
                &oxm_entry.ip_proto,
                &dst->fields.ip_proto);
            break;
        case OF_OXM_IP_PROTO:
            OF_MATCH_MASK_IP_PROTO_EXACT_SET(dst);
            of_oxm_ip_proto_value_get(
                &oxm_entry.ip_proto,
                &dst->fields.ip_proto);
            break;

        case OF_OXM_METADATA_MASKED:
            of_oxm_metadata_masked_value_mask_get(
                &oxm_entry.metadata_masked,
                &dst->masks.metadata);
            of_oxm_metadata_masked_value_get(
                &oxm_entry.metadata,
                &dst->fields.metadata);
            break;
        case OF_OXM_METADATA:
            OF_MATCH_MASK_METADATA_EXACT_SET(dst);
            of_oxm_metadata_value_get(
                &oxm_entry.metadata,
                &dst->fields.metadata);
            break;

        default:
             /* @fixme Add debug statement */
             return OF_ERROR_PARSE;
        } /* end switch */
        rv = of_list_oxm_next(&oxm_list, &oxm_entry);
    } /* end OXM iteration */

    return OF_ERROR_NONE;
}

/**
 * Serialize a match structure according to the version passed
 * @param version The version to use for serialization protocol
 * @param match Pointer to the structure to serialize
 * @param octets Pointer to an octets object to fill out
 *
 * A buffer is allocated using normal internal ALLOC/FREE semantics
 * and pointed to by the octets object.  The length of the resulting
 * serialization is in octets->bytes.
 *
 * For 1.2 matches, returns the padded serialized structure
 *
 * Note that FREE must be called on octets->data when processing of
 * the object is complete.
 */

int
of_match_serialize(of_version_t version, of_match_t *match, of_octets_t *octets)
{
    int rv;

    switch (version) {

    case OF_VERSION_1_0:
        {
            of_match_v1_t *wire_match;
            wire_match = of_match_v1_new(version);
            if (wire_match == NULL) {
                return OF_ERROR_RESOURCE;
            }
            if ((rv = of_match_to_wire_match_v1(match, wire_match)) < 0) {
                of_match_v1_delete(wire_match);
                return rv;
            }
            octets->bytes = OF_MATCH_BYTES(wire_match->length);
            of_object_wire_buffer_steal((of_object_t *)wire_match,
                                        &octets->data);
            of_match_v1_delete(wire_match);
        }
        break;

    case OF_VERSION_1_1:
        {
            of_match_v2_t *wire_match;
            wire_match = of_match_v2_new(version);
            if (wire_match == NULL) {
                return OF_ERROR_RESOURCE;
            }
            if ((rv = of_match_to_wire_match_v2(match, wire_match)) < 0) {
                of_match_v2_delete(wire_match);
                return rv;
            }
            octets->bytes = OF_MATCH_BYTES(wire_match->length);
            of_object_wire_buffer_steal((of_object_t *)wire_match,
                                        &octets->data);
            of_match_v2_delete(wire_match);
        }
        break;

    case OF_VERSION_1_2:
        {
            of_match_v3_t *wire_match;
            wire_match = of_match_v3_new(version);
            if (wire_match == NULL) {
                return OF_ERROR_RESOURCE;
            }
            if ((rv = of_match_to_wire_match_v3(match, wire_match)) < 0) {
                of_match_v3_delete(wire_match);
                return rv;
            }
            octets->bytes = OF_MATCH_BYTES(wire_match->length);
            of_object_wire_buffer_steal((of_object_t *)wire_match,
                                        &octets->data);
            of_match_v3_delete(wire_match);
        }
        break;

    case OF_VERSION_1_3:
        {
            of_match_v4_t *wire_match;
            wire_match = of_match_v4_new(version);
            if (wire_match == NULL) {
                return OF_ERROR_RESOURCE;
            }
            if ((rv = of_match_to_wire_match_v4(match, wire_match)) < 0) {
                of_match_v4_delete(wire_match);
                return rv;
            }
            octets->bytes = OF_MATCH_BYTES(wire_match->length);
            of_object_wire_buffer_steal((of_object_t *)wire_match,
                                        &octets->data);
            of_match_v4_delete(wire_match);
        }
        break;

    default:
        return OF_ERROR_COMPAT;
    }

    return OF_ERROR_NONE;
}

/**
 * Deserialize a match structure according to the version passed
 * @param version The version to use for deserialization protocol
 * @param match Pointer to the structure to fill out
 * @param octets Pointer to an octets object holding serial buffer
 *
 * Normally the octets object will point to a part of a wire buffer.
 */

int
of_match_deserialize(of_version_t version, of_match_t *match,
                     of_octets_t *octets)
{
    if (octets->bytes == 0) { /* No match specified means all wildcards */
        MEMSET(match, 0, sizeof(*match));
        match->version = version;

        return OF_ERROR_NONE;
    }

    switch (version) {

    case OF_VERSION_1_0:
        { /* FIXME: check init bytes */
            uint8_t *tmp;
            of_match_v1_t wire_match;
            of_match_v1_init(&wire_match,
                   OF_VERSION_1_0, -1, 1);
            of_object_buffer_bind((of_object_t *)&wire_match,
                octets->data, octets->bytes, NULL);
            OF_TRY(of_match_v1_to_match(&wire_match, match));

            /* Free the wire buffer control block without freeing
             * octets->bytes. */
            of_wire_buffer_steal(wire_match.wire_object.wbuf, &tmp);
        }
        break;

    case OF_VERSION_1_1:
        { /* FIXME: check init bytes */
            uint8_t *tmp;
            of_match_v2_t wire_match;
            of_match_v2_init(&wire_match,
                   OF_VERSION_1_1, -1, 1);
            of_object_buffer_bind((of_object_t *)&wire_match,
                octets->data, octets->bytes, NULL);
            OF_TRY(of_match_v2_to_match(&wire_match, match));

            /* Free the wire buffer control block without freeing
             * octets->bytes. */
            of_wire_buffer_steal(wire_match.wire_object.wbuf, &tmp);
        }
        break;

    case OF_VERSION_1_2:
        { /* FIXME: check init bytes */
            uint8_t *tmp;
            of_match_v3_t wire_match;
            of_match_v3_init(&wire_match,
                   OF_VERSION_1_2, -1, 1);
            of_object_buffer_bind((of_object_t *)&wire_match,
                octets->data, octets->bytes, NULL);
            OF_TRY(of_match_v3_to_match(&wire_match, match));

            /* Free the wire buffer control block without freeing
             * octets->bytes. */
            of_wire_buffer_steal(wire_match.wire_object.wbuf, &tmp);
        }
        break;

    case OF_VERSION_1_3:
        { /* FIXME: check init bytes */
            uint8_t *tmp;
            of_match_v4_t wire_match;
            of_match_v4_init(&wire_match,
                   OF_VERSION_1_3, -1, 1);
            of_object_buffer_bind((of_object_t *)&wire_match,
                octets->data, octets->bytes, NULL);
            OF_TRY(of_match_v4_to_match(&wire_match, match));

            /* Free the wire buffer control block without freeing
             * octets->bytes. */
            of_wire_buffer_steal(wire_match.wire_object.wbuf, &tmp);
        }
        break;

    default:
        return OF_ERROR_COMPAT;
    }

    return OF_ERROR_NONE;
}
